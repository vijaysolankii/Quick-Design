"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@liveblocks";
exports.ids = ["vendor-chunks/@liveblocks"];
exports.modules = {

/***/ "(ssr)/./node_modules/@liveblocks/core/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CommentsApiError: () => (/* binding */ CommentsApiError),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   NotificationsApiError: () => (/* binding */ NotificationsApiError),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   addReaction: () => (/* binding */ addReaction),\n/* harmony export */   applyOptimisticUpdates: () => (/* binding */ applyOptimisticUpdates),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   deleteComment: () => (/* binding */ deleteComment),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* binding */ getMentionedIdsFromCommentBody),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   kInternal: () => (/* binding */ kInternal),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   removeReaction: () => (/* binding */ removeReaction),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   upsertComment: () => (/* binding */ upsertComment),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"1.10.2\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (false) {} else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (true) {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let flagger;\n  const promise = new Promise((res) => {\n    flagger = res;\n  });\n  if (!flagger) {\n    throw new Error(\"Should never happen\");\n  }\n  return [promise, flagger];\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _onetimeObservers = /* @__PURE__ */ new Set();\n  const _observers = /* @__PURE__ */ new Set();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      notify(event);\n    }\n    _buffer = null;\n  }\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    _onetimeObservers.add(callback);\n    return () => _onetimeObservers.delete(callback);\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n    } else {\n      notify(event);\n    }\n  }\n  function notify(event) {\n    _onetimeObservers.forEach((callback) => callback(event));\n    _onetimeObservers.clear();\n    _observers.forEach((callback) => callback(event));\n  }\n  function clear() {\n    _onetimeObservers.clear();\n    _observers.clear();\n  }\n  function count() {\n    return _onetimeObservers.size + _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify: notifyOrBuffer,\n    subscribe,\n    subscribeOnce,\n    clear,\n    count,\n    waitUntil,\n    pause,\n    unpause,\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  constructor(initialContext) {\n    this.curr = initialContext;\n  }\n  get current() {\n    return this.curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.curr,\n      patch(patch) {\n        if (allowed) {\n          self.curr = Object.assign({}, self.curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get initialState() {\n    const result = this.states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.currentStateOrNull === null) {\n      if (this.runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.runningState = 1 /* STARTED */;\n    this.currentStateOrNull = this.initialState;\n    this.enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.exit(null);\n    this.runningState = 2 /* STOPPED */;\n    this.currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.runningState = 0 /* NOT_STARTED_YET */;\n    this.currentStateOrNull = null;\n    this.states = /* @__PURE__ */ new Set();\n    this.enterFns = /* @__PURE__ */ new Map();\n    this.cleanupStack = [];\n    this.knownEventTypes = /* @__PURE__ */ new Set();\n    this.allowedTransitions = /* @__PURE__ */ new Map();\n    this.currentContext = new SafeContext(initialContext);\n    this.eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n      willTransition: this.eventHub.willTransition.observable,\n      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n      willExitState: this.eventHub.willExitState.observable,\n      didEnterState: this.eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      let done = false;\n      void promiseFn(this.currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.getStatesMatching(nameOrPattern)) {\n      let map = this.allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern The state name, or state group pattern name.\n   * @param after          Number of milliseconds after which to take the\n   *                       transition. If in the mean time, another transition\n   *                       is taken, the timer will get cancelled.\n   * @param target     The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  getTargetFn(eventName) {\n    return this.allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  exit(levels) {\n    this.eventHub.willExitState.notify(this.currentState);\n    this.currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.cleanupStack.push(cleanupFn);\n        } else {\n          this.cleanupStack.push(null);\n        }\n      }\n    });\n    this.eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.transition(event, targetFn);\n    } else {\n      this.eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  transition(event, target) {\n    this.eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.exit(up);\n    }\n    this.currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.enter(down);\n    }\n  }\n};\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction newToLegacyStatus(status) {\n  switch (status) {\n    case \"connecting\":\n      return \"connecting\";\n    case \"connected\":\n      return \"open\";\n    case \"reconnecting\":\n      return \"unavailable\";\n    case \"disconnected\":\n      return \"failed\";\n    case \"initial\":\n      return \"closed\";\n    default:\n      return \"closed\";\n  }\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nvar LiveblocksError = class extends Error {\n  /** @internal */\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (code: ${event.code}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeEventSource();\n  onMessage.pause();\n  const onLiveblocksError = makeEventSource();\n  function fireErrorEvent(errmsg, errcode) {\n    return () => {\n      const err = new LiveblocksError(errmsg, errcode);\n      onLiveblocksError.notify(err);\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onLiveblocksError: onLiveblocksError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.machine = machine;\n    this.events = events;\n    this.cleanups = cleanups;\n  }\n  getLegacyStatus() {\n    return newToLegacyStatus(this.getStatus());\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.machine.stop();\n    let cleanup;\n    while (cleanup = this.cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      verifyTokenPermissions(parsed, options);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          verifyTokenPermissions(parsed, options);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  function verifyTokenPermissions(parsedToken, options) {\n    if (!options.roomId && parsedToken.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      if (Object.entries(parsedToken.parsed.perms).length === 0) {\n        return;\n      }\n      for (const [resource, scopes] of Object.entries(\n        parsedToken.parsed.perms\n      )) {\n        if (resource.includes(\"*\") && hasCorrespondingScopes(options.requestedScope, scopes)) {\n          return;\n        }\n      }\n      throw new StopRetrying(\n        \"The issued access token doesn't grant enough permissions. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/access-tokens-not-enough-permissions\"\n      );\n    }\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch2, endpoint, body) {\n  const res = await fetch2(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif ( true && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storage.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/stringify.ts\nfunction stringify(object, ...args) {\n  if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n    return JSON.stringify(object, ...args);\n  }\n  const sortedObject = Object.keys(object).sort().reduce(\n    (sortedObject2, key) => {\n      sortedObject2[key] = object[key];\n      return sortedObject2;\n    },\n    {}\n  );\n  return JSON.stringify(sortedObject, ...args);\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar DEFAULT_DELAY = 100;\nvar noop = () => {\n};\nvar BatchCall = class {\n  constructor(args) {\n    this.resolve = noop;\n    this.reject = noop;\n    this.promise = new Promise(noop);\n    this.args = args;\n  }\n};\nvar Batch = class {\n  constructor(callback, options) {\n    this.queue = [];\n    this.error = false;\n    this.callback = callback;\n    this.size = options?.size ?? DEFAULT_SIZE;\n    this.delay = options?.delay ?? DEFAULT_DELAY;\n  }\n  clearDelayTimeout() {\n    if (this.delayTimeoutId !== void 0) {\n      clearTimeout(this.delayTimeoutId);\n      this.delayTimeoutId = void 0;\n    }\n  }\n  schedule() {\n    if (this.queue.length === this.size) {\n      void this.flush();\n    } else if (this.queue.length === 1) {\n      this.clearDelayTimeout();\n      this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay);\n    }\n  }\n  async flush() {\n    if (this.queue.length === 0) {\n      return;\n    }\n    const calls = this.queue.splice(0);\n    const args = calls.map((call) => call.args);\n    try {\n      const results = await this.callback(args);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (result instanceof Error) {\n          call.reject(result);\n        } else if (result !== void 0) {\n          call.resolve(result);\n        } else {\n          if (Array.isArray(results)) {\n            call.reject(\n              new Error(\n                `Batch callback must return an array of the same length as the number of calls in the batch. Expected ${calls.length}, but got ${results.length}.`\n              )\n            );\n          } else {\n            call.reject(new Error(\"Batch callback must return an array.\"));\n          }\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(...args) {\n    const existingCall = this.queue.find(\n      (call2) => stringify(call2.args) === stringify(args)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(args);\n    call.promise = new Promise((resolve, reject) => {\n      call.resolve = resolve;\n      call.reject = reject;\n    });\n    this.queue.push(call);\n    this.schedule();\n    return call.promise;\n  }\n  clear() {\n    this.queue = [];\n    this.error = false;\n    this.clearDelayTimeout();\n  }\n};\nfunction createBatchStore(callback, options) {\n  const batch = new Batch(callback, options);\n  const cache = /* @__PURE__ */ new Map();\n  const eventSource2 = makeEventSource();\n  function getCacheKey(args) {\n    return stringify(args);\n  }\n  function setStateAndNotify(cacheKey, state) {\n    if (state) {\n      cache.set(cacheKey, state);\n    } else {\n      cache.delete(cacheKey);\n    }\n    eventSource2.notify(state);\n  }\n  async function get(...args) {\n    const cacheKey = getCacheKey(args);\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      setStateAndNotify(cacheKey, { isLoading: true });\n      const result = await batch.get(...args);\n      setStateAndNotify(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      setStateAndNotify(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getState(...args) {\n    const cacheKey = getCacheKey(args);\n    return cache.get(cacheKey);\n  }\n  return {\n    ...eventSource2,\n    get,\n    getState\n  };\n}\n\n// src/lib/create-store.ts\nfunction createStore(initialState) {\n  let state = initialState;\n  const subscribers = /* @__PURE__ */ new Set();\n  function get() {\n    return state;\n  }\n  function set(callback) {\n    const newState = callback(state);\n    if (state === newState) {\n      return;\n    }\n    state = newState;\n    for (const subscriber of subscribers) {\n      subscriber(state);\n    }\n  }\n  function subscribe(callback) {\n    subscribers.add(callback);\n    callback(state);\n    return () => {\n      subscribers.delete(callback);\n    };\n  }\n  return {\n    get,\n    set,\n    subscribe\n  };\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (true) {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (true) {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (true) {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const updatedAt = data.updatedAt ? new Date(data.updatedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url.toString();\n}\n\n// src/notifications.ts\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY = 50;\nfunction createNotificationsApi({\n  baseUrl,\n  authManager,\n  currentUserIdStore,\n  fetcher\n}) {\n  async function fetchJson(endpoint, options, params) {\n    const authValue = await authManager.getAuthValue({\n      requestedScope: \"comments:read\"\n    });\n    if (authValue.type === \"secret\" && authValue.token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      const userId = authValue.token.parsed.uid;\n      currentUserIdStore.set(() => userId);\n    }\n    const url = urljoin(baseUrl, `/v2/c${endpoint}`, params);\n    const response = await fetcher(url.toString(), {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getInboxNotifications(options) {\n    const json = await fetchJson(\"/inbox-notifications\", void 0, {\n      limit: options?.limit,\n      since: options?.since?.toISOString()\n    });\n    return {\n      threads: json.threads.map((thread) => convertToThreadData(thread)),\n      inboxNotifications: json.inboxNotifications.map(\n        (notification) => convertToInboxNotificationData(notification)\n      ),\n      deletedThreads: json.deletedThreads.map(\n        (info) => convertToThreadDeleteInfo(info)\n      ),\n      deletedInboxNotifications: json.deletedInboxNotifications.map(\n        (info) => convertToInboxNotificationDeleteInfo(info)\n      ),\n      meta: {\n        requestedAt: new Date(json.meta.requestedAt)\n      }\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await fetchJson(\"/inbox-notifications/count\");\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds: \"all\" })\n    });\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead\n  };\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  constructor() {\n    /** @internal */\n    this._parent = NoParent;\n  }\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.__pool;\n  }\n  get roomId() {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.__id;\n  }\n  /** @internal */\n  get parent() {\n    return this._parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this._parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.__id = id;\n    this.__pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this._parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this._parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.__pool = void 0;\n  }\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n      this._cachedImmutable = void 0;\n      this._cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n      this._cachedTreeNodeKey = key;\n      this._cachedTreeNode = this._toTreeNode(key);\n    }\n    return this._cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this._cachedImmutable === void 0) {\n      this._cachedImmutable = this._toImmutable();\n    }\n    return this._cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/lib/nanoid.ts\nfunction nanoid(length = 7) {\n  const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-\";\n  const len = alphabet.length;\n  return Array.from(\n    { length },\n    () => alphabet.charAt(Math.floor(Math.random() * len))\n  ).join(\"\");\n}\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  constructor(data) {\n    super();\n    this._data = data;\n  }\n  get data() {\n    return this._data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  constructor(items = []) {\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this._unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this._items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList();\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this._items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this._unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this._items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this._items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this._items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n        this._items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  /** @internal */\n  _applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this._items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        );\n        this._items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition));\n      }\n      const previousIndex = this._items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(existingItem);\n      if (newIndex !== previousIndex) {\n        delta.push(moveDelta(previousIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this._items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  /** @internal */\n  _applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  /** @internal */\n  _applyInsertAck(op) {\n    const existingItem = this._items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this._items[existingItemIndex]?._parentPos;\n      const after2 = this._items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  /** @internal */\n  _applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this._unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this._items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this._applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this._items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      this._items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _applySetChildKeyRemote(newKey, child) {\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this._items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  /** @internal */\n  _applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this._implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this._items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this._items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this._items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this._items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`\n      );\n    }\n    const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n    const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this._items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n      beforePosition = this._items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this._items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this._items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const item = this._items[index];\n    item._detach();\n    this._items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0));\n        }\n      }\n      this._items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n      this._items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const existingItem = this._items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this._items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this._items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this._items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this._items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this._items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n  /** @internal */\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  /** @internal */\n  _shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1 ? this._items[index + 1]?._parentPos : void 0\n    );\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this._items.map((node) => node.toImmutable());\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this._items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this._innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index) {\n  return {\n    index,\n    type: \"delete\"\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    index,\n    type: \"move\",\n    previousIndex,\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/lib/freeze.ts\nvar freeze =  false ? (\n  /* istanbul ignore next */\n  0\n) : Object.freeze;\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  constructor(entries2) {\n    super();\n    this.unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = /* @__PURE__ */ new Map();\n    }\n  }\n  /**\n   * @internal\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map._map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /**\n   * @internal\n   */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.unacknowledgedSet.delete(key);\n    }\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this._map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n  /**\n   * @internal\n   */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this._map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this._map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this._map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this._map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this._map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this._map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this._map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this._map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this._map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this._map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this._map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  constructor(obj = {}) {\n    super();\n    this._propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this._map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  static _buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @internal */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj._map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        this._propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === void 0) {\n    } else if (this._propToLastUpdate.get(key) === opId) {\n      this._propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this._map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this._applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  /** @internal */\n  _applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        this._propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this._map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  /** @internal */\n  _applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this._map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this._map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this._map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this._map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this._map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this._map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this._map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this._map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this._map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this._map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this._propToLastUpdate.set(key, opId);\n      }\n      this._map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this._map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList();\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n  constructor() {\n    this._ev = makeEventSource();\n  }\n  get didInvalidate() {\n    return this._ev.observable;\n  }\n  invalidate() {\n    if (this._cache !== void 0) {\n      this._cache = void 0;\n      this._ev.notify();\n    }\n  }\n  get current() {\n    return this._cache ?? (this._cache = this._toImmutable());\n  }\n};\n\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar OthersRef = class extends ImmutableRef {\n  //\n  // --------------------------------------------------------------\n  //\n  constructor() {\n    super();\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n  }\n  connectionIds() {\n    return this._connections.keys();\n  }\n  /** @internal */\n  _toImmutable() {\n    const users = compact(\n      Array.from(this._presences.keys()).map(\n        (connectionId) => this.getUser(Number(connectionId))\n      )\n    );\n    return users;\n  }\n  clearOthers() {\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n    this.invalidate();\n  }\n  /** @internal */\n  _getUser(connectionId) {\n    const conn = this._connections.get(connectionId);\n    const presence = this._presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this._users.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this._getUser(connectionId);\n    if (computedUser) {\n      this._users.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  /** @internal */\n  _invalidateUser(connectionId) {\n    if (this._users.has(connectionId)) {\n      this._users.delete(connectionId);\n    }\n    this.invalidate();\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this._connections.set(\n      connectionId,\n      freeze({\n        connectionId,\n        id: metaUserId,\n        info: metaUserInfo,\n        scopes\n      })\n    );\n    if (this._presences.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this._connections.delete(connectionId);\n    this._presences.delete(connectionId);\n    this._invalidateUser(connectionId);\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this._presences.set(connectionId, freeze(compactObject(presence)));\n    if (this._connections.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    const oldPresence = this._presences.get(connectionId);\n    if (oldPresence === void 0) {\n      return;\n    }\n    const newPresence = merge(oldPresence, patch);\n    if (oldPresence !== newPresence) {\n      this._presences.set(connectionId, freeze(newPresence));\n      this._invalidateUser(connectionId);\n    }\n  }\n};\n\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n  constructor(data) {\n    super();\n    this._data = freeze(compactObject(data));\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    const oldData = this._data;\n    const newData = merge(oldData, patch);\n    if (oldData !== newData) {\n      this._data = freeze(newData);\n      this.invalidate();\n    }\n  }\n};\n\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n  constructor(initialValue) {\n    super();\n    this._value = freeze(initialValue);\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._value;\n  }\n  set(newValue) {\n    this._value = freeze(newValue);\n    this.invalidate();\n  }\n};\nvar DerivedRef = class extends ImmutableRef {\n  constructor(...args) {\n    super();\n    const transformFn = args.pop();\n    const otherRefs = args;\n    this._refs = otherRefs;\n    this._refs.forEach((ref) => {\n      ref.didInvalidate.subscribe(() => this.invalidate());\n    });\n    this._transform = transformFn;\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._transform(\n      ...this._refs.map((ref) => ref.current)\n    );\n  }\n};\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: user\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nvar CommentsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction createCommentsApi(roomId, getAuthValue, fetchClientApi) {\n  async function fetchCommentsApi(endpoint, params, options) {\n    const authValue = await getAuthValue();\n    return fetchClientApi(roomId, endpoint, authValue, options, params);\n  }\n  async function fetchJson(endpoint, options, params) {\n    const response = await fetchCommentsApi(endpoint, params, options);\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new CommentsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new CommentsApiError(response.statusText, response.status);\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getThreads(options) {\n    const response = await fetchCommentsApi(\n      \"/threads/search\",\n      {\n        since: options?.since?.toISOString()\n      },\n      {\n        body: JSON.stringify({\n          ...options?.query?.metadata && { metadata: options.query.metadata }\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        method: \"POST\"\n      }\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        threads: json.data.map((thread) => convertToThreadData(thread)),\n        inboxNotifications: json.inboxNotifications.map(\n          (notification) => convertToInboxNotificationData(notification)\n        ),\n        deletedThreads: json.deletedThreads.map(\n          (info) => convertToThreadDeleteInfo(info)\n        ),\n        deletedInboxNotifications: json.deletedInboxNotifications.map(\n          (info) => convertToInboxNotificationDeleteInfo(info)\n        ),\n        meta: {\n          requestedAt: new Date(json.meta.requestedAt)\n        }\n      };\n    } else if (response.status === 404) {\n      return {\n        threads: [],\n        inboxNotifications: [],\n        deletedThreads: [],\n        deletedInboxNotifications: [],\n        meta: {\n          requestedAt: /* @__PURE__ */ new Date()\n        }\n      };\n    } else {\n      throw new Error(\"There was an error while getting threads.\");\n    }\n  }\n  async function getThread({ threadId }) {\n    const response = await fetchCommentsApi(\n      `/thread-with-notification/${threadId}`\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return;\n    } else {\n      throw new Error(`There was an error while getting thread ${threadId}.`);\n    }\n  }\n  async function createThread({\n    metadata,\n    body,\n    commentId,\n    threadId\n  }) {\n    const thread = await fetchJson(\n      \"/threads\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: threadId,\n          comment: {\n            id: commentId,\n            body\n          },\n          metadata\n        })\n      }\n    );\n    return convertToThreadData(thread);\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/metadata`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(metadata)\n      }\n    );\n  }\n  async function createComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: commentId,\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment2({\n    threadId,\n    commentId\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  async function addReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    const reaction = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ emoji })\n      }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions/${encodeURIComponent(emoji)}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  return {\n    getThreads,\n    getThread,\n    createThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    deleteComment: deleteComment2,\n    addReaction: addReaction2,\n    removeReaction: removeReaction2\n  };\n}\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 = 50;\nfunction createRoom(options, config) {\n  const initialPresence = typeof options.initialPresence === \"function\" ? options.initialPresence(config.roomId) : options.initialPresence;\n  const initialStorage = typeof options.initialStorage === \"function\" ? options.initialStorage(config.roomId) : options.initialStorage;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence™ update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfo: new ValueRef(null),\n    dynamicSessionInfo: new ValueRef(null),\n    myPresence: new PatchableRef(initialPresence),\n    others: new OthersRef(),\n    initialStorage,\n    idFactory: null,\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: /* @__PURE__ */ new Map(),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n  };\n  const doNotBatchUpdates = (cb) => cb();\n  const batchUpdates = config.unstable_batchedUpdates ?? doNotBatchUpdates;\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getAuthBearerHeaderFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfo.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfo.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    batchUpdates(() => {\n      eventHub.status.notify(newStatus);\n      notifySelfChanged(doNotBatchUpdates);\n    });\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        batchUpdates(() => {\n          eventHub.lostConnection.notify(\"lost\");\n          _hasLostConnection = true;\n          context.others.clearOthers();\n          notify({ others: [{ type: \"reset\" }] }, doNotBatchUpdates);\n        });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"failed\");\n          });\n        } else {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"restored\");\n          });\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.current }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onLiveblocksError.subscribe((err) => {\n    batchUpdates(() => {\n      if (true) {\n        error2(\n          `Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`\n        );\n      }\n      eventHub.error.notify(err);\n    });\n  });\n  const pool = {\n    roomId: config.roomId,\n    getNode: (id) => context.nodes.get(id),\n    addNode: (id, node) => void context.nodes.set(id, node),\n    deleteNode: (id) => void context.nodes.delete(id),\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch;\n      if (true) {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n      if (activeBatch) {\n        activeBatch.ops.push(...ops);\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        batchUpdates(() => {\n          addToUndoStack(reverse, doNotBatchUpdates);\n          context.redoStack.length = 0;\n          dispatchOps(ops);\n          notify({ storageUpdates }, doNotBatchUpdates);\n        });\n      }\n    },\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfo.current?.scopes;\n      if (scopes === void 0) {\n        return;\n      }\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n  const eventHub = {\n    connection: makeEventSource(),\n    // Old/deprecated API\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    error: makeEventSource(),\n    storage: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource()\n  };\n  async function fetchClientApi(roomId, endpoint, authValue, options2, params) {\n    const url = urljoin(\n      config.baseUrl,\n      `/v2/c/rooms/${encodeURIComponent(roomId)}${endpoint}`,\n      params\n    );\n    const fetcher = config.polyfills?.fetch || /* istanbul ignore next */\n    fetch;\n    return await fetcher(url, {\n      ...options2,\n      headers: {\n        ...options2?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n  }\n  async function streamFetch(authValue, roomId) {\n    return fetchClientApi(roomId, \"/storage\", authValue, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n  }\n  async function httpPostToRoom(endpoint, body) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(config.roomId, endpoint, managedSocket.authValue, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body)\n    });\n  }\n  function sendMessages(messages) {\n    const serializedPayload = JSON.stringify(messages);\n    const nonce = context.dynamicSessionInfo.current?.nonce;\n    if (config.unstable_fallbackToHTTP && nonce) {\n      const size = new TextEncoder().encode(serializedPayload).length;\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\n        void httpPostToRoom(\"/send-message\", { nonce, messages }).then(\n          (resp) => {\n            if (!resp.ok && resp.status === 403) {\n              managedSocket.reconnect();\n            }\n          }\n        );\n        warn(\n          \"Message was too large for websockets and sent over HTTP instead\"\n        );\n        return;\n      }\n    }\n    managedSocket.send(serializedPayload);\n  }\n  const self = new DerivedRef(\n    context.staticSessionInfo,\n    context.dynamicSessionInfo,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes),\n          isReadOnly: !canWrite\n          // Deprecated, kept for backward-compatibility\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged(batchedUpdatesWrapper) {\n    const currSelf = self.current;\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      batchedUpdatesWrapper(() => {\n        eventHub.self.notify(currSelf);\n      });\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = new DerivedRef(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items, batchedUpdatesWrapper);\n    } else {\n      context.root = LiveObject._fromItems(message.items, pool);\n    }\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        context.root.set(key, cloneLson(context.initialStorage[key]));\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items, batchedUpdatesWrapper) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates, batchedUpdatesWrapper);\n  }\n  function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange(batchedUpdatesWrapper);\n  }\n  function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.unshift(...historyOps);\n    } else {\n      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n    }\n  }\n  function notify(updates, batchedUpdatesWrapper) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    batchedUpdatesWrapper(() => {\n      if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n        const others = context.others.current;\n        for (const event of othersUpdates) {\n          eventHub.others.notify({ ...event, others });\n        }\n      }\n      if (updates.presence ?? false) {\n        notifySelfChanged(doNotBatchUpdates);\n        eventHub.myPresence.notify(context.myPresence.current);\n      }\n      if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n        const updates2 = Array.from(storageUpdates.values());\n        eventHub.storage.notify(updates2);\n      }\n      notifyStorageStatus();\n    });\n  }\n  function getConnectionId() {\n    const info = context.dynamicSessionInfo.current;\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: [],\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.unshift(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (true) {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.unshift(...applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: output.reverse,\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.current[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.unshift({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      batchUpdates(() => {\n        if (options2?.addToHistory) {\n          addToUndoStack(\n            [{ type: \"presence\", data: oldValues }],\n            doNotBatchUpdates\n          );\n        }\n        notify({ presence: true }, doNotBatchUpdates);\n      });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message, batchedUpdatesWrapper) {\n    context.dynamicSessionInfo.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged(batchedUpdatesWrapper);\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange(batchedUpdatesWrapper) {\n    batchedUpdatesWrapper(() => {\n      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n    });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.current,\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const ops = Array.from(offlineOps.values());\n    const result = applyOps(ops, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates, batchedUpdatesWrapper);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    batchUpdates(() => {\n      for (const message of messages) {\n        switch (message.type) {\n          case 101 /* USER_JOINED */: {\n            const userJoinedUpdate = onUserJoinedMessage(message);\n            if (userJoinedUpdate) {\n              updates.others.push(userJoinedUpdate);\n            }\n            break;\n          }\n          case 100 /* UPDATE_PRESENCE */: {\n            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n            if (othersPresenceUpdate) {\n              updates.others.push(othersPresenceUpdate);\n            }\n            break;\n          }\n          case 103 /* BROADCASTED_EVENT */: {\n            const others = context.others.current;\n            eventHub.customEvent.notify({\n              connectionId: message.actor,\n              user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n              event: message.event\n            });\n            break;\n          }\n          case 102 /* USER_LEFT */: {\n            const event2 = onUserLeftMessage(message);\n            if (event2) {\n              updates.others.push(event2);\n            }\n            break;\n          }\n          case 300 /* UPDATE_YDOC */: {\n            eventHub.ydoc.notify(message);\n            break;\n          }\n          case 104 /* ROOM_STATE */: {\n            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n            break;\n          }\n          case 200 /* INITIAL_STORAGE_STATE */: {\n            processInitialStorage(message);\n            break;\n          }\n          case 201 /* UPDATE_STORAGE */: {\n            const applyResult = applyOps(message.ops, false);\n            for (const [key, value] of applyResult.updates.storageUpdates) {\n              updates.storageUpdates.set(\n                key,\n                mergeStorageUpdates(updates.storageUpdates.get(key), value)\n              );\n            }\n            break;\n          }\n          case 299 /* REJECT_STORAGE_OP */: {\n            errorWithTitle(\n              \"Storage mutation rejection error\",\n              message.reason\n            );\n            if (true) {\n              const traces = /* @__PURE__ */ new Set();\n              for (const opId of message.opIds) {\n                const trace = context.opStackTraces?.get(opId);\n                if (trace) {\n                  traces.add(trace);\n                }\n              }\n              if (traces.size > 0) {\n                warnWithTitle(\n                  \"The following function calls caused the rejected storage mutations:\",\n                  `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n                );\n              }\n              throw new Error(\n                `Storage mutations rejected by server: ${message.reason}`\n              );\n            }\n            break;\n          }\n          case 400 /* THREAD_CREATED */:\n          case 401 /* THREAD_METADATA_UPDATED */:\n          case 405 /* COMMENT_REACTION_ADDED */:\n          case 406 /* COMMENT_REACTION_REMOVED */:\n          case 402 /* COMMENT_CREATED */:\n          case 403 /* COMMENT_EDITED */:\n          case 404 /* COMMENT_DELETED */: {\n            eventHub.comments.notify(message);\n            break;\n          }\n        }\n      }\n      notify(updates, doNotBatchUpdates);\n    });\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence™ update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    context.buffer.storageOperations.push(...ops);\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n    applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) {\n      return;\n    }\n    const result = await streamFetch(managedSocket.authValue, config.roomId);\n    const items = await result.json();\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.redoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.undoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    batchUpdates(() => {\n      context.activeBatch = {\n        ops: [],\n        updates: {\n          storageUpdates: /* @__PURE__ */ new Map(),\n          presence: false,\n          others: []\n        },\n        reverseOps: []\n      };\n      try {\n        returnValue = callback();\n      } finally {\n        const currentBatch = context.activeBatch;\n        context.activeBatch = null;\n        if (currentBatch.reverseOps.length > 0) {\n          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n        }\n        if (currentBatch.ops.length > 0) {\n          context.redoStack.length = 0;\n        }\n        if (currentBatch.ops.length > 0) {\n          dispatchOps(currentBatch.ops);\n        }\n        notify(currentBatch.updates, doNotBatchUpdates);\n        flushNowOrSoon();\n      }\n    });\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = [];\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(historyOps, batchUpdates);\n    }\n  }\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n  }\n  const others_forDevTools = new DerivedRef(\n    context.others,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    error: eventHub.error.observable,\n    storage: eventHub.storage.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable\n  };\n  const commentsApi = createCommentsApi(\n    config.roomId,\n    delegates.authenticate,\n    fetchClientApi\n  );\n  async function fetchNotificationsJson(endpoint, options2) {\n    const authValue = await delegates.authenticate();\n    const response = await fetchClientApi(\n      config.roomId,\n      endpoint,\n      authValue,\n      options2\n    );\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  function getRoomNotificationSettings() {\n    return fetchNotificationsJson(\n      \"/notification-settings\"\n    );\n  }\n  function updateRoomNotificationSettings(settings) {\n    return fetchNotificationsJson(\n      \"/notification-settings\",\n      {\n        method: \"POST\",\n        body: JSON.stringify(settings),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchNotificationsJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.nodes.size;\n        },\n        // prettier-ignore\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.current,\n        getOthers_forDevTools: () => others_forDevTools.current,\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        comments: {\n          ...commentsApi\n        },\n        notifications: {\n          getRoomNotificationSettings,\n          updateRoomNotificationSettings,\n          markInboxNotificationAsRead\n        }\n      },\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(events),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getConnectionState: () => managedSocket.getLegacyStatus(),\n      getSelf: () => self.current,\n      // Presence\n      getPresence: () => context.myPresence.current,\n      getOthers: () => context.others.current\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(events) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storage.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storage.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\":\n          return events.error.subscribe(callback);\n        case \"connection\": {\n          const cb = callback;\n          return events.status.subscribe(\n            (status) => cb(newToLegacyStatus(status))\n          );\n        }\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storage.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url = new URL(baseUrl);\n    url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url.pathname = \"/v7\";\n    url.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url.toString());\n  };\n}\n\n// src/store.ts\nfunction createClientStore() {\n  const store = createStore({\n    threads: {},\n    queries: {},\n    optimisticUpdates: [],\n    inboxNotifications: {},\n    notificationSettings: {}\n  });\n  return {\n    ...store,\n    deleteThread(threadId) {\n      store.set((state) => {\n        return {\n          ...state,\n          threads: deleteKeyImmutable(state.threads, threadId),\n          inboxNotifications: Object.fromEntries(\n            Object.entries(state.inboxNotifications).filter(\n              ([_id, notification]) => notification.threadId !== threadId\n            )\n          )\n        };\n      });\n    },\n    updateThreadAndNotification(thread, inboxNotification) {\n      store.set((state) => {\n        const existingThread = state.threads[thread.id];\n        return {\n          ...state,\n          threads: existingThread === void 0 || compareThreads(thread, existingThread) === 1 ? { ...state.threads, [thread.id]: thread } : state.threads,\n          inboxNotifications: inboxNotification === void 0 ? state.inboxNotifications : {\n            ...state.inboxNotifications,\n            [inboxNotification.id]: inboxNotification\n          }\n        };\n      });\n    },\n    updateThreadsAndNotifications(threads, inboxNotifications, deletedThreads, deletedInboxNotifications, queryKey) {\n      store.set((state) => ({\n        ...state,\n        threads: applyThreadUpdates(state.threads, {\n          newThreads: threads,\n          deletedThreads\n        }),\n        inboxNotifications: applyNotificationsUpdates(\n          state.inboxNotifications,\n          {\n            newInboxNotifications: inboxNotifications,\n            deletedNotifications: deletedInboxNotifications\n          }\n        ),\n        queries: queryKey !== void 0 ? {\n          ...state.queries,\n          [queryKey]: {\n            isLoading: false\n          }\n        } : state.queries\n      }));\n    },\n    updateRoomInboxNotificationSettings(roomId, settings, queryKey) {\n      store.set((state) => ({\n        ...state,\n        notificationSettings: {\n          ...state.notificationSettings,\n          [roomId]: settings\n        },\n        queries: {\n          ...state.queries,\n          [queryKey]: {\n            isLoading: false\n          }\n        }\n      }));\n    },\n    pushOptimisticUpdate(optimisticUpdate) {\n      store.set((state) => ({\n        ...state,\n        optimisticUpdates: [...state.optimisticUpdates, optimisticUpdate]\n      }));\n    },\n    setQueryState(queryKey, queryState) {\n      store.set((state) => ({\n        ...state,\n        queries: {\n          ...state.queries,\n          [queryKey]: queryState\n        }\n      }));\n    }\n  };\n}\nfunction deleteKeyImmutable(record, key) {\n  if (Object.prototype.hasOwnProperty.call(record, key)) {\n    const { [key]: _toDelete, ...rest } = record;\n    return rest;\n  }\n  return record;\n}\nfunction compareThreads(thread1, thread2) {\n  if (thread1.updatedAt && thread2.updatedAt) {\n    return thread1.updatedAt > thread2.updatedAt ? 1 : thread1.updatedAt < thread2.updatedAt ? -1 : 0;\n  } else if (thread1.updatedAt || thread2.updatedAt) {\n    return thread1.updatedAt ? 1 : -1;\n  }\n  if (thread1.createdAt > thread2.createdAt) {\n    return 1;\n  } else if (thread1.createdAt < thread2.createdAt) {\n    return -1;\n  }\n  return 0;\n}\nfunction applyOptimisticUpdates(state) {\n  const result = {\n    threads: {\n      ...state.threads\n    },\n    inboxNotifications: {\n      ...state.inboxNotifications\n    },\n    notificationSettings: {\n      ...state.notificationSettings\n    }\n  };\n  for (const optimisticUpdate of state.optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        result.threads[optimisticUpdate.thread.id] = optimisticUpdate.thread;\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        if (thread.updatedAt !== void 0 && thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n        result.threads[thread.id] = {\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata\n          }\n        };\n        break;\n      }\n      case \"create-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        const inboxNotification = Object.values(result.inboxNotifications).find(\n          (notification) => notification.threadId === thread.id\n        );\n        if (inboxNotification === void 0) {\n          break;\n        }\n        result.inboxNotifications[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt\n        };\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = deleteComment(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.deletedAt\n        );\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = addReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.reaction\n        );\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = removeReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.emoji,\n          optimisticUpdate.userId,\n          optimisticUpdate.removedAt\n        );\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        result.inboxNotifications[optimisticUpdate.inboxNotificationId] = {\n          ...state.inboxNotifications[optimisticUpdate.inboxNotificationId],\n          readAt: optimisticUpdate.readAt\n        };\n        break;\n      }\n      case \"mark-inbox-notifications-as-read\": {\n        for (const id in result.inboxNotifications) {\n          result.inboxNotifications[id] = {\n            ...result.inboxNotifications[id],\n            readAt: optimisticUpdate.readAt\n          };\n        }\n        break;\n      }\n      case \"update-notification-settings\": {\n        result.notificationSettings[optimisticUpdate.roomId] = {\n          ...result.notificationSettings[optimisticUpdate.roomId],\n          ...optimisticUpdate.settings\n        };\n      }\n    }\n  }\n  return result;\n}\nfunction applyThreadUpdates(existingThreads, updates) {\n  const updatedThreads = { ...existingThreads };\n  updates.newThreads.forEach((thread) => {\n    const existingThread = updatedThreads[thread.id];\n    if (existingThread) {\n      const result = compareThreads(existingThread, thread);\n      if (result === 1)\n        return;\n    }\n    updatedThreads[thread.id] = thread;\n  });\n  updates.deletedThreads.forEach(({ id, deletedAt }) => {\n    const existingThread = updatedThreads[id];\n    if (existingThread === void 0)\n      return;\n    existingThread.deletedAt = deletedAt;\n    existingThread.updatedAt = deletedAt;\n    existingThread.comments = [];\n  });\n  return updatedThreads;\n}\nfunction applyNotificationsUpdates(existingInboxNotifications, updates) {\n  const updatedInboxNotifications = { ...existingInboxNotifications };\n  updates.newInboxNotifications.forEach((notification) => {\n    const existingNotification = updatedInboxNotifications[notification.id];\n    if (existingNotification) {\n      const result = compareInboxNotifications(\n        existingNotification,\n        notification\n      );\n      if (result === 1)\n        return;\n    }\n    updatedInboxNotifications[notification.id] = notification;\n  });\n  updates.deletedNotifications.forEach(\n    ({ id }) => delete updatedInboxNotifications[id]\n  );\n  return updatedInboxNotifications;\n}\nfunction compareInboxNotifications(inboxNotificationA, inboxNotificationB) {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n  return 0;\n}\nfunction upsertComment(thread, comment) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  if (comment.threadId !== thread.id) {\n    warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (existingComment2) => existingComment2.id === comment.id\n  );\n  if (existingComment === void 0) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt?.getTime() || 0, comment.createdAt.getTime())\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment]\n    };\n    return updatedThread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {\n    const updatedComments = thread.comments.map(\n      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt?.getTime() || 0,\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments\n    };\n    return updatedThread;\n  }\n  return thread;\n}\nfunction deleteComment(thread, commentId, deletedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      deletedAt,\n      body: void 0\n    } : comment\n  );\n  if (!updatedComments.some((comment) => comment.deletedAt === void 0)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt,\n      comments: []\n    };\n  }\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments\n  };\n}\nfunction addReaction(thread, commentId, reaction) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: upsertReaction(comment.reactions, reaction)\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction removeReaction(thread, commentId, emoji, userId, removedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: comment.reactions.map(\n        (reaction) => reaction.emoji === emoji ? {\n          ...reaction,\n          users: reaction.users.filter((user) => user.id !== userId)\n        } : reaction\n      ).filter((reaction) => reaction.users.length > 0)\n      // Remove reactions with no users left\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction upsertReaction(reactions, reaction) {\n  const existingReaction = reactions.find(\n    (existingReaction2) => existingReaction2.emoji === reaction.emoji\n  );\n  if (existingReaction === void 0) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }]\n      }\n    ];\n  }\n  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {\n    return reactions.map(\n      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {\n        ...existingReaction2,\n        users: [...existingReaction2.users, { id: reaction.userId }]\n      } : existingReaction2\n    );\n  }\n  return reactions;\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  baseUrl || (baseUrl = process.env.LIVEBLOCKS_BASE_URL || process.env.NEXT_PUBLIC_LIVEBLOCKS_BASE_URL || process.env.VITE_LIVEBLOCKS_BASE_URL || void 0);\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction getAuthBearerHeaderFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const authManager = createAuthManager(options);\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(info) {\n    const leave = () => {\n      const self = leave;\n      if (!info.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (info.unsubs.size === 0) {\n          teardownRoom(info.room);\n        }\n      }\n    };\n    info.unsubs.add(leave);\n    return {\n      room: info.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, options2) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    deprecateIf(\n      options2.initialPresence === null || options2.initialPresence === void 0,\n      \"Please provide an initial presence value for the current user when entering the room.\"\n    );\n    const newRoom = createRoom(\n      {\n        initialPresence: options2.initialPresence ?? {},\n        initialStorage: options2.initialStorage\n      },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        unstable_batchedUpdates: options2?.unstable_batchedUpdates,\n        baseUrl,\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n        unstable_streamData: !!clientOptions.unstable_streamData\n      }\n    );\n    const newRoomInfo = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomInfo);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? options2.shouldInitiallyConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomInfo);\n  }\n  function enter(roomId, options2) {\n    const { room, leave: _ } = enterRoom(roomId, options2);\n    return room;\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function forceLeave(roomId) {\n    const unsubs = roomsById.get(roomId)?.unsubs ?? /* @__PURE__ */ new Set();\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  }\n  function logout() {\n    authManager.reset();\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const currentUserIdStore = createStore(null);\n  const {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead\n  } = createNotificationsApi({\n    baseUrl,\n    fetcher: clientOptions.polyfills?.fetch || /* istanbul ignore next */\n    fetch,\n    authManager,\n    currentUserIdStore\n  });\n  const cacheStore = createClientStore();\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const usersStore = createBatchStore(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const roomsInfoStore = createBatchStore(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  return Object.defineProperty(\n    {\n      logout,\n      // Old, deprecated APIs\n      enter,\n      getRoom,\n      leave: forceLeave,\n      // New, preferred API\n      enterRoom,\n      // Internal\n      [kInternal]: {\n        notifications: {\n          getInboxNotifications,\n          getUnreadInboxNotificationsCount,\n          markAllInboxNotificationsAsRead,\n          markInboxNotificationAsRead\n        },\n        currentUserIdStore,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        cacheStore,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        }\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n}\nvar NotificationsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0)\n    return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (true) {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {}\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyText(element) {\n  return \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values) {\n  return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values) {\n  return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url) {\n  if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return url;\n  } else if (url.startsWith(\"www.\")) {\n    return \"https://\" + url;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (true) {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/Poller.ts\nfunction makePoller(callback) {\n  let context = {\n    state: \"stopped\",\n    timeoutHandle: null,\n    interval: null,\n    lastScheduledAt: null,\n    remainingInterval: null\n  };\n  function poll() {\n    if (context.state === \"running\") {\n      schedule(context.interval);\n    }\n    void callback();\n  }\n  function schedule(interval) {\n    context = {\n      state: \"running\",\n      interval: context.state !== \"stopped\" ? context.interval : interval,\n      lastScheduledAt: performance.now(),\n      timeoutHandle: setTimeout(poll, interval),\n      remainingInterval: null\n    };\n  }\n  function scheduleRemaining(remaining) {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    context = {\n      state: \"running\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: setTimeout(poll, remaining),\n      remainingInterval: null\n    };\n  }\n  function start(interval) {\n    if (context.state === \"running\") {\n      return;\n    }\n    schedule(interval);\n  }\n  function restart(interval) {\n    stop();\n    start(interval);\n  }\n  function pause() {\n    if (context.state !== \"running\") {\n      return;\n    }\n    clearTimeout(context.timeoutHandle);\n    context = {\n      state: \"paused\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: null,\n      remainingInterval: context.interval - (performance.now() - context.lastScheduledAt)\n    };\n  }\n  function resume() {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    scheduleRemaining(context.remainingInterval);\n  }\n  function stop() {\n    if (context.state === \"stopped\") {\n      return;\n    }\n    if (context.timeoutHandle) {\n      clearTimeout(context.timeoutHandle);\n    }\n    context = {\n      state: \"stopped\",\n      interval: null,\n      lastScheduledAt: null,\n      timeoutHandle: null,\n      remainingInterval: null\n    };\n  }\n  return {\n    start,\n    restart,\n    pause,\n    resume,\n    stop\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null || Object.prototype.toString.call(objA) !== \"[object Object]\" || Object.prototype.toString.call(objB) !== \"[object Object]\") {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCLEdBQUcsVUFBVTtBQUN4RTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSjtBQUNBLHFHQUFxRyxrQkFBa0I7QUFDdkg7QUFDQTtBQUNBLFdBQVcsU0FBUyxFQUFFLFVBQVU7QUFDaEMsV0FBVyxTQUFTLEVBQUUsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsd0JBQXdCO0FBQzNHO0FBQ0E7QUFDQSxhQUFhLFVBQVUsUUFBUSxZQUFZO0FBQzNDLGFBQWEsU0FBUyxRQUFRLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0MscUJBQXFCLFdBQVcsZ0JBQWdCLHVCQUF1QixnQkFBZ0I7QUFDdkg7QUFDQTtBQUNBLDBDQUEwQyxhQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFvQjtBQUM5RDtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOEJBQThCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUssUUFBUSxTQUFTLFVBQVUsY0FBYztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQSwwQ0FBMEMsK0JBQStCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixtREFBbUQsNEZBQTRGO0FBQy9JO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlJQUFpSSxjQUFjO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQkFBc0IscUVBQXFFLEdBQUcsWUFBWSxtQkFBbUIsU0FBUztBQUN0STtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JELE1BQU07QUFDTixpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0VBQWdFLFNBQVMsS0FBSztBQUM5RTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjLG1DQUFtQyxTQUFTLGFBQWE7QUFDdkg7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGdCQUFnQix5QkFBeUIsSUFBSSxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUyxHQUFHLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBcUM7QUFDM0M7QUFDQTtBQUNBLGdCQUFnQix3REFBd0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3SEFBd0gsYUFBYSxZQUFZLGVBQWU7QUFDaEs7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBLG9DQUFvQyxnQ0FBZ0M7QUFDcEUsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0Q0FBNEM7QUFDN0U7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0I7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLE1BQU0sUUFBUTtBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQixJQUFJO0FBQzVELFFBQVE7QUFDUjtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTSxtQ0FBbUMsbUJBQW1CO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNLG1DQUFtQyx1QkFBdUI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNLG1DQUFtQyx1QkFBdUI7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBcUMsR0FBRyxDQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsYUFBYSxNQUFxQztBQUNsRDtBQUNBLEVBQUUsQ0FBUTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELCtCQUErQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ04sZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxxQkFBcUIsT0FBTyxHQUFHLEtBQUs7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFxQyxHQUFHLENBQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYSxHQUFHLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFT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QUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFD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LCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLHNCQUFzQjtBQUNuRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxzQ0FBc0M7QUFDbkg7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9DQUFvQyxlQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZLDRCQUE0QixVQUFVO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQixZQUFZO0FBQ2xFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQXlERTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmlncHJvLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL2NvcmUvZGlzdC9pbmRleC5tanM/ZjYxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvdmVyc2lvbi50c1xudmFyIFBLR19OQU1FID0gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG52YXIgUEtHX1ZFUlNJT04gPSBcIjEuMTAuMlwiO1xudmFyIFBLR19GT1JNQVQgPSBcImVzbVwiO1xuXG4vLyBzcmMvZHVwZS1kZXRlY3Rpb24udHNcbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fTtcbnZhciBjcm9zc0xpbmtlZERvY3MgPSBcImh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9jcm9zcy1saW5rZWRcIjtcbnZhciBkdXBlc0RvY3MgPSBcImh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9kdXBlc1wiO1xudmFyIFNQQUNFID0gXCIgXCI7XG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZWN0RHVwZXMocGtnTmFtZSwgcGtnVmVyc2lvbiwgcGtnRm9ybWF0KSB7XG4gIGNvbnN0IHBrZ0lkID0gU3ltYm9sLmZvcihwa2dOYW1lKTtcbiAgY29uc3QgcGtnQnVpbGRJbmZvID0gcGtnRm9ybWF0ID8gYCR7cGtnVmVyc2lvbiB8fCBcImRldlwifSAoJHtwa2dGb3JtYXR9KWAgOiBwa2dWZXJzaW9uIHx8IFwiZGV2XCI7XG4gIGlmICghZ1twa2dJZF0pIHtcbiAgICBnW3BrZ0lkXSA9IHBrZ0J1aWxkSW5mbztcbiAgfSBlbHNlIGlmIChnW3BrZ0lkXSA9PT0gcGtnQnVpbGRJbmZvKSB7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbXNnID0gW1xuICAgICAgYE11bHRpcGxlIGNvcGllcyBvZiBMaXZlYmxvY2tzIGFyZSBiZWluZyBsb2FkZWQgaW4geW91ciBwcm9qZWN0LiBUaGlzIHdpbGwgY2F1c2UgaXNzdWVzISBTZWUgJHtkdXBlc0RvY3MgKyBTUEFDRX1gLFxuICAgICAgXCJcIixcbiAgICAgIFwiQ29uZmxpY3RzOlwiLFxuICAgICAgYC0gJHtwa2dOYW1lfSAke2dbcGtnSWRdfSAoYWxyZWFkeSBsb2FkZWQpYCxcbiAgICAgIGAtICR7cGtnTmFtZX0gJHtwa2dCdWlsZEluZm99ICh0cnlpbmcgdG8gbG9hZCB0aGlzIG5vdylgXG4gICAgXS5qb2luKFwiXFxuXCIpO1xuICAgIGVycm9yKG1zZyk7XG4gIH1cbiAgaWYgKHBrZ1ZlcnNpb24gJiYgUEtHX1ZFUlNJT04gJiYgcGtnVmVyc2lvbiAhPT0gUEtHX1ZFUlNJT04pIHtcbiAgICBlcnJvcihcbiAgICAgIFtcbiAgICAgICAgYENyb3NzLWxpbmtlZCB2ZXJzaW9ucyBvZiBMaXZlYmxvY2tzIGZvdW5kLCB3aGljaCB3aWxsIGNhdXNlIGlzc3VlcyEgU2VlICR7Y3Jvc3NMaW5rZWREb2NzICsgU1BBQ0V9YCxcbiAgICAgICAgXCJcIixcbiAgICAgICAgXCJDb25mbGljdHM6XCIsXG4gICAgICAgIGAtICR7UEtHX05BTUV9IGlzIGF0ICR7UEtHX1ZFUlNJT059YCxcbiAgICAgICAgYC0gJHtwa2dOYW1lfSBpcyBhdCAke3BrZ1ZlcnNpb259YCxcbiAgICAgICAgXCJcIixcbiAgICAgICAgXCJBbHdheXMgdXBncmFkZSBhbGwgTGl2ZWJsb2NrcyBwYWNrYWdlcyB0byB0aGUgc2FtZSB2ZXJzaW9uIG51bWJlci5cIlxuICAgICAgXS5qb2luKFwiXFxuXCIpXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL2Fzc2VydC50c1xuZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3ZhbHVlLCBlcnJtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKGVycm1zZyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBlcnJtc2cpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZXJybXNnKTtcbiAgICAgIGVyci5uYW1lID0gXCJBc3NlcnRpb24gZmFpbHVyZVwiO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbm4odmFsdWUsIGVycm1zZyA9IFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgbm9uLW51bGxhYmxlXCIpIHtcbiAgYXNzZXJ0KHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAsIGVycm1zZyk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gc3JjL2xpYi9jb250cm9sbGVkUHJvbWlzZS50c1xuZnVuY3Rpb24gY29udHJvbGxlZFByb21pc2UoKSB7XG4gIGxldCBmbGFnZ2VyO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgIGZsYWdnZXIgPSByZXM7XG4gIH0pO1xuICBpZiAoIWZsYWdnZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGQgbmV2ZXIgaGFwcGVuXCIpO1xuICB9XG4gIHJldHVybiBbcHJvbWlzZSwgZmxhZ2dlcl07XG59XG5cbi8vIHNyYy9saWIvRXZlbnRTb3VyY2UudHNcbmZ1bmN0aW9uIG1ha2VFdmVudFNvdXJjZSgpIHtcbiAgY29uc3QgX29uZXRpbWVPYnNlcnZlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBfb2JzZXJ2ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IF9idWZmZXIgPSBudWxsO1xuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBfYnVmZmVyID0gW107XG4gIH1cbiAgZnVuY3Rpb24gdW5wYXVzZSgpIHtcbiAgICBpZiAoX2J1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIF9idWZmZXIpIHtcbiAgICAgIG5vdGlmeShldmVudCk7XG4gICAgfVxuICAgIF9idWZmZXIgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgIF9vYnNlcnZlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4gX29ic2VydmVycy5kZWxldGUoY2FsbGJhY2spO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZU9uY2UoY2FsbGJhY2spIHtcbiAgICBfb25ldGltZU9ic2VydmVycy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiBfb25ldGltZU9ic2VydmVycy5kZWxldGUoY2FsbGJhY2spO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbChwcmVkaWNhdGUpIHtcbiAgICBsZXQgdW5zdWI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgIHVuc3ViID0gc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICBpZiAocHJlZGljYXRlID09PSB2b2lkIDAgfHwgcHJlZGljYXRlKGV2ZW50KSkge1xuICAgICAgICAgIHJlcyhldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4gdW5zdWI/LigpKTtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnlPckJ1ZmZlcihldmVudCkge1xuICAgIGlmIChfYnVmZmVyICE9PSBudWxsKSB7XG4gICAgICBfYnVmZmVyLnB1c2goZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBub3RpZnkoZXZlbnQpIHtcbiAgICBfb25ldGltZU9ic2VydmVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soZXZlbnQpKTtcbiAgICBfb25ldGltZU9ic2VydmVycy5jbGVhcigpO1xuICAgIF9vYnNlcnZlcnMuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGV2ZW50KSk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgX29uZXRpbWVPYnNlcnZlcnMuY2xlYXIoKTtcbiAgICBfb2JzZXJ2ZXJzLmNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gY291bnQoKSB7XG4gICAgcmV0dXJuIF9vbmV0aW1lT2JzZXJ2ZXJzLnNpemUgKyBfb2JzZXJ2ZXJzLnNpemU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAvLyBQcml2YXRlL2ludGVybmFsIGNvbnRyb2wgb3ZlciBldmVudCBlbWlzc2lvblxuICAgIG5vdGlmeTogbm90aWZ5T3JCdWZmZXIsXG4gICAgc3Vic2NyaWJlLFxuICAgIHN1YnNjcmliZU9uY2UsXG4gICAgY2xlYXIsXG4gICAgY291bnQsXG4gICAgd2FpdFVudGlsLFxuICAgIHBhdXNlLFxuICAgIHVucGF1c2UsXG4gICAgLy8gUHVibGljbHkgZXhwb3NhYmxlIHN1YnNjcmlwdGlvbiBBUElcbiAgICBvYnNlcnZhYmxlOiB7XG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBzdWJzY3JpYmVPbmNlLFxuICAgICAgd2FpdFVudGlsXG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbGliL2ZhbmN5LWNvbnNvbGUudHNcbnZhciBmYW5jeV9jb25zb2xlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGZhbmN5X2NvbnNvbGVfZXhwb3J0cywge1xuICBlcnJvcjogKCkgPT4gZXJyb3IyLFxuICBlcnJvcldpdGhUaXRsZTogKCkgPT4gZXJyb3JXaXRoVGl0bGUsXG4gIHdhcm46ICgpID0+IHdhcm4sXG4gIHdhcm5XaXRoVGl0bGU6ICgpID0+IHdhcm5XaXRoVGl0bGVcbn0pO1xudmFyIGJhZGdlID0gXCJiYWNrZ3JvdW5kOiMwZTBkMTI7Ym9yZGVyLXJhZGl1czo5OTk5cHg7Y29sb3I6I2ZmZjtwYWRkaW5nOjNweCA3cHg7Zm9udC1mYW1pbHk6c2Fucy1zZXJpZjtmb250LXdlaWdodDo2MDA7XCI7XG52YXIgYm9sZCA9IFwiZm9udC13ZWlnaHQ6NjAwXCI7XG5mdW5jdGlvbiB3cmFwKG1ldGhvZCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgPyBjb25zb2xlW21ldGhvZF0gOiAoXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAobWVzc2FnZSwgLi4uYXJncykgPT4gY29uc29sZVttZXRob2RdKFwiJWNMaXZlYmxvY2tzXCIsIGJhZGdlLCBtZXNzYWdlLCAuLi5hcmdzKVxuICApO1xufVxudmFyIHdhcm4gPSB3cmFwKFwid2FyblwiKTtcbnZhciBlcnJvcjIgPSB3cmFwKFwiZXJyb3JcIik7XG5mdW5jdGlvbiB3cmFwV2l0aFRpdGxlKG1ldGhvZCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgPyBjb25zb2xlW21ldGhvZF0gOiAoXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAodGl0bGUsIG1lc3NhZ2UsIC4uLmFyZ3MpID0+IGNvbnNvbGVbbWV0aG9kXShcbiAgICAgIGAlY0xpdmVibG9ja3MlYyAke3RpdGxlfWAsXG4gICAgICBiYWRnZSxcbiAgICAgIGJvbGQsXG4gICAgICBtZXNzYWdlLFxuICAgICAgLi4uYXJnc1xuICAgIClcbiAgKTtcbn1cbnZhciB3YXJuV2l0aFRpdGxlID0gd3JhcFdpdGhUaXRsZShcIndhcm5cIik7XG52YXIgZXJyb3JXaXRoVGl0bGUgPSB3cmFwV2l0aFRpdGxlKFwiZXJyb3JcIik7XG5cbi8vIHNyYy9saWIvZnNtLnRzXG5mdW5jdGlvbiBkaXN0YW5jZShzdGF0ZTEsIHN0YXRlMikge1xuICBpZiAoc3RhdGUxID09PSBzdGF0ZTIpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gIGNvbnN0IGNodW5rczEgPSBzdGF0ZTEuc3BsaXQoXCIuXCIpO1xuICBjb25zdCBjaHVua3MyID0gc3RhdGUyLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgbWluTGVuID0gTWF0aC5taW4oY2h1bmtzMS5sZW5ndGgsIGNodW5rczIubGVuZ3RoKTtcbiAgbGV0IHNoYXJlZCA9IDA7XG4gIGZvciAoOyBzaGFyZWQgPCBtaW5MZW47IHNoYXJlZCsrKSB7XG4gICAgaWYgKGNodW5rczFbc2hhcmVkXSAhPT0gY2h1bmtzMltzaGFyZWRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgdXAgPSBjaHVua3MxLmxlbmd0aCAtIHNoYXJlZDtcbiAgY29uc3QgZG93biA9IGNodW5rczIubGVuZ3RoIC0gc2hhcmVkO1xuICByZXR1cm4gW3VwLCBkb3duXTtcbn1cbmZ1bmN0aW9uIHBhdHRlcm5zKHRhcmdldFN0YXRlLCBsZXZlbHMpIHtcbiAgY29uc3QgcGFydHMgPSB0YXJnZXRTdGF0ZS5zcGxpdChcIi5cIik7XG4gIGlmIChsZXZlbHMgPCAxIHx8IGxldmVscyA+IHBhcnRzLmxlbmd0aCArIDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBsZXZlbHNcIik7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGlmIChsZXZlbHMgPiBwYXJ0cy5sZW5ndGgpIHtcbiAgICByZXN1bHQucHVzaChcIipcIik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IHBhcnRzLmxlbmd0aCAtIGxldmVscyArIDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNsaWNlID0gcGFydHMuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNsaWNlLmpvaW4oXCIuXCIpICsgXCIuKlwiKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0LnB1c2godGFyZ2V0U3RhdGUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIFNhZmVDb250ZXh0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsQ29udGV4dCkge1xuICAgIHRoaXMuY3VyciA9IGluaXRpYWxDb250ZXh0O1xuICB9XG4gIGdldCBjdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnI7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGFsbG93cyBwYXRjaGluZyBvZiB0aGUgY29udGV4dCwgYnlcbiAgICogY2FsbGluZyBgY29udGV4dC5wYXRjaCgpYC4gUGF0Y2hpbmcgaXMgb25seSBhbGxvd2VkIGZvciB0aGUgZHVyYXRpb25cbiAgICogb2YgdGhpcyB3aW5kb3cuXG4gICAqL1xuICBhbGxvd1BhdGNoaW5nKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGFsbG93ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHBhdGNoYWJsZUNvbnRleHQgPSB7XG4gICAgICAuLi50aGlzLmN1cnIsXG4gICAgICBwYXRjaChwYXRjaCkge1xuICAgICAgICBpZiAoYWxsb3dlZCkge1xuICAgICAgICAgIHNlbGYuY3VyciA9IE9iamVjdC5hc3NpZ24oe30sIHNlbGYuY3VyciwgcGF0Y2gpO1xuICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBPYmplY3QuZW50cmllcyhwYXRjaCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHBhaXI7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBcInBhdGNoXCIpIHtcbiAgICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBubyBsb25nZXIgcGF0Y2ggc3RhbGUgY29udGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY2FsbGJhY2socGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgYWxsb3dlZCA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxufTtcbnZhciBuZXh0SWQgPSAxO1xudmFyIEZTTSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluaXRpYWwgc3RhdGUsIHdoaWNoIGlzIGRlZmluZWQgYnkgdGhlIGZpcnN0IGNhbGwgbWFkZSB0b1xuICAgKiAuYWRkU3RhdGUoKS5cbiAgICovXG4gIGdldCBpbml0aWFsU3RhdGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zdGF0ZXMudmFsdWVzKClbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN0YXRlcyBkZWZpbmVkIHlldFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U3RhdGVPck51bGwgPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSA9PT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN0YXJ0ZWQgeWV0XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdG9wcGVkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RhdGVPck51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgbWFjaGluZSBieSBlbnRlcmluZyB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlIG1hY2hpbmUgaGFzIGFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5ydW5uaW5nU3RhdGUgPSAxIC8qIFNUQVJURUQgKi87XG4gICAgdGhpcy5jdXJyZW50U3RhdGVPck51bGwgPSB0aGlzLmluaXRpYWxTdGF0ZTtcbiAgICB0aGlzLmVudGVyKG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgc3RhdGUgbWFjaGluZS4gU3RvcHBpbmcgdGhlIHN0YXRlIG1hY2hpbmUgd2lsbCBjYWxsIGV4aXRcbiAgICogaGFuZGxlcnMgZm9yIHRoZSBjdXJyZW50IHN0YXRlLCBidXQgbm90IGVudGVyIGEgbmV3IHN0YXRlLlxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDEgLyogU1RBUlRFRCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN0b3AgYSBzdGF0ZSBtYWNoaW5lIHRoYXQgaGFzbid0IHN0YXJ0ZWQgeWV0XCIpO1xuICAgIH1cbiAgICB0aGlzLmV4aXQobnVsbCk7XG4gICAgdGhpcy5ydW5uaW5nU3RhdGUgPSAyIC8qIFNUT1BQRUQgKi87XG4gICAgdGhpcy5jdXJyZW50U3RhdGVPck51bGwgPSBudWxsO1xuICB9XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxDb250ZXh0KSB7XG4gICAgdGhpcy5pZCA9IG5leHRJZCsrO1xuICAgIHRoaXMucnVubmluZ1N0YXRlID0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi87XG4gICAgdGhpcy5jdXJyZW50U3RhdGVPck51bGwgPSBudWxsO1xuICAgIHRoaXMuc3RhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmVudGVyRm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmNsZWFudXBTdGFjayA9IFtdO1xuICAgIHRoaXMua25vd25FdmVudFR5cGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmFsbG93ZWRUcmFuc2l0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jdXJyZW50Q29udGV4dCA9IG5ldyBTYWZlQ29udGV4dChpbml0aWFsQ29udGV4dCk7XG4gICAgdGhpcy5ldmVudEh1YiA9IHtcbiAgICAgIGRpZFJlY2VpdmVFdmVudDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICB3aWxsVHJhbnNpdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICBkaWRJZ25vcmVFdmVudDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgICB3aWxsRXhpdFN0YXRlOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIGRpZEVudGVyU3RhdGU6IG1ha2VFdmVudFNvdXJjZSgpXG4gICAgfTtcbiAgICB0aGlzLmV2ZW50cyA9IHtcbiAgICAgIGRpZFJlY2VpdmVFdmVudDogdGhpcy5ldmVudEh1Yi5kaWRSZWNlaXZlRXZlbnQub2JzZXJ2YWJsZSxcbiAgICAgIHdpbGxUcmFuc2l0aW9uOiB0aGlzLmV2ZW50SHViLndpbGxUcmFuc2l0aW9uLm9ic2VydmFibGUsXG4gICAgICBkaWRJZ25vcmVFdmVudDogdGhpcy5ldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5vYnNlcnZhYmxlLFxuICAgICAgd2lsbEV4aXRTdGF0ZTogdGhpcy5ldmVudEh1Yi53aWxsRXhpdFN0YXRlLm9ic2VydmFibGUsXG4gICAgICBkaWRFbnRlclN0YXRlOiB0aGlzLmV2ZW50SHViLmRpZEVudGVyU3RhdGUub2JzZXJ2YWJsZVxuICAgIH07XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudDtcbiAgfVxuICAvKipcbiAgICogRGVmaW5lIGFuIGV4cGxpY2l0IGZpbml0ZSBzdGF0ZSBpbiB0aGUgc3RhdGUgbWFjaGluZS5cbiAgICovXG4gIGFkZFN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlcy5hZGQoc3RhdGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9uRW50ZXIobmFtZU9yUGF0dGVybiwgZW50ZXJGbikge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZW50ZXJGbnMuaGFzKG5hbWVPclBhdHRlcm4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIFRPRE8gV2UgX2N1cnJlbnRseV8gZG9uJ3Qgc3VwcG9ydCBtdWx0aXBsZSAub25FbnRlcnMoKSBmb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gc3RhdGUsIGJ1dCB0aGlzIGlzIG5vdCBhIGZ1bmRhbWVudGFsIGxpbWl0YXRpb24uIEp1c3Qgbm90XG4gICAgICAgIC8vIGltcGxlbWVudGVkIHlldC4gSWYgd2Ugd2FudGVkIHRvLCB3ZSBjb3VsZCBtYWtlIHRoaXMgYW4gYXJyYXkuXG4gICAgICAgIGBlbnRlci9leGl0IGZ1bmN0aW9uIGZvciAke25hbWVPclBhdHRlcm59IGFscmVhZHkgZXhpc3RzYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5lbnRlckZucy5zZXQobmFtZU9yUGF0dGVybiwgZW50ZXJGbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb25FbnRlckFzeW5jKG5hbWVPclBhdHRlcm4sIHByb21pc2VGbiwgb25PSywgb25FcnJvcikge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIobmFtZU9yUGF0dGVybiwgKCkgPT4ge1xuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICB2b2lkIHByb21pc2VGbih0aGlzLmN1cnJlbnRDb250ZXh0LmN1cnJlbnQsIHNpZ25hbCkudGhlbihcbiAgICAgICAgLy8gT24gT0tcbiAgICAgICAgKGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfT0tcIiwgZGF0YSB9LCBvbk9LKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE9uIEVycm9yXG4gICAgICAgIChyZWFzb24pID0+IHtcbiAgICAgICAgICBpZiAoIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfRVJST1JcIiwgcmVhc29uIH0sIG9uRXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGdldFN0YXRlc01hdGNoaW5nKG5hbWVPclBhdHRlcm4pIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgaWYgKG5hbWVPclBhdHRlcm4gPT09IFwiKlwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHN0YXRlIG9mIHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lT3JQYXR0ZXJuLmVuZHNXaXRoKFwiLipcIikpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IG5hbWVPclBhdHRlcm4uc2xpY2UoMCwgLTEpO1xuICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiB0aGlzLnN0YXRlcykge1xuICAgICAgICBpZiAoc3RhdGUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuYW1lID0gbmFtZU9yUGF0dGVybjtcbiAgICAgIGlmICh0aGlzLnN0YXRlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3RhdGVzIG1hdGNoICR7SlNPTi5zdHJpbmdpZnkobmFtZU9yUGF0dGVybil9YCk7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmUgYWxsIGFsbG93ZWQgb3V0Z29pbmcgdHJhbnNpdGlvbnMgZm9yIGEgc3RhdGUuXG4gICAqXG4gICAqIFRoZSB0YXJnZXRzIGZvciBlYWNoIGV2ZW50IGNhbiBiZSBkZWZpbmVkIGFzIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGVcbiAgICogbmV4dCBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvLiBUaGVzZSBmdW5jdGlvbnMgY2FuIGxvb2sgYXQgdGhlIGBldmVudGAgb3JcbiAgICogYGNvbnRleHRgIHBhcmFtcyB0byBjb25kaXRpb25hbGx5IGRlY2lkZSB3aGljaCBuZXh0IHN0YXRlIHRvIHRyYW5zaXRpb25cbiAgICogdG8uXG4gICAqXG4gICAqIElmIHlvdSBzZXQgaXQgdG8gYG51bGxgLCB0aGVuIHRoZSB0cmFuc2l0aW9uIHdpbGwgYmUgZXhwbGljaXRseSBmb3JiaWRkZW5cbiAgICogYW5kIHRocm93IGFuIGVycm9yLiBJZiB5b3UgZG9uJ3QgZGVmaW5lIGEgdGFyZ2V0IGZvciBhIHRyYW5zaXRpb24sIHRoZW5cbiAgICogc3VjaCBldmVudHMgd2lsbCBnZXQgaWdub3JlZC5cbiAgICovXG4gIGFkZFRyYW5zaXRpb25zKG5hbWVPclBhdHRlcm4sIG1hcHBpbmcpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3JjU3RhdGUgb2YgdGhpcy5nZXRTdGF0ZXNNYXRjaGluZyhuYW1lT3JQYXR0ZXJuKSkge1xuICAgICAgbGV0IG1hcCA9IHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zLmdldChzcmNTdGF0ZSk7XG4gICAgICBpZiAobWFwID09PSB2b2lkIDApIHtcbiAgICAgICAgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbGxvd2VkVHJhbnNpdGlvbnMuc2V0KHNyY1N0YXRlLCBtYXApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbdHlwZSwgdGFyZ2V0X10gb2YgT2JqZWN0LmVudHJpZXMobWFwcGluZykpIHtcbiAgICAgICAgaWYgKG1hcC5oYXModHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVHJ5aW5nIHRvIHNldCB0cmFuc2l0aW9uIFwiJHt0eXBlfVwiIG9uIFwiJHtzcmNTdGF0ZX1cIiAodmlhIFwiJHtuYW1lT3JQYXR0ZXJufVwiKSwgYnV0IGEgdHJhbnNpdGlvbiBhbHJlYWR5IGV4aXN0cyB0aGVyZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRfO1xuICAgICAgICB0aGlzLmtub3duRXZlbnRUeXBlcy5hZGQodHlwZSk7XG4gICAgICAgIGlmICh0YXJnZXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldEZuID0gdHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiID8gdGFyZ2V0IDogKCkgPT4gdGFyZ2V0O1xuICAgICAgICAgIG1hcC5zZXQodHlwZSwgdGFyZ2V0Rm4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBMaWtlIGAuYWRkVHJhbnNpdGlvbigpYCwgYnV0IHRha2VzIGFuIChhbm9ueW1vdXMpIHRyYW5zaXRpb24gd2hlbmV2ZXIgdGhlXG4gICAqIHRpbWVyIGZpcmVzLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGVPclBhdHRlcm4gVGhlIHN0YXRlIG5hbWUsIG9yIHN0YXRlIGdyb3VwIHBhdHRlcm4gbmFtZS5cbiAgICogQHBhcmFtIGFmdGVyICAgICAgICAgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggdG8gdGFrZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uIElmIGluIHRoZSBtZWFuIHRpbWUsIGFub3RoZXIgdHJhbnNpdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgaXMgdGFrZW4sIHRoZSB0aW1lciB3aWxsIGdldCBjYW5jZWxsZWQuXG4gICAqIEBwYXJhbSB0YXJnZXQgICAgIFRoZSB0YXJnZXQgc3RhdGUgdG8gZ28gdG8uXG4gICAqL1xuICBhZGRUaW1lZFRyYW5zaXRpb24oc3RhdGVPclBhdHRlcm4sIGFmdGVyMiwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMub25FbnRlcihzdGF0ZU9yUGF0dGVybiwgKCkgPT4ge1xuICAgICAgY29uc3QgbXMgPSB0eXBlb2YgYWZ0ZXIyID09PSBcImZ1bmN0aW9uXCIgPyBhZnRlcjIodGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50KSA6IGFmdGVyMjtcbiAgICAgIGNvbnN0IHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24oeyB0eXBlOiBcIlRJTUVSXCIgfSwgdGFyZ2V0KTtcbiAgICAgIH0sIG1zKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBnZXRUYXJnZXRGbihldmVudE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd2VkVHJhbnNpdGlvbnMuZ2V0KHRoaXMuY3VycmVudFN0YXRlKT8uZ2V0KGV2ZW50TmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4aXRzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBjbGVhbnVwIGZ1bmN0aW9ucy5cbiAgICogQ2FsbCB0aGlzIGJlZm9yZSBjaGFuZ2luZyB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIGxldmVscyBEZWZpbmVzIGhvdyBtYW55IFwibGV2ZWxzXCIgb2YgbmVzdGluZyB3aWxsIGJlXG4gICAqIGV4aXRlZC4gRm9yIGV4YW1wbGUsIGlmIHlvdSB0cmFuc2l0aW9uIGZyb20gYGZvby5iYXIucXV4YCB0b1xuICAgKiBgZm9vLmJhci5iYXpgLCB0aGVuIHRoZSBsZXZlbCBpcyAxLiBCdXQgaWYgeW91IHRyYW5zaXRpb24gZnJvbVxuICAgKiBgZm9vLmJhci5xdXhgIHRvIGBibGEuYmxhYCwgdGhlbiB0aGUgbGV2ZWwgaXMgMy5cbiAgICogSWYgYG51bGxgLCBpdCB3aWxsIGV4aXQgYWxsIGxldmVscy5cbiAgICovXG4gIGV4aXQobGV2ZWxzKSB7XG4gICAgdGhpcy5ldmVudEh1Yi53aWxsRXhpdFN0YXRlLm5vdGlmeSh0aGlzLmN1cnJlbnRTdGF0ZSk7XG4gICAgdGhpcy5jdXJyZW50Q29udGV4dC5hbGxvd1BhdGNoaW5nKChwYXRjaGFibGVDb250ZXh0KSA9PiB7XG4gICAgICBsZXZlbHMgPSBsZXZlbHMgPz8gdGhpcy5jbGVhbnVwU3RhY2subGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHM7IGkrKykge1xuICAgICAgICB0aGlzLmNsZWFudXBTdGFjay5wb3AoKT8uKHBhdGNoYWJsZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFbnRlcnMgdGhlIGN1cnJlbnQgc3RhdGUsIGFuZCBleGVjdXRlcyBhbnkgbmVjZXNzYXJ5IG9uRW50ZXIgaGFuZGxlcnMuXG4gICAqIENhbGwgdGhpcyBkaXJlY3RseSBfYWZ0ZXJfIHNldHRpbmcgdGhlIGN1cnJlbnQgc3RhdGUgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAqL1xuICBlbnRlcihsZXZlbHMpIHtcbiAgICBjb25zdCBlbnRlclBhdHRlcm5zID0gcGF0dGVybnMoXG4gICAgICB0aGlzLmN1cnJlbnRTdGF0ZSxcbiAgICAgIGxldmVscyA/PyB0aGlzLmN1cnJlbnRTdGF0ZS5zcGxpdChcIi5cIikubGVuZ3RoICsgMVxuICAgICk7XG4gICAgdGhpcy5jdXJyZW50Q29udGV4dC5hbGxvd1BhdGNoaW5nKChwYXRjaGFibGVDb250ZXh0KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgZW50ZXJQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBlbnRlckZuID0gdGhpcy5lbnRlckZucy5nZXQocGF0dGVybik7XG4gICAgICAgIGNvbnN0IGNsZWFudXBGbiA9IGVudGVyRm4/LihwYXRjaGFibGVDb250ZXh0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhbnVwRm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRoaXMuY2xlYW51cFN0YWNrLnB1c2goY2xlYW51cEZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNsZWFudXBTdGFjay5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5ldmVudEh1Yi5kaWRFbnRlclN0YXRlLm5vdGlmeSh0aGlzLmN1cnJlbnRTdGF0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGFuIGV2ZW50IHRvIHRoZSBtYWNoaW5lLCB3aGljaCBtYXkgY2F1c2UgYW4gaW50ZXJuYWwgc3RhdGVcbiAgICogdHJhbnNpdGlvbiB0byBoYXBwZW4uIFdoZW4gdGhhdCBoYXBwZW5zLCB3aWxsIHRyaWdnZXIgc2lkZSBlZmZlY3RzLlxuICAgKi9cbiAgc2VuZChldmVudCkge1xuICAgIGlmICghdGhpcy5rbm93bkV2ZW50VHlwZXMuaGFzKGV2ZW50LnR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXZlbnQgJHtKU09OLnN0cmluZ2lmeShldmVudC50eXBlKX1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlID09PSAyIC8qIFNUT1BQRUQgKi8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0Rm4gPSB0aGlzLmdldFRhcmdldEZuKGV2ZW50LnR5cGUpO1xuICAgIGlmICh0YXJnZXRGbiAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uKGV2ZW50LCB0YXJnZXRGbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgdHJhbnNpdGlvbihldmVudCwgdGFyZ2V0KSB7XG4gICAgdGhpcy5ldmVudEh1Yi5kaWRSZWNlaXZlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICBjb25zdCBvbGRTdGF0ZSA9IHRoaXMuY3VycmVudFN0YXRlO1xuICAgIGNvbnN0IHRhcmdldEZuID0gdHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiID8gdGFyZ2V0IDogKCkgPT4gdGFyZ2V0O1xuICAgIGNvbnN0IG5leHRUYXJnZXQgPSB0YXJnZXRGbihldmVudCwgdGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50KTtcbiAgICBsZXQgbmV4dFN0YXRlO1xuICAgIGxldCBlZmZlY3RzID0gdm9pZCAwO1xuICAgIGlmIChuZXh0VGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICB0aGlzLmV2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm5vdGlmeShldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV4dFRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbmV4dFN0YXRlID0gbmV4dFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFN0YXRlID0gbmV4dFRhcmdldC50YXJnZXQ7XG4gICAgICBlZmZlY3RzID0gQXJyYXkuaXNBcnJheShuZXh0VGFyZ2V0LmVmZmVjdCkgPyBuZXh0VGFyZ2V0LmVmZmVjdCA6IFtuZXh0VGFyZ2V0LmVmZmVjdF07XG4gICAgfVxuICAgIGlmICghdGhpcy5zdGF0ZXMuaGFzKG5leHRTdGF0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuZXh0IHN0YXRlIG5hbWU6ICR7SlNPTi5zdHJpbmdpZnkobmV4dFN0YXRlKX1gKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5ub3RpZnkoeyBmcm9tOiBvbGRTdGF0ZSwgdG86IG5leHRTdGF0ZSB9KTtcbiAgICBjb25zdCBbdXAsIGRvd25dID0gZGlzdGFuY2UodGhpcy5jdXJyZW50U3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgaWYgKHVwID4gMCkge1xuICAgICAgdGhpcy5leGl0KHVwKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50U3RhdGVPck51bGwgPSBuZXh0U3RhdGU7XG4gICAgaWYgKGVmZmVjdHMgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZWZmZWN0c1RvUnVuID0gZWZmZWN0cztcbiAgICAgIHRoaXMuY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBlZmZlY3RzVG9SdW4pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBlZmZlY3QocGF0Y2hhYmxlQ29udGV4dCwgZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRjaGFibGVDb250ZXh0LnBhdGNoKGVmZmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRvd24gPiAwKSB7XG4gICAgICB0aGlzLmVudGVyKGRvd24pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2xpYi91dGlscy50c1xuZnVuY3Rpb24gcmFpc2UobXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChibG9iKSB7XG4gIHJldHVybiBibG9iICE9PSBudWxsICYmIHR5cGVvZiBibG9iID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChibG9iKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cbmZ1bmN0aW9uIGVudHJpZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopO1xufVxuZnVuY3Rpb24gdHJ5UGFyc2VKc29uKHJhd01lc3NhZ2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyYXdNZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZXBDbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gYjY0ZGVjb2RlKGI2NHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZm9ybWF0dGVkVmFsdWUgPSBiNjR2YWx1ZS5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgICBjb25zdCBkZWNvZGVkVmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoXG4gICAgICBhdG9iKGZvcm1hdHRlZFZhbHVlKS5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gXCIlXCIgKyAoXCIwMFwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgICAgfSkuam9pbihcIlwiKVxuICAgICk7XG4gICAgcmV0dXJuIGRlY29kZWRWYWx1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGF0b2IoYjY0dmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wYWN0KGl0ZW1zKSB7XG4gIHJldHVybiBpdGVtcy5maWx0ZXIoXG4gICAgKGl0ZW0pID0+IGl0ZW0gIT09IG51bGwgJiYgaXRlbSAhPT0gdm9pZCAwXG4gICk7XG59XG5mdW5jdGlvbiBjb21wYWN0T2JqZWN0KG9iaikge1xuICBjb25zdCBuZXdPYmogPSB7IC4uLm9iaiB9O1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGspID0+IHtcbiAgICBjb25zdCBrZXkgPSBrO1xuICAgIGlmIChuZXdPYmpba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxldGUgbmV3T2JqW2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ld09iajtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhUaW1lb3V0KHByb21pc2UsIG1pbGxpcywgZXJybXNnKSB7XG4gIGxldCB0aW1lcklEO1xuICBjb25zdCB0aW1lciQgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgdGltZXJJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJtc2cpKTtcbiAgICB9LCBtaWxsaXMpO1xuICB9KTtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZXIkXSkuZmluYWxseSgoKSA9PiBjbGVhclRpbWVvdXQodGltZXJJRCkpO1xufVxuXG4vLyBzcmMvcHJvdG9jb2wvU2VydmVyTXNnLnRzXG52YXIgU2VydmVyTXNnQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNlcnZlck1zZ0NvZGUyKSA9PiB7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1BSRVNFTkNFXCJdID0gMTAwXSA9IFwiVVBEQVRFX1BSRVNFTkNFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVNFUl9KT0lORURcIl0gPSAxMDFdID0gXCJVU0VSX0pPSU5FRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVTRVJfTEVGVFwiXSA9IDEwMl0gPSBcIlVTRVJfTEVGVFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkJST0FEQ0FTVEVEX0VWRU5UXCJdID0gMTAzXSA9IFwiQlJPQURDQVNURURfRVZFTlRcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJST09NX1NUQVRFXCJdID0gMTA0XSA9IFwiUk9PTV9TVEFURVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIklOSVRJQUxfU1RPUkFHRV9TVEFURVwiXSA9IDIwMF0gPSBcIklOSVRJQUxfU1RPUkFHRV9TVEFURVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlVQREFURV9TVE9SQUdFXCJdID0gMjAxXSA9IFwiVVBEQVRFX1NUT1JBR0VcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJSRUpFQ1RfU1RPUkFHRV9PUFwiXSA9IDI5OV0gPSBcIlJFSkVDVF9TVE9SQUdFX09QXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1lET0NcIl0gPSAzMDBdID0gXCJVUERBVEVfWURPQ1wiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9DUkVBVEVEXCJdID0gNDAwXSA9IFwiVEhSRUFEX0NSRUFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfTUVUQURBVEFfVVBEQVRFRFwiXSA9IDQwMV0gPSBcIlRIUkVBRF9NRVRBREFUQV9VUERBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9DUkVBVEVEXCJdID0gNDAyXSA9IFwiQ09NTUVOVF9DUkVBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9FRElURURcIl0gPSA0MDNdID0gXCJDT01NRU5UX0VESVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfREVMRVRFRFwiXSA9IDQwNF0gPSBcIkNPTU1FTlRfREVMRVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfUkVBQ1RJT05fQURERURcIl0gPSA0MDVdID0gXCJDT01NRU5UX1JFQUNUSU9OX0FEREVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEXCJdID0gNDA2XSA9IFwiQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEXCI7XG4gIHJldHVybiBTZXJ2ZXJNc2dDb2RlMjtcbn0pKFNlcnZlck1zZ0NvZGUgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvSVdlYlNvY2tldC50c1xudmFyIFdlYnNvY2tldENsb3NlQ29kZXMgPSAvKiBAX19QVVJFX18gKi8gKChXZWJzb2NrZXRDbG9zZUNvZGVzMikgPT4ge1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIkNMT1NFX05PUk1BTFwiXSA9IDFlM10gPSBcIkNMT1NFX05PUk1BTFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIkNMT1NFX0FCTk9STUFMXCJdID0gMTAwNl0gPSBcIkNMT1NFX0FCTk9STUFMXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVU5FWFBFQ1RFRF9DT05ESVRJT05cIl0gPSAxMDExXSA9IFwiVU5FWFBFQ1RFRF9DT05ESVRJT05cIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJUUllfQUdBSU5fTEFURVJcIl0gPSAxMDEzXSA9IFwiVFJZX0FHQUlOX0xBVEVSXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiSU5WQUxJRF9NRVNTQUdFX0ZPUk1BVFwiXSA9IDRlM10gPSBcIklOVkFMSURfTUVTU0FHRV9GT1JNQVRcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJOT1RfQUxMT1dFRFwiXSA9IDQwMDFdID0gXCJOT1RfQUxMT1dFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX1NFQ09ORFNcIl0gPSA0MDAyXSA9IFwiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfU0VDT05EU1wiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU1wiXSA9IDQwMDNdID0gXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9EQVlfUEVSX0FQUFwiXSA9IDQwMDRdID0gXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9EQVlfUEVSX0FQUFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU19QRVJfUk9PTVwiXSA9IDQwMDVdID0gXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNfUEVSX1JPT01cIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJLSUNLRURcIl0gPSA0MTAwXSA9IFwiS0lDS0VEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVE9LRU5fRVhQSVJFRFwiXSA9IDQxMDldID0gXCJUT0tFTl9FWFBJUkVEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfV0lUSE9VVF9SRVRSWVwiXSA9IDQ5OTldID0gXCJDTE9TRV9XSVRIT1VUX1JFVFJZXCI7XG4gIHJldHVybiBXZWJzb2NrZXRDbG9zZUNvZGVzMjtcbn0pKFdlYnNvY2tldENsb3NlQ29kZXMgfHwge30pO1xuZnVuY3Rpb24gc2hvdWxkRGlzY29ubmVjdChjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSA0OTk5IC8qIENMT1NFX1dJVEhPVVRfUkVUUlkgKi8gfHwgY29kZSA+PSA0ZTMgJiYgY29kZSA8IDQxMDA7XG59XG5mdW5jdGlvbiBzaG91bGRSZWF1dGgoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSA0MTAwICYmIGNvZGUgPCA0MjAwO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwMTMgLyogVFJZX0FHQUlOX0xBVEVSICovIHx8IGNvZGUgPj0gNDIwMCAmJiBjb2RlIDwgNDMwMDtcbn1cblxuLy8gc3JjL2Nvbm5lY3Rpb24udHNcbmZ1bmN0aW9uIGlzSWRsZShzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gXCJpbml0aWFsXCIgfHwgc3RhdHVzID09PSBcImRpc2Nvbm5lY3RlZFwiO1xufVxuZnVuY3Rpb24gbmV3VG9MZWdhY3lTdGF0dXMoc3RhdHVzKSB7XG4gIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgY2FzZSBcImNvbm5lY3RpbmdcIjpcbiAgICAgIHJldHVybiBcImNvbm5lY3RpbmdcIjtcbiAgICBjYXNlIFwiY29ubmVjdGVkXCI6XG4gICAgICByZXR1cm4gXCJvcGVuXCI7XG4gICAgY2FzZSBcInJlY29ubmVjdGluZ1wiOlxuICAgICAgcmV0dXJuIFwidW5hdmFpbGFibGVcIjtcbiAgICBjYXNlIFwiZGlzY29ubmVjdGVkXCI6XG4gICAgICByZXR1cm4gXCJmYWlsZWRcIjtcbiAgICBjYXNlIFwiaW5pdGlhbFwiOlxuICAgICAgcmV0dXJuIFwiY2xvc2VkXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcImNsb3NlZFwiO1xuICB9XG59XG5mdW5jdGlvbiB0b05ld0Nvbm5lY3Rpb25TdGF0dXMobWFjaGluZSkge1xuICBjb25zdCBzdGF0ZSA9IG1hY2hpbmUuY3VycmVudFN0YXRlO1xuICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgY2FzZSBcIkBvay5jb25uZWN0ZWRcIjpcbiAgICBjYXNlIFwiQG9rLmF3YWl0aW5nLXBvbmdcIjpcbiAgICAgIHJldHVybiBcImNvbm5lY3RlZFwiO1xuICAgIGNhc2UgXCJAaWRsZS5pbml0aWFsXCI6XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgY2FzZSBcIkBhdXRoLmJ1c3lcIjpcbiAgICBjYXNlIFwiQGF1dGguYmFja29mZlwiOlxuICAgIGNhc2UgXCJAY29ubmVjdGluZy5idXN5XCI6XG4gICAgY2FzZSBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIjpcbiAgICBjYXNlIFwiQGlkbGUuem9tYmllXCI6XG4gICAgICByZXR1cm4gbWFjaGluZS5jb250ZXh0LnN1Y2Nlc3NDb3VudCA+IDAgPyBcInJlY29ubmVjdGluZ1wiIDogXCJjb25uZWN0aW5nXCI7XG4gICAgY2FzZSBcIkBpZGxlLmZhaWxlZFwiOlxuICAgICAgcmV0dXJuIFwiZGlzY29ubmVjdGVkXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihzdGF0ZSwgXCJVbmtub3duIHN0YXRlXCIpO1xuICB9XG59XG52YXIgQkFDS09GRl9ERUxBWVMgPSBbMjUwLCA1MDAsIDFlMywgMmUzLCA0ZTMsIDhlMywgMWU0XTtcbnZhciBSRVNFVF9ERUxBWSA9IEJBQ0tPRkZfREVMQVlTWzBdIC0gMTtcbnZhciBCQUNLT0ZGX0RFTEFZU19TTE9XID0gWzJlMywgM2U0LCA2ZTQsIDNlNV07XG52YXIgSEVBUlRCRUFUX0lOVEVSVkFMID0gM2U0O1xudmFyIFBPTkdfVElNRU9VVCA9IDJlMztcbnZhciBBVVRIX1RJTUVPVVQgPSAxZTQ7XG52YXIgU09DS0VUX0NPTk5FQ1RfVElNRU9VVCA9IDFlNDtcbnZhciBTdG9wUmV0cnlpbmcgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIocmVhc29uKTtcbiAgfVxufTtcbnZhciBMaXZlYmxvY2tzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufTtcbmZ1bmN0aW9uIG5leHRCYWNrb2ZmRGVsYXkoY3VycmVudERlbGF5LCBkZWxheXMpIHtcbiAgcmV0dXJuIGRlbGF5cy5maW5kKChkZWxheSkgPT4gZGVsYXkgPiBjdXJyZW50RGVsYXkpID8/IGRlbGF5c1tkZWxheXMubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBpbmNyZWFzZUJhY2tvZmZEZWxheShjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goe1xuICAgIGJhY2tvZmZEZWxheTogbmV4dEJhY2tvZmZEZWxheShjb250ZXh0LmJhY2tvZmZEZWxheSwgQkFDS09GRl9ERUxBWVMpXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHkoY29udGV4dCkge1xuICBjb250ZXh0LnBhdGNoKHtcbiAgICBiYWNrb2ZmRGVsYXk6IG5leHRCYWNrb2ZmRGVsYXkoY29udGV4dC5iYWNrb2ZmRGVsYXksIEJBQ0tPRkZfREVMQVlTX1NMT1cpXG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzZXRTdWNjZXNzQ291bnQoY29udGV4dCkge1xuICBjb250ZXh0LnBhdGNoKHsgc3VjY2Vzc0NvdW50OiAwIH0pO1xufVxuZnVuY3Rpb24gbG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGxvZ2dlciA9IGxldmVsID09PSAyIC8qIEVSUk9SICovID8gZXJyb3IyIDogbGV2ZWwgPT09IDEgLyogV0FSTiAqLyA/IHdhcm4gOiAoXG4gICAgLyogYmxhY2sgaG9sZSAqL1xuICAgICgpID0+IHtcbiAgICB9XG4gICk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbG9nZ2VyKG1lc3NhZ2UpO1xuICB9O1xufVxuZnVuY3Rpb24gbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZSkge1xuICBjb25zdCBjb25uID0gXCJDb25uZWN0aW9uIHRvIExpdmVibG9ja3Mgd2Vic29ja2V0IHNlcnZlclwiO1xuICByZXR1cm4gKGN0eCkgPT4ge1xuICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHdhcm4oYCR7Y29ubn0gY291bGQgbm90IGJlIGVzdGFibGlzaGVkLiAke1N0cmluZyhlKX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgaXNDbG9zZUV2ZW50KGUpID8gYCR7Y29ubn0gY2xvc2VkIHByZW1hdHVyZWx5IChjb2RlOiAke2UuY29kZX0pLiBSZXRyeWluZyBpbiAke2N0eC5iYWNrb2ZmRGVsYXl9bXMuYCA6IGAke2Nvbm59IGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGxvZ0Nsb3NlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYENvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyIGNsb3NlZCAoY29kZTogJHtldmVudC5jb2RlfSkuIFJldHJ5aW5nIGluICR7Y3R4LmJhY2tvZmZEZWxheX1tcy5gXG4gICAgKTtcbiAgfTtcbn1cbnZhciBsb2dQZXJtYW5lbnRDbG9zZSA9IGxvZyhcbiAgMSAvKiBXQVJOICovLFxuICBcIkNvbm5lY3Rpb24gdG8gV2ViU29ja2V0IGNsb3NlZCBwZXJtYW5lbnRseS4gV29uJ3QgcmV0cnkuXCJcbik7XG5mdW5jdGlvbiBpc0Nsb3NlRXZlbnQoZXJyb3IzKSB7XG4gIHJldHVybiAhKGVycm9yMyBpbnN0YW5jZW9mIEVycm9yKSAmJiBlcnJvcjMudHlwZSA9PT0gXCJjbG9zZVwiO1xufVxuZnVuY3Rpb24gZW5hYmxlVHJhY2luZyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXJ0ID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIGZ1bmN0aW9uIGxvZzIoLi4uYXJncykge1xuICAgIHdhcm4oXG4gICAgICBgJHsoKCgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQpIC8gMWUzKS50b0ZpeGVkKDIpfSBbRlNNICMke21hY2hpbmUuaWR9XWAsXG4gICAgICAuLi5hcmdzXG4gICAgKTtcbiAgfVxuICBjb25zdCB1bnN1YnMgPSBbXG4gICAgbWFjaGluZS5ldmVudHMuZGlkUmVjZWl2ZUV2ZW50LnN1YnNjcmliZSgoZSkgPT4gbG9nMihgRXZlbnQgJHtlLnR5cGV9YCkpLFxuICAgIG1hY2hpbmUuZXZlbnRzLndpbGxUcmFuc2l0aW9uLnN1YnNjcmliZShcbiAgICAgICh7IGZyb20sIHRvIH0pID0+IGxvZzIoXCJUcmFuc2l0aW9uaW5nXCIsIGZyb20sIFwiXFx1MjE5MlwiLCB0bylcbiAgICApLFxuICAgIG1hY2hpbmUuZXZlbnRzLmRpZElnbm9yZUV2ZW50LnN1YnNjcmliZShcbiAgICAgIChlKSA9PiBsb2cyKFwiSWdub3JlZCBldmVudFwiLCBlLnR5cGUsIGUsIFwiKGN1cnJlbnQgc3RhdGUgd29uJ3QgaGFuZGxlIGl0KVwiKVxuICAgIClcbiAgICAvLyBtYWNoaW5lLmV2ZW50cy53aWxsRXhpdFN0YXRlLnN1YnNjcmliZSgocykgPT4gbG9nKFwiRXhpdGluZyBzdGF0ZVwiLCBzKSksXG4gICAgLy8gbWFjaGluZS5ldmVudHMuZGlkRW50ZXJTdGF0ZS5zdWJzY3JpYmUoKHMpID0+IGxvZyhcIkVudGVyaW5nIHN0YXRlXCIsIHMpKSxcbiAgXTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IHVuc3ViIG9mIHVuc3Vicykge1xuICAgICAgdW5zdWIoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWZpbmVDb25uZWN0aXZpdHlFdmVudHMobWFjaGluZSkge1xuICBjb25zdCBzdGF0dXNEaWRDaGFuZ2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgY29uc3QgZGlkQ29ubmVjdCA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBjb25zdCBkaWREaXNjb25uZWN0ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGxldCBsYXN0U3RhdHVzID0gbnVsbDtcbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBtYWNoaW5lLmV2ZW50cy5kaWRFbnRlclN0YXRlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgY29uc3QgY3VyclN0YXR1cyA9IHRvTmV3Q29ubmVjdGlvblN0YXR1cyhtYWNoaW5lKTtcbiAgICBpZiAoY3VyclN0YXR1cyAhPT0gbGFzdFN0YXR1cykge1xuICAgICAgc3RhdHVzRGlkQ2hhbmdlLm5vdGlmeShjdXJyU3RhdHVzKTtcbiAgICB9XG4gICAgaWYgKGxhc3RTdGF0dXMgPT09IFwiY29ubmVjdGVkXCIgJiYgY3VyclN0YXR1cyAhPT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgZGlkRGlzY29ubmVjdC5ub3RpZnkoKTtcbiAgICB9IGVsc2UgaWYgKGxhc3RTdGF0dXMgIT09IFwiY29ubmVjdGVkXCIgJiYgY3VyclN0YXR1cyA9PT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgZGlkQ29ubmVjdC5ub3RpZnkoKTtcbiAgICB9XG4gICAgbGFzdFN0YXR1cyA9IGN1cnJTdGF0dXM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHN0YXR1c0RpZENoYW5nZTogc3RhdHVzRGlkQ2hhbmdlLm9ic2VydmFibGUsXG4gICAgZGlkQ29ubmVjdDogZGlkQ29ubmVjdC5vYnNlcnZhYmxlLFxuICAgIGRpZERpc2Nvbm5lY3Q6IGRpZERpc2Nvbm5lY3Qub2JzZXJ2YWJsZSxcbiAgICB1bnN1YnNjcmliZVxuICB9O1xufVxudmFyIGFzc2lnbiA9IChwYXRjaCkgPT4gKGN0eCkgPT4gY3R4LnBhdGNoKHBhdGNoKTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25TdGF0ZU1hY2hpbmUoZGVsZWdhdGVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9uTWVzc2FnZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBvbk1lc3NhZ2UucGF1c2UoKTtcbiAgY29uc3Qgb25MaXZlYmxvY2tzRXJyb3IgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgZnVuY3Rpb24gZmlyZUVycm9yRXZlbnQoZXJybXNnLCBlcnJjb2RlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBMaXZlYmxvY2tzRXJyb3IoZXJybXNnLCBlcnJjb2RlKTtcbiAgICAgIG9uTGl2ZWJsb2Nrc0Vycm9yLm5vdGlmeShlcnIpO1xuICAgIH07XG4gIH1cbiAgY29uc3QgaW5pdGlhbENvbnRleHQgPSB7XG4gICAgc3VjY2Vzc0NvdW50OiAwLFxuICAgIGF1dGhWYWx1ZTogbnVsbCxcbiAgICBzb2NrZXQ6IG51bGwsXG4gICAgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWVxuICB9O1xuICBjb25zdCBtYWNoaW5lID0gbmV3IEZTTShpbml0aWFsQ29udGV4dCkuYWRkU3RhdGUoXCJAaWRsZS5pbml0aWFsXCIpLmFkZFN0YXRlKFwiQGlkbGUuZmFpbGVkXCIpLmFkZFN0YXRlKFwiQGlkbGUuem9tYmllXCIpLmFkZFN0YXRlKFwiQGF1dGguYnVzeVwiKS5hZGRTdGF0ZShcIkBhdXRoLmJhY2tvZmZcIikuYWRkU3RhdGUoXCJAY29ubmVjdGluZy5idXN5XCIpLmFkZFN0YXRlKFwiQGNvbm5lY3RpbmcuYmFja29mZlwiKS5hZGRTdGF0ZShcIkBvay5jb25uZWN0ZWRcIikuYWRkU3RhdGUoXCJAb2suYXdhaXRpbmctcG9uZ1wiKTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIipcIiwge1xuICAgIFJFQ09OTkVDVDoge1xuICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCByZXNldFN1Y2Nlc3NDb3VudF1cbiAgICB9LFxuICAgIERJU0NPTk5FQ1Q6IFwiQGlkbGUuaW5pdGlhbFwiXG4gIH0pO1xuICBtYWNoaW5lLm9uRW50ZXIoXCJAaWRsZS4qXCIsIHJlc2V0U3VjY2Vzc0NvdW50KS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlLipcIiwge1xuICAgIENPTk5FQ1Q6IChfLCBjdHgpID0+IChcbiAgICAgIC8vIElmIHdlIHN0aWxsIGhhdmUgYSBrbm93biBhdXRoVmFsdWUsIHRyeSB0byByZWNvbm5lY3QgdG8gdGhlIHNvY2tldCBkaXJlY3RseSxcbiAgICAgIC8vIG90aGVyd2lzZSwgdHJ5IHRvIG9idGFpbiBhIG5ldyBhdXRoVmFsdWVcbiAgICAgIGN0eC5hdXRoVmFsdWUgIT09IG51bGwgPyBcIkBjb25uZWN0aW5nLmJ1c3lcIiA6IFwiQGF1dGguYnVzeVwiXG4gICAgKVxuICB9KTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBhdXRoLmJhY2tvZmZcIiwge1xuICAgIE5BVklHQVRPUl9PTkxJTkU6IHtcbiAgICAgIHRhcmdldDogXCJAYXV0aC5idXN5XCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7IGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVkgfSlcbiAgICB9XG4gIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcbiAgICBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAoY3R4KSA9PiBjdHguYmFja29mZkRlbGF5LFxuICAgIFwiQGF1dGguYnVzeVwiXG4gICkub25FbnRlckFzeW5jKFxuICAgIFwiQGF1dGguYnVzeVwiLFxuICAgICgpID0+IHdpdGhUaW1lb3V0KFxuICAgICAgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSgpLFxuICAgICAgQVVUSF9USU1FT1VULFxuICAgICAgXCJUaW1lZCBvdXQgZHVyaW5nIGF1dGhcIlxuICAgICksXG4gICAgLy8gT24gc3VjY2Vzc2Z1bCBhdXRoZW50aWNhdGlvblxuICAgIChva0V2ZW50KSA9PiAoe1xuICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHtcbiAgICAgICAgYXV0aFZhbHVlOiBva0V2ZW50LmRhdGFcbiAgICAgIH0pXG4gICAgfSksXG4gICAgLy8gQXV0aCBmYWlsZWRcbiAgICAoZmFpbGVkRXZlbnQpID0+IHtcbiAgICAgIGlmIChmYWlsZWRFdmVudC5yZWFzb24gaW5zdGFuY2VvZiBTdG9wUmV0cnlpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UpLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UsIC0xKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgIGluY3JlYXNlQmFja29mZkRlbGF5LFxuICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgIDIgLyogRVJST1IgKi8sXG4gICAgICAgICAgICBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2ZhaWxlZEV2ZW50LnJlYXNvbiBpbnN0YW5jZW9mIEVycm9yID8gZmFpbGVkRXZlbnQucmVhc29uLm1lc3NhZ2UgOiBTdHJpbmcoZmFpbGVkRXZlbnQucmVhc29uKX1gXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbiAgY29uc3Qgb25Tb2NrZXRFcnJvciA9IChldmVudCkgPT4gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfRVJST1JcIiwgZXZlbnQgfSk7XG4gIGNvbnN0IG9uU29ja2V0Q2xvc2UgPSAoZXZlbnQpID0+IG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0NMT1NFXCIsIGV2ZW50IH0pO1xuICBjb25zdCBvblNvY2tldE1lc3NhZ2UgPSAoZXZlbnQpID0+IGV2ZW50LmRhdGEgPT09IFwicG9uZ1wiID8gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJQT05HXCIgfSkgOiBvbk1lc3NhZ2Uubm90aWZ5KGV2ZW50KTtcbiAgZnVuY3Rpb24gdGVhcmRvd25Tb2NrZXQoc29ja2V0KSB7XG4gICAgaWYgKHNvY2tldCkge1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvblNvY2tldEVycm9yKTtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgb25Tb2NrZXRDbG9zZSk7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLCB7XG4gICAgTkFWSUdBVE9SX09OTElORToge1xuICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHsgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWSB9KVxuICAgIH1cbiAgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgIChjdHgpID0+IGN0eC5iYWNrb2ZmRGVsYXksXG4gICAgXCJAY29ubmVjdGluZy5idXN5XCJcbiAgKS5vbkVudGVyQXN5bmMoXG4gICAgXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgLy9cbiAgICAvLyBVc2UgdGhlIFwiY3JlYXRlU29ja2V0XCIgZGVsZWdhdGUgZnVuY3Rpb24gKHByb3ZpZGVkIHRvIHRoZVxuICAgIC8vIE1hbmFnZWRTb2NrZXQpIHRvIGNyZWF0ZSB0aGUgYWN0dWFsIFdlYlNvY2tldCBjb25uZWN0aW9uIGluc3RhbmNlLlxuICAgIC8vIFRoZW4sIHNldCB1cCBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMsIGFuZCB3YWl0IGZvciB0aGVcbiAgICAvLyBcIm9wZW5cIiBldmVudCB0byBvY2N1ci5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIFwib3BlblwiIGV2ZW50IGhhcHBlbnMsIHdlJ3JlIHJlYWR5IHRvIHRyYW5zaXRpb24gdG8gdGhlXG4gICAgLy8gT0sgc3RhdGUuIFRoaXMgaXMgZG9uZSBieSByZXNvbHZpbmcgdGhlIFByb21pc2UuXG4gICAgLy9cbiAgICBhc3luYyAoY3R4LCBzaWduYWwpID0+IHtcbiAgICAgIGxldCBjYXB0dXJlZFByZW1hdHVyZUV2ZW50ID0gbnVsbDtcbiAgICAgIGxldCB1bmNvbmZpcm1lZFNvY2tldCA9IG51bGw7XG4gICAgICBjb25zdCBjb25uZWN0JCA9IG5ldyBQcm9taXNlKFxuICAgICAgICAocmVzb2x2ZSwgcmVqKSA9PiB7XG4gICAgICAgICAgaWYgKGN0eC5hdXRoVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGF1dGggYXV0aFZhbHVlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzb2NrZXQgPSBkZWxlZ2F0ZXMuY3JlYXRlU29ja2V0KGN0eC5hdXRoVmFsdWUpO1xuICAgICAgICAgIHVuY29uZmlybWVkU29ja2V0ID0gc29ja2V0O1xuICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdChldmVudCkge1xuICAgICAgICAgICAgY2FwdHVyZWRQcmVtYXR1cmVFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICAgICAgICByZWooZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBbYWN0b3IkLCBkaWRSZWNlaXZlQWN0b3JdID0gY29udHJvbGxlZFByb21pc2UoKTtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMud2FpdEZvckFjdG9ySWQpIHtcbiAgICAgICAgICAgIGRpZFJlY2VpdmVBY3RvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB3YWl0Rm9yQWN0b3JJZChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmVyTXNnID0gdHJ5UGFyc2VKc29uKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgaWYgKHNlcnZlck1zZz8udHlwZSA9PT0gMTA0IC8qIFJPT01fU1RBVEUgKi8pIHtcbiAgICAgICAgICAgICAgZGlkUmVjZWl2ZUFjdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgICAgIGlmIChvcHRpb25zLndhaXRGb3JBY3RvcklkKSB7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgd2FpdEZvckFjdG9ySWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCByZWplY3QpO1xuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvblNvY2tldENsb3NlKTtcbiAgICAgICAgICAgIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHdhaXRGb3JBY3RvcklkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2b2lkIGFjdG9yJC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShbc29ja2V0LCB1bnN1Yl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gd2l0aFRpbWVvdXQoXG4gICAgICAgIGNvbm5lY3QkLFxuICAgICAgICBTT0NLRVRfQ09OTkVDVF9USU1FT1VULFxuICAgICAgICBcIlRpbWVkIG91dCBkdXJpbmcgd2Vic29ja2V0IGNvbm5lY3Rpb25cIlxuICAgICAgKS50aGVuKFxuICAgICAgICAvL1xuICAgICAgICAvLyBQYXJ0IDM6XG4gICAgICAgIC8vIEJ5IG5vdywgb3VyIFwib3BlblwiIGV2ZW50IGhhcyBmaXJlZCwgYW5kIHRoZSBwcm9taXNlIGhhcyBiZWVuXG4gICAgICAgIC8vIHJlc29sdmVkLiBUd28gcG9zc2libGUgc2NlbmFyaW9zOlxuICAgICAgICAvL1xuICAgICAgICAvLyAxLiBUaGUgaGFwcHkgcGF0aC4gTW9zdCBsaWtlbHkuXG4gICAgICAgIC8vIDIuIFVoLW9oLiBBIHByZW1hdHVyZSBjbG9zZS9lcnJvciBldmVudCBoYXMgYmVlbiBvYnNlcnZlZC4gTGV0J3NcbiAgICAgICAgLy8gICAgcmVqZWN0IHRoZSBwcm9taXNlIGFmdGVyIGFsbC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQW55IGNsb3NlL2Vycm9yIGV2ZW50IHRoYXQgd2lsbCBnZXQgc2NoZWR1bGVkIGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gb253YXJkcywgd2lsbCBiZSBjYXVnaHQgaW4gdGhlIE9LIHN0YXRlLCBhbmQgZGVhbHQgd2l0aFxuICAgICAgICAvLyBhY2NvcmRpbmdseS5cbiAgICAgICAgLy9cbiAgICAgICAgKFtzb2NrZXQsIHVuc3ViXSkgPT4ge1xuICAgICAgICAgIHVuc3ViKCk7XG4gICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYm9ydGVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FwdHVyZWRQcmVtYXR1cmVFdmVudCkge1xuICAgICAgICAgICAgdGhyb3cgY2FwdHVyZWRQcmVtYXR1cmVFdmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICAgICAgfVxuICAgICAgKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICB0ZWFyZG93blNvY2tldCh1bmNvbmZpcm1lZFNvY2tldCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIE9ubHkgdHJhbnNpdGlvbiB0byBPSyBzdGF0ZSBhZnRlciBhIHN1Y2Nlc3NmdWxseSBvcGVuZWQgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICAob2tFdmVudCkgPT4gKHtcbiAgICAgIHRhcmdldDogXCJAb2suY29ubmVjdGVkXCIsXG4gICAgICBlZmZlY3Q6IGFzc2lnbih7XG4gICAgICAgIHNvY2tldDogb2tFdmVudC5kYXRhLFxuICAgICAgICBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZXG4gICAgICB9KVxuICAgIH0pLFxuICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjYW5ub3QgYmUgZXN0YWJsaXNoZWRcbiAgICAoZmFpbHVyZSkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gZmFpbHVyZS5yZWFzb247XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgU3RvcFJldHJ5aW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgbG9nKDIgLyogRVJST1IgKi8sIGVyci5tZXNzYWdlKSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGVyci5tZXNzYWdlLCAtMSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNDbG9zZUV2ZW50KGVycikpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSA0MTA5IC8qIFRPS0VOX0VYUElSRUQgKi8pIHtcbiAgICAgICAgICByZXR1cm4gXCJAYXV0aC5idXN5XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChlcnIuY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgICBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseSxcbiAgICAgICAgICAgICAgbG9nUHJlbWF0dXJlRXJyb3JPckNsb3NlRXZlbnQoZXJyKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZERpc2Nvbm5lY3QoZXJyLmNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICAgIGVmZmVjdDogW1xuICAgICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZXJyLnJlYXNvbiksXG4gICAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGVyci5yZWFzb24sIGVyci5jb2RlKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAYXV0aC5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlcnIpXVxuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIGNvbnN0IHNlbmRIZWFydGJlYXQgPSB7XG4gICAgdGFyZ2V0OiBcIkBvay5hd2FpdGluZy1wb25nXCIsXG4gICAgZWZmZWN0OiAoY3R4KSA9PiB7XG4gICAgICBjdHguc29ja2V0Py5zZW5kKFwicGluZ1wiKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1heWJlSGVhcnRiZWF0ID0gKCkgPT4ge1xuICAgIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICAgIGNvbnN0IGNhblpvbWJpZSA9IGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiICYmIGRlbGVnYXRlcy5jYW5ab21iaWUoKTtcbiAgICByZXR1cm4gY2FuWm9tYmllID8gXCJAaWRsZS56b21iaWVcIiA6IHNlbmRIZWFydGJlYXQ7XG4gIH07XG4gIG1hY2hpbmUuYWRkVGltZWRUcmFuc2l0aW9uKFwiQG9rLmNvbm5lY3RlZFwiLCBIRUFSVEJFQVRfSU5URVJWQUwsIG1heWJlSGVhcnRiZWF0KS5hZGRUcmFuc2l0aW9ucyhcIkBvay5jb25uZWN0ZWRcIiwge1xuICAgIE5BVklHQVRPUl9PRkZMSU5FOiBtYXliZUhlYXJ0YmVhdCxcbiAgICAvLyBEb24ndCB0YWtlIHRoZSBicm93c2VyJ3Mgd29yZCBmb3IgaXQgd2hlbiBpdCBzYXlzIGl0J3Mgb2ZmbGluZS4gRG8gYSBwaW5nL3BvbmcgdG8gbWFrZSBzdXJlLlxuICAgIFdJTkRPV19HT1RfRk9DVVM6IHNlbmRIZWFydGJlYXRcbiAgfSk7XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAaWRsZS56b21iaWVcIiwge1xuICAgIFdJTkRPV19HT1RfRk9DVVM6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiXG4gICAgLy8gV2hlbiBpbiB6b21iaWUgc3RhdGUsIHRoZSBjbGllbnQgd2lsbCB0cnkgdG8gd2FrZSB1cCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHdpbmRvdyByZWdhaW5zIGZvY3VzXG4gIH0pO1xuICBtYWNoaW5lLm9uRW50ZXIoXCJAb2suKlwiLCAoY3R4KSA9PiB7XG4gICAgY3R4LnBhdGNoKHsgc3VjY2Vzc0NvdW50OiBjdHguc3VjY2Vzc0NvdW50ICsgMSB9KTtcbiAgICBjb25zdCB0aW1lcklEID0gc2V0VGltZW91dChcbiAgICAgIC8vIE9uIHRoZSBuZXh0IHRpY2ssIHN0YXJ0IGRlbGl2ZXJpbmcgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBhbHJlYWR5XG4gICAgICAvLyBiZWVuIHJlY2VpdmVkLCBhbmQgY29udGludWUgc3luY2hyb25vdXMgZGVsaXZlcnkgb2YgYWxsIGZ1dHVyZVxuICAgICAgLy8gaW5jb21pbmcgbWVzc2FnZXMuXG4gICAgICBvbk1lc3NhZ2UudW5wYXVzZSxcbiAgICAgIDBcbiAgICApO1xuICAgIHJldHVybiAoY3R4MikgPT4ge1xuICAgICAgdGVhcmRvd25Tb2NrZXQoY3R4Mi5zb2NrZXQpO1xuICAgICAgY3R4Mi5wYXRjaCh7IHNvY2tldDogbnVsbCB9KTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklEKTtcbiAgICAgIG9uTWVzc2FnZS5wYXVzZSgpO1xuICAgIH07XG4gIH0pLmFkZFRyYW5zaXRpb25zKFwiQG9rLmF3YWl0aW5nLXBvbmdcIiwgeyBQT05HOiBcIkBvay5jb25uZWN0ZWRcIiB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXCJAb2suYXdhaXRpbmctcG9uZ1wiLCBQT05HX1RJTUVPVVQsIHtcbiAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgIC8vIExvZyBpbXBsaWNpdCBjb25uZWN0aW9uIGxvc3MgYW5kIGRyb3AgdGhlIGN1cnJlbnQgb3BlbiBzb2NrZXRcbiAgICBlZmZlY3Q6IGxvZyhcbiAgICAgIDEgLyogV0FSTiAqLyxcbiAgICAgIFwiUmVjZWl2ZWQgbm8gcG9uZyBmcm9tIHNlcnZlciwgYXNzdW1lIGltcGxpY2l0IGNvbm5lY3Rpb24gbG9zcy5cIlxuICAgIClcbiAgfSkuYWRkVHJhbnNpdGlvbnMoXCJAb2suKlwiLCB7XG4gICAgLy8gV2hlbiBhIHNvY2tldCByZWNlaXZlcyBhbiBlcnJvciwgdGhpcyBjYW4gY2F1c2UgdGhlIGNsb3Npbmcgb2YgdGhlXG4gICAgLy8gc29ja2V0LCBvciBub3QuIFNvIGFsd2F5cyBjaGVjayB0byBzZWUgaWYgdGhlIHNvY2tldCBpcyBzdGlsbCBPUEVOIG9yXG4gICAgLy8gbm90LiBXaGVuIHN0aWxsIE9QRU4sIGRvbid0IHRyYW5zaXRpb24uXG4gICAgRVhQTElDSVRfU09DS0VUX0VSUk9SOiAoXywgY29udGV4dCkgPT4ge1xuICAgICAgaWYgKGNvbnRleHQuc29ja2V0Py5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBpbmNyZWFzZUJhY2tvZmZEZWxheVxuICAgICAgfTtcbiAgICB9LFxuICAgIEVYUExJQ0lUX1NPQ0tFVF9DTE9TRTogKGUpID0+IHtcbiAgICAgIGlmIChzaG91bGREaXNjb25uZWN0KGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2dQZXJtYW5lbnRDbG9zZSxcbiAgICAgICAgICAgIGZpcmVFcnJvckV2ZW50KGUuZXZlbnQucmVhc29uLCBlLmV2ZW50LmNvZGUpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJlYXV0aChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIGlmIChlLmV2ZW50LmNvZGUgPT09IDQxMDkgLyogVE9LRU5fRVhQSVJFRCAqLykge1xuICAgICAgICAgIHJldHVybiBcIkBhdXRoLmJ1c3lcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXlBZ2dyZXNzaXZlbHksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICAgIGNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gICAgY29uc3Qgcm9vdCA9IHdpbiA/PyBkb2M7XG4gICAgbWFjaGluZS5vbkVudGVyKFwiKlwiLCAoY3R4KSA9PiB7XG4gICAgICBmdW5jdGlvbiBvbk5ldHdvcmtPZmZsaW5lKCkge1xuICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIk5BVklHQVRPUl9PRkZMSU5FXCIgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvbk5ldHdvcmtCYWNrT25saW5lKCkge1xuICAgICAgICBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIk5BVklHQVRPUl9PTkxJTkVcIiB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikge1xuICAgICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiV0lORE9XX0dPVF9GT0NVU1wiIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25OZXR3b3JrQmFja09ubGluZSk7XG4gICAgICB3aW4/LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9uTmV0d29ya09mZmxpbmUpO1xuICAgICAgcm9vdD8uYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJvb3Q/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICAgIHdpbj8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbk5ldHdvcmtCYWNrT25saW5lKTtcbiAgICAgICAgd2luPy5yZW1vdmVFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBvbk5ldHdvcmtPZmZsaW5lKTtcbiAgICAgICAgdGVhcmRvd25Tb2NrZXQoY3R4LnNvY2tldCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IGNsZWFudXBzID0gW107XG4gIGNvbnN0IHsgc3RhdHVzRGlkQ2hhbmdlLCBkaWRDb25uZWN0LCBkaWREaXNjb25uZWN0LCB1bnN1YnNjcmliZSB9ID0gZGVmaW5lQ29ubmVjdGl2aXR5RXZlbnRzKG1hY2hpbmUpO1xuICBjbGVhbnVwcy5wdXNoKHVuc3Vic2NyaWJlKTtcbiAgaWYgKG9wdGlvbnMuZW5hYmxlRGVidWdMb2dnaW5nKSB7XG4gICAgY2xlYW51cHMucHVzaChlbmFibGVUcmFjaW5nKG1hY2hpbmUpKTtcbiAgfVxuICBtYWNoaW5lLnN0YXJ0KCk7XG4gIHJldHVybiB7XG4gICAgbWFjaGluZSxcbiAgICBjbGVhbnVwcyxcbiAgICAvLyBPYnNlcnZhYmxlIGV2ZW50cyB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSB0aGlzIG1hY2hpbmVcbiAgICBldmVudHM6IHtcbiAgICAgIHN0YXR1c0RpZENoYW5nZSxcbiAgICAgIGRpZENvbm5lY3QsXG4gICAgICBkaWREaXNjb25uZWN0LFxuICAgICAgb25NZXNzYWdlOiBvbk1lc3NhZ2Uub2JzZXJ2YWJsZSxcbiAgICAgIG9uTGl2ZWJsb2Nrc0Vycm9yOiBvbkxpdmVibG9ja3NFcnJvci5vYnNlcnZhYmxlXG4gICAgfVxuICB9O1xufVxudmFyIE1hbmFnZWRTb2NrZXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRlbGVnYXRlcywgZW5hYmxlRGVidWdMb2dnaW5nID0gZmFsc2UsIHdhaXRGb3JBY3RvcklkID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgbWFjaGluZSwgZXZlbnRzLCBjbGVhbnVwcyB9ID0gY3JlYXRlQ29ubmVjdGlvblN0YXRlTWFjaGluZShcbiAgICAgIGRlbGVnYXRlcyxcbiAgICAgIHsgd2FpdEZvckFjdG9ySWQsIGVuYWJsZURlYnVnTG9nZ2luZyB9XG4gICAgKTtcbiAgICB0aGlzLm1hY2hpbmUgPSBtYWNoaW5lO1xuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMuY2xlYW51cHMgPSBjbGVhbnVwcztcbiAgfVxuICBnZXRMZWdhY3lTdGF0dXMoKSB7XG4gICAgcmV0dXJuIG5ld1RvTGVnYWN5U3RhdHVzKHRoaXMuZ2V0U3RhdHVzKCkpO1xuICB9XG4gIGdldFN0YXR1cygpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRvTmV3Q29ubmVjdGlvblN0YXR1cyh0aGlzLm1hY2hpbmUpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIFwiaW5pdGlhbFwiO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBhdXRoIGF1dGhWYWx1ZS5cbiAgICovXG4gIGdldCBhdXRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFjaGluZS5jb250ZXh0LmF1dGhWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCB0byB0cnkgdG8gY29ubmVjdCB0byBhIFdlYlNvY2tldC4gVGhpcyBvbmx5IGhhcyBhbiBlZmZlY3RcbiAgICogaWYgdGhlIG1hY2hpbmUgaXMgaWRsZSBhdCB0aGUgbW9tZW50LCBvdGhlcndpc2UgdGhpcyBpcyBhIG5vLW9wLlxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJZiBpZGxlLCB3aWxsIHRyeSB0byBjb25uZWN0LiBPdGhlcndpc2UsIGl0IHdpbGwgYXR0ZW1wdCB0byByZWNvbm5lY3QgdG9cbiAgICogdGhlIHNvY2tldCwgcG90ZW50aWFsbHkgb2J0YWluaW5nIGEgbmV3IGF1dGhWYWx1ZSBmaXJzdCwgaWYgbmVlZGVkLlxuICAgKi9cbiAgcmVjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJSRUNPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCB0byBkaXNjb25uZWN0IGZyb20gdGhlIGN1cnJlbnQgV2ViU29ja2V0LiBJcyBnb2luZyB0byBiZVxuICAgKiBhIG5vLW9wIGlmIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb25uZWN0aW9uLlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRElTQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgdG8gc3RvcCB0aGUgbWFjaGluZSBhbmQgcnVuIG5lY2Vzc2FyeSBjbGVhbnVwIGZ1bmN0aW9ucy4gQWZ0ZXJcbiAgICogY2FsbGluZyBkZXN0cm95KCksIHlvdSBjYW4gbm8gbG9uZ2VyIHVzZSB0aGlzIGluc3RhbmNlLiBDYWxsIHRoaXMgYmVmb3JlXG4gICAqIGxldHRpbmcgdGhlIGluc3RhbmNlIGdldCBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5tYWNoaW5lLnN0b3AoKTtcbiAgICBsZXQgY2xlYW51cDtcbiAgICB3aGlsZSAoY2xlYW51cCA9IHRoaXMuY2xlYW51cHMucG9wKCkpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNhZmVseSBzZW5kIGEgbWVzc2FnZSB0byB0aGUgY3VycmVudCBXZWJTb2NrZXQgY29ubmVjdGlvbi4gV2lsbCBlbWl0IGEgbG9nXG4gICAqIG1lc3NhZ2UgaWYgdGhpcyBpcyBzb21laG93IGltcG9zc2libGUuXG4gICAqL1xuICBzZW5kKGRhdGEpIHtcbiAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm1hY2hpbmUuY29udGV4dD8uc29ja2V0O1xuICAgIGlmIChzb2NrZXQgPT09IG51bGwpIHtcbiAgICAgIHdhcm4oXCJDYW5ub3Qgc2VuZDogbm90IGNvbm5lY3RlZCB5ZXRcIiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChzb2NrZXQucmVhZHlTdGF0ZSAhPT0gMSkge1xuICAgICAgd2FybihcIkNhbm5vdCBzZW5kOiBXZWJTb2NrZXQgbm8gbG9uZ2VyIG9wZW5cIiwgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvY2tldC5zZW5kKGRhdGEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTk9URTogVXNlZCBieSB0aGUgRTJFIGFwcCBvbmx5LCB0byBzaW11bGF0ZSBleHBsaWNpdCBldmVudHMuXG4gICAqIE5vdCBpZGVhbCB0byBrZWVwIGV4cG9zZWQgOihcbiAgICovXG4gIF9wcml2YXRlU2VuZE1hY2hpbmVFdmVudChldmVudCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKGV2ZW50KTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3RvY29sL0F1dGhUb2tlbi50c1xuZnVuY3Rpb24gY2FuV3JpdGVTdG9yYWdlKHNjb3Blcykge1xuICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbn1cbmZ1bmN0aW9uIGNhbkNvbW1lbnQoc2NvcGVzKSB7XG4gIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czp3cml0ZVwiIC8qIENvbW1lbnRzV3JpdGUgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkQXV0aFRva2VuUGF5bG9hZChkYXRhKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGRhdGEpICYmIChkYXRhLmsgPT09IFwiYWNjXCIgLyogQUNDRVNTX1RPS0VOICovIHx8IGRhdGEuayA9PT0gXCJpZFwiIC8qIElEX1RPS0VOICovIHx8IGRhdGEuayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyk7XG59XG5mdW5jdGlvbiBwYXJzZUF1dGhUb2tlbihyYXdUb2tlblN0cmluZykge1xuICBjb25zdCB0b2tlblBhcnRzID0gcmF3VG9rZW5TdHJpbmcuc3BsaXQoXCIuXCIpO1xuICBpZiAodG9rZW5QYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdXRoZW50aWNhdGlvbiBlcnJvcjogaW52YWxpZCBKV1QgdG9rZW5cIik7XG4gIH1cbiAgY29uc3QgcGF5bG9hZCA9IHRyeVBhcnNlSnNvbihiNjRkZWNvZGUodG9rZW5QYXJ0c1sxXSkpO1xuICBpZiAoIShwYXlsb2FkICYmIGlzVmFsaWRBdXRoVG9rZW5QYXlsb2FkKHBheWxvYWQpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQXV0aGVudGljYXRpb24gZXJyb3I6IGV4cGVjdGVkIGEgdmFsaWQgdG9rZW4gYnV0IGRpZCBub3QgZ2V0IG9uZS4gSGludDogaWYgeW91IGFyZSB1c2luZyBhIGNhbGxiYWNrLCBlbnN1cmUgdGhlIHJvb20gaXMgcGFzc2VkIHdoZW4gY3JlYXRpbmcgdGhlIHRva2VuLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRDYWxsYmFja1wiXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJhdzogcmF3VG9rZW5TdHJpbmcsXG4gICAgcGFyc2VkOiBwYXlsb2FkXG4gIH07XG59XG5cbi8vIHNyYy9hdXRoLW1hbmFnZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUF1dGhNYW5hZ2VyKGF1dGhPcHRpb25zKSB7XG4gIGNvbnN0IGF1dGhlbnRpY2F0aW9uID0gcHJlcGFyZUF1dGhlbnRpY2F0aW9uKGF1dGhPcHRpb25zKTtcbiAgY29uc3Qgc2VlblRva2VucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBjb25zdCBleHBpcnlUaW1lcyA9IFtdO1xuICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBzZWVuVG9rZW5zLmNsZWFyKCk7XG4gICAgdG9rZW5zLmxlbmd0aCA9IDA7XG4gICAgZXhwaXJ5VGltZXMubGVuZ3RoID0gMDtcbiAgICByZXF1ZXN0UHJvbWlzZXMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RlZFNjb3BlLCBzY29wZXMpIHtcbiAgICBpZiAocmVxdWVzdGVkU2NvcGUgPT09IFwiY29tbWVudHM6cmVhZFwiKSB7XG4gICAgICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6cmVhZFwiIC8qIENvbW1lbnRzUmVhZCAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6d3JpdGVcIiAvKiBDb21tZW50c1dyaXRlICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOnJlYWRcIiAvKiBSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdGVkU2NvcGUgPT09IFwicm9vbTpyZWFkXCIpIHtcbiAgICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOnJlYWRcIiAvKiBSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2FjaGVkVG9rZW4ocmVxdWVzdE9wdGlvbnMpIHtcbiAgICBjb25zdCBub3cgPSBNYXRoLmNlaWwoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgZm9yIChsZXQgaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBleHBpcnlUaW1lc1tpXTtcbiAgICAgIGlmIChleHBpcmVzQXQgPD0gbm93KSB7XG4gICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGV4cGlyeVRpbWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4ucGFyc2VkLmsgPT09IFwiaWRcIiAvKiBJRF9UT0tFTiAqLykge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnBhcnNlZC5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLykge1xuICAgICAgICBpZiAoIXJlcXVlc3RPcHRpb25zLnJvb21JZCAmJiBPYmplY3QuZW50cmllcyh0b2tlbi5wYXJzZWQucGVybXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtyZXNvdXJjZSwgc2NvcGVzXSBvZiBPYmplY3QuZW50cmllcyh0b2tlbi5wYXJzZWQucGVybXMpKSB7XG4gICAgICAgICAgaWYgKCFyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZS5pbmNsdWRlcyhcIipcIikgJiYgaGFzQ29ycmVzcG9uZGluZ1Njb3BlcyhyZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0ZWRTY29wZSwgc2NvcGVzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXNvdXJjZS5pbmNsdWRlcyhcIipcIikgJiYgcmVxdWVzdE9wdGlvbnMucm9vbUlkLnN0YXJ0c1dpdGgocmVzb3VyY2UucmVwbGFjZShcIipcIiwgXCJcIikpIHx8IHJlcXVlc3RPcHRpb25zLnJvb21JZCA9PT0gcmVzb3VyY2UgJiYgaGFzQ29ycmVzcG9uZGluZ1Njb3BlcyhyZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0ZWRTY29wZSwgc2NvcGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1ha2VBdXRoUmVxdWVzdChvcHRpb25zKSB7XG4gICAgY29uc3QgZmV0Y2hlciA9IGF1dGhPcHRpb25zLnBvbHlmaWxscz8uZmV0Y2ggPz8gKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyB2b2lkIDAgOiB3aW5kb3cuZmV0Y2gpO1xuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcInByaXZhdGVcIikge1xuICAgICAgaWYgKGZldGNoZXIgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCB3aXRoIGEgdXJsIGFzIGF1dGggZW5kcG9pbnQsIHlvdSBuZWVkIHRvIHByb3ZpZGUgYSBmZXRjaCBwb2x5ZmlsbC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEF1dGhFbmRwb2ludChmZXRjaGVyLCBhdXRoZW50aWNhdGlvbi51cmwsIHtcbiAgICAgICAgcm9vbTogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VBdXRoVG9rZW4ocmVzcG9uc2UudG9rZW4pO1xuICAgICAgdmVyaWZ5VG9rZW5QZXJtaXNzaW9ucyhwYXJzZWQsIG9wdGlvbnMpO1xuICAgICAgaWYgKHNlZW5Ub2tlbnMuaGFzKHBhcnNlZC5yYXcpKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgXCJUaGUgc2FtZSBMaXZlYmxvY2tzIGF1dGggdG9rZW4gd2FzIGlzc3VlZCBmcm9tIHRoZSBiYWNrZW5kIGJlZm9yZS4gQ2FjaGluZyBMaXZlYmxvY2tzIHRva2VucyBpcyBub3Qgc3VwcG9ydGVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiAgICBpZiAoYXV0aGVudGljYXRpb24udHlwZSA9PT0gXCJjdXN0b21cIikge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoZW50aWNhdGlvbi5jYWxsYmFjayhvcHRpb25zLnJvb21JZCk7XG4gICAgICBpZiAocmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UudG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICAgICAgdmVyaWZ5VG9rZW5QZXJtaXNzaW9ucyhwYXJzZWQsIG9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlLmVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgcmVhc29uID0gYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtcInJlYXNvblwiIGluIHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZS5yZWFzb24gPT09IFwic3RyaW5nXCIgPyByZXNwb25zZS5yZWFzb24gOiBcIkZvcmJpZGRlblwifWA7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yID09PSBcImZvcmJpZGRlblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKHJlYXNvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnWW91ciBhdXRoZW50aWNhdGlvbiBjYWxsYmFjayBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgdG9rZW4sIGJ1dCBpdCBkaWQgbm90LiBIaW50OiB0aGUgcmV0dXJuIHZhbHVlIHNob3VsZCBsb29rIGxpa2U6IHsgdG9rZW46IFwiLi4uXCIgfSdcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVW5leHBlY3RlZCBhdXRoZW50aWNhdGlvbiB0eXBlLiBNdXN0IGJlIHByaXZhdGUgb3IgY3VzdG9tLlwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB2ZXJpZnlUb2tlblBlcm1pc3Npb25zKHBhcnNlZFRva2VuLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnJvb21JZCAmJiBwYXJzZWRUb2tlbi5wYXJzZWQuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8pIHtcbiAgICAgIGlmIChPYmplY3QuZW50cmllcyhwYXJzZWRUb2tlbi5wYXJzZWQucGVybXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtyZXNvdXJjZSwgc2NvcGVzXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgICAgcGFyc2VkVG9rZW4ucGFyc2VkLnBlcm1zXG4gICAgICApKSB7XG4gICAgICAgIGlmIChyZXNvdXJjZS5pbmNsdWRlcyhcIipcIikgJiYgaGFzQ29ycmVzcG9uZGluZ1Njb3BlcyhvcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKFxuICAgICAgICBcIlRoZSBpc3N1ZWQgYWNjZXNzIHRva2VuIGRvZXNuJ3QgZ3JhbnQgZW5vdWdoIHBlcm1pc3Npb25zLiBQbGVhc2UgZm9sbG93IHRoZSBpbnN0cnVjdGlvbnMgYXQgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2xpdmVibG9ja3MtY2xpZW50L2FjY2Vzcy10b2tlbnMtbm90LWVub3VnaC1wZXJtaXNzaW9uc1wiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRBdXRoVmFsdWUocmVxdWVzdE9wdGlvbnMpIHtcbiAgICBpZiAoYXV0aGVudGljYXRpb24udHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJwdWJsaWNcIiwgcHVibGljQXBpS2V5OiBhdXRoZW50aWNhdGlvbi5wdWJsaWNBcGlLZXkgfTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVkVG9rZW4gPSBnZXRDYWNoZWRUb2tlbihyZXF1ZXN0T3B0aW9ucyk7XG4gICAgaWYgKGNhY2hlZFRva2VuICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwic2VjcmV0XCIsIHRva2VuOiBjYWNoZWRUb2tlbiB9O1xuICAgIH1cbiAgICBsZXQgY3VycmVudFByb21pc2U7XG4gICAgaWYgKHJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgY3VycmVudFByb21pc2UgPSByZXF1ZXN0UHJvbWlzZXMuZ2V0KHJlcXVlc3RPcHRpb25zLnJvb21JZCk7XG4gICAgICBpZiAoY3VycmVudFByb21pc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBjdXJyZW50UHJvbWlzZSA9IG1ha2VBdXRoUmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5zZXQocmVxdWVzdE9wdGlvbnMucm9vbUlkLCBjdXJyZW50UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVxdWVzdFByb21pc2VzLmdldChcImxpdmVibG9ja3MtdXNlci10b2tlblwiKTtcbiAgICAgIGlmIChjdXJyZW50UHJvbWlzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGN1cnJlbnRQcm9taXNlID0gbWFrZUF1dGhSZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLnNldChcImxpdmVibG9ja3MtdXNlci10b2tlblwiLCBjdXJyZW50UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGN1cnJlbnRQcm9taXNlO1xuICAgICAgY29uc3QgQlVGRkVSID0gMzA7XG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpICsgKHRva2VuLnBhcnNlZC5leHAgLSB0b2tlbi5wYXJzZWQuaWF0KSAtIEJVRkZFUjtcbiAgICAgIHNlZW5Ub2tlbnMuYWRkKHRva2VuLnJhdyk7XG4gICAgICBpZiAodG9rZW4ucGFyc2VkLmsgIT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8pIHtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBleHBpcnlUaW1lcy5wdXNoKGV4cGlyZXNBdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlOiBcInNlY3JldFwiLCB0b2tlbiB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAocmVxdWVzdE9wdGlvbnMucm9vbUlkKSB7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5kZWxldGUocmVxdWVzdE9wdGlvbnMucm9vbUlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5kZWxldGUoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcmVzZXQsXG4gICAgZ2V0QXV0aFZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlQXV0aGVudGljYXRpb24oYXV0aE9wdGlvbnMpIHtcbiAgY29uc3QgeyBwdWJsaWNBcGlLZXksIGF1dGhFbmRwb2ludCB9ID0gYXV0aE9wdGlvbnM7XG4gIGlmIChhdXRoRW5kcG9pbnQgIT09IHZvaWQgMCAmJiBwdWJsaWNBcGlLZXkgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbm5vdCBzaW11bHRhbmVvdXNseSB1c2UgYHB1YmxpY0FwaUtleWAgYW5kIGBhdXRoRW5kcG9pbnRgIG9wdGlvbnMuIFBsZWFzZSBwaWNrIG9uZSBhbmQgbGVhdmUgdGhlIG90aGVyIG9wdGlvbiB1bnNwZWNpZmllZC4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50XCJcbiAgICApO1xuICB9XG4gIGlmICh0eXBlb2YgcHVibGljQXBpS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHB1YmxpY0FwaUtleS5zdGFydHNXaXRoKFwic2tfXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBgcHVibGljQXBpS2V5YCBvcHRpb24uIFRoZSB2YWx1ZSB5b3UgcGFzc2VkIGlzIGEgc2VjcmV0IGtleSwgd2hpY2ggc2hvdWxkIG5vdCBiZSB1c2VkIGZyb20gdGhlIGNsaWVudC4gUGxlYXNlIG9ubHkgZXZlciBwYXNzIGEgcHVibGljIGtleSBoZXJlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRQdWJsaWNLZXlcIlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFwdWJsaWNBcGlLZXkuc3RhcnRzV2l0aChcInBrX1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQga2V5LiBQbGVhc2UgdXNlIHRoZSBwdWJsaWMga2V5IGZvcm1hdDogcGtfPHB1YmxpYyBrZXk+LiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRQdWJsaWNLZXlcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicHVibGljXCIsXG4gICAgICBwdWJsaWNBcGlLZXlcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgYXV0aEVuZHBvaW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicHJpdmF0ZVwiLFxuICAgICAgdXJsOiBhdXRoRW5kcG9pbnRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhdXRoRW5kcG9pbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgICAgY2FsbGJhY2s6IGF1dGhFbmRwb2ludFxuICAgIH07XG4gIH0gZWxzZSBpZiAoYXV0aEVuZHBvaW50ICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBgYXV0aEVuZHBvaW50YCBvcHRpb24gbXVzdCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRBdXRoRW5kcG9pbnRcIlxuICAgICk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIFwiSW52YWxpZCBMaXZlYmxvY2tzIGNsaWVudCBvcHRpb25zLiBQbGVhc2UgcHJvdmlkZSBlaXRoZXIgYSBgcHVibGljQXBpS2V5YCBvciBgYXV0aEVuZHBvaW50YCBvcHRpb24uIFRoZXkgY2Fubm90IGJvdGggYmUgZW1wdHkuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFwiXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEF1dGhFbmRwb2ludChmZXRjaDIsIGVuZHBvaW50LCBib2R5KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoMihlbmRwb2ludCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9LFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gIH0pO1xuICBpZiAoIXJlcy5vaykge1xuICAgIGNvbnN0IHJlYXNvbiA9IGAkeyhhd2FpdCByZXMudGV4dCgpKS50cmltKCkgfHwgXCJyZWFzb24gbm90IHByb3ZpZGVkIGluIGF1dGggcmVzcG9uc2VcIn0gKCR7cmVzLnN0YXR1c30gcmV0dXJuZWQgYnkgUE9TVCAke2VuZHBvaW50fSlgO1xuICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEgfHwgcmVzLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcFJldHJ5aW5nKGBVbmF1dGhvcml6ZWQ6ICR7cmVhc29ufWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhdXRoZW50aWNhdGU6ICR7cmVhc29ufWApO1xuICAgIH1cbiAgfVxuICBsZXQgZGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBKU09OIHJlc3BvbnNlIHdoZW4gZG9pbmcgYSBQT1NUIHJlcXVlc3Qgb24gXCIke2VuZHBvaW50fVwiLiAke1N0cmluZyhcbiAgICAgICAgZXJcbiAgICAgICl9YFxuICAgICk7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpIHx8IHR5cGVvZiBkYXRhLnRva2VuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGEgSlNPTiByZXNwb25zZSBvZiB0aGUgZm9ybSBcXGB7IHRva2VuOiBcIi4uLlwiIH1cXGAgd2hlbiBkb2luZyBhIFBPU1QgcmVxdWVzdCBvbiBcIiR7ZW5kcG9pbnR9XCIsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgZGF0YVxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBjb25zdCB7IHRva2VuIH0gPSBkYXRhO1xuICByZXR1cm4geyB0b2tlbiB9O1xufVxuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgREVGQVVMVF9CQVNFX1VSTCA9IFwiaHR0cHM6Ly9hcGkubGl2ZWJsb2Nrcy5pb1wiO1xuXG4vLyBzcmMvaW50ZXJuYWwudHNcbnZhciBrSW50ZXJuYWwgPSBTeW1ib2woKTtcblxuLy8gc3JjL2RldnRvb2xzL2JyaWRnZS50c1xudmFyIF9icmlkZ2VBY3RpdmUgPSBmYWxzZTtcbmZ1bmN0aW9uIGFjdGl2YXRlQnJpZGdlKGFsbG93ZWQpIHtcbiAgX2JyaWRnZUFjdGl2ZSA9IGFsbG93ZWQ7XG59XG5mdW5jdGlvbiBzZW5kVG9QYW5lbChtZXNzYWdlLCBvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmdWxsTXNnID0ge1xuICAgIC4uLm1lc3NhZ2UsXG4gICAgc291cmNlOiBcImxpdmVibG9ja3MtZGV2dG9vbHMtY2xpZW50XCJcbiAgfTtcbiAgaWYgKCEob3B0aW9ucz8uZm9yY2UgfHwgX2JyaWRnZUFjdGl2ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LnBvc3RNZXNzYWdlKGZ1bGxNc2csIFwiKlwiKTtcbn1cbnZhciBldmVudFNvdXJjZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQuc291cmNlID09PSB3aW5kb3cgJiYgZXZlbnQuZGF0YT8uc291cmNlID09PSBcImxpdmVibG9ja3MtZGV2dG9vbHMtcGFuZWxcIikge1xuICAgICAgZXZlbnRTb3VyY2Uubm90aWZ5KGV2ZW50LmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgfVxuICB9KTtcbn1cbnZhciBvbk1lc3NhZ2VGcm9tUGFuZWwgPSBldmVudFNvdXJjZS5vYnNlcnZhYmxlO1xuXG4vLyBzcmMvZGV2dG9vbHMvaW5kZXgudHNcbnZhciBWRVJTSU9OID0gUEtHX1ZFUlNJT04gfHwgXCJkZXZcIjtcbnZhciBfZGV2dG9vbHNTZXR1cEhhc1J1biA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBEZXZUb29scyhnZXRBbGxSb29tcykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKF9kZXZ0b29sc1NldHVwSGFzUnVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIF9kZXZ0b29sc1NldHVwSGFzUnVuID0gdHJ1ZTtcbiAgb25NZXNzYWdlRnJvbVBhbmVsLnN1YnNjcmliZSgobXNnKSA9PiB7XG4gICAgc3dpdGNoIChtc2cubXNnKSB7XG4gICAgICBjYXNlIFwiY29ubmVjdFwiOiB7XG4gICAgICAgIGFjdGl2YXRlQnJpZGdlKHRydWUpO1xuICAgICAgICBmb3IgKGNvbnN0IHJvb21JZCBvZiBnZXRBbGxSb29tcygpKSB7XG4gICAgICAgICAgc2VuZFRvUGFuZWwoe1xuICAgICAgICAgICAgbXNnOiBcInJvb206OmF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgY2xpZW50VmVyc2lvbjogVkVSU0lPTlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHNlbmRUb1BhbmVsKHsgbXNnOiBcIndha2UtdXAtZGV2dG9vbHNcIiB9LCB7IGZvcmNlOiB0cnVlIH0pO1xufVxudmFyIHVuc3Vic0J5Um9vbUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHN0b3BTeW5jU3RyZWFtKHJvb21JZCkge1xuICBjb25zdCB1bnN1YnMgPSB1bnN1YnNCeVJvb21JZC5nZXQocm9vbUlkKSA/PyBbXTtcbiAgdW5zdWJzQnlSb29tSWQuZGVsZXRlKHJvb21JZCk7XG4gIGZvciAoY29uc3QgdW5zdWIgb2YgdW5zdWJzKSB7XG4gICAgdW5zdWIoKTtcbiAgfVxufVxuZnVuY3Rpb24gc3RhcnRTeW5jU3RyZWFtKHJvb20pIHtcbiAgc3RvcFN5bmNTdHJlYW0ocm9vbS5pZCk7XG4gIGZ1bGxTeW5jKHJvb20pO1xuICB1bnN1YnNCeVJvb21JZC5zZXQocm9vbS5pZCwgW1xuICAgIC8vIFdoZW4gdGhlIGNvbm5lY3Rpb24gc3RhdHVzIGNoYW5nZXNcbiAgICByb29tLmV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jQ29ubmVjdGlvbihyb29tKSksXG4gICAgLy8gV2hlbiBzdG9yYWdlIGluaXRpYWxpemVzLCBzZW5kIHRoZSB1cGRhdGVcbiAgICByb29tLmV2ZW50cy5zdG9yYWdlRGlkTG9hZC5zdWJzY3JpYmVPbmNlKCgpID0+IHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSksXG4gICAgLy8gQW55IHRpbWUgc3RvcmFnZSB1cGRhdGVzLCBzZW5kIHRoZSBuZXcgc3RvcmFnZSByb290XG4gICAgcm9vbS5ldmVudHMuc3RvcmFnZS5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSBcIm1lXCIgb3IgXCJvdGhlcnNcIiB1cGRhdGVzLCBzZW5kIHRoZSBuZXcgdmFsdWVzIGFjY29yZGluZ2x5XG4gICAgcm9vbS5ldmVudHMuc2VsZi5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNNZShyb29tKSksXG4gICAgcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY090aGVycyhyb29tKSksXG4gICAgLy8gQW55IHRpbWUgeWRvYyBpcyB1cGRhdGVkLCBmb3J3YXJkIHRoZSB1cGRhdGVcbiAgICByb29tLmV2ZW50cy55ZG9jLnN1YnNjcmliZSgodXBkYXRlKSA9PiBzeW5jWWRvY1VwZGF0ZShyb29tLCB1cGRhdGUpKSxcbiAgICAvLyBBbnkgdGltZSBhIGN1c3RvbSByb29tIGV2ZW50IGlzIHJlY2VpdmVkLCBmb3J3YXJkIGl0XG4gICAgcm9vbS5ldmVudHMuY3VzdG9tRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgKGV2ZW50RGF0YSkgPT4gZm9yd2FyZEV2ZW50KHJvb20sIGV2ZW50RGF0YSlcbiAgICApXG4gIF0pO1xufVxuZnVuY3Rpb24gc3luY1lkb2NVcGRhdGUocm9vbSwgdXBkYXRlKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6eWRvY1wiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICB1cGRhdGVcbiAgfSk7XG59XG52YXIgbG9hZGVkQXQgPSBEYXRlLm5vdygpO1xudmFyIGV2ZW50Q291bnRlciA9IDA7XG5mdW5jdGlvbiBuZXh0RXZlbnRJZCgpIHtcbiAgcmV0dXJuIGBldmVudC0ke2xvYWRlZEF0fS0ke2V2ZW50Q291bnRlcisrfWA7XG59XG5mdW5jdGlvbiBmb3J3YXJkRXZlbnQocm9vbSwgZXZlbnREYXRhKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6ZXZlbnRzOjpjdXN0b20tZXZlbnRcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgZXZlbnQ6IHtcbiAgICAgIHR5cGU6IFwiQ3VzdG9tRXZlbnRcIixcbiAgICAgIGlkOiBuZXh0RXZlbnRJZCgpLFxuICAgICAga2V5OiBcIkV2ZW50XCIsXG4gICAgICBjb25uZWN0aW9uSWQ6IGV2ZW50RGF0YS5jb25uZWN0aW9uSWQsXG4gICAgICBwYXlsb2FkOiBldmVudERhdGEuZXZlbnRcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNDb25uZWN0aW9uKHJvb20pIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHN0YXR1czogcm9vbS5nZXRTdGF0dXMoKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSB7XG4gIGNvbnN0IHJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICBpZiAocm9vdCkge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBzdG9yYWdlOiByb290LnRvVHJlZU5vZGUoXCJyb290XCIpLnBheWxvYWRcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNNZShyb29tKSB7XG4gIGNvbnN0IG1lID0gcm9vbVtrSW50ZXJuYWxdLmdldFNlbGZfZm9yRGV2VG9vbHMoKTtcbiAgaWYgKG1lKSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIG1lXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jT3RoZXJzKHJvb20pIHtcbiAgY29uc3Qgb3RoZXJzID0gcm9vbVtrSW50ZXJuYWxdLmdldE90aGVyc19mb3JEZXZUb29scygpO1xuICBpZiAob3RoZXJzKSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIG90aGVyc1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBmdWxsU3luYyhyb29tKSB7XG4gIGNvbnN0IHJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICBjb25zdCBtZSA9IHJvb21ba0ludGVybmFsXS5nZXRTZWxmX2ZvckRldlRvb2xzKCk7XG4gIGNvbnN0IG90aGVycyA9IHJvb21ba0ludGVybmFsXS5nZXRPdGhlcnNfZm9yRGV2VG9vbHMoKTtcbiAgcm9vbS5mZXRjaFlEb2MoXCJcIik7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6ZnVsbFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBzdGF0dXM6IHJvb20uZ2V0U3RhdHVzKCksXG4gICAgc3RvcmFnZTogcm9vdD8udG9UcmVlTm9kZShcInJvb3RcIikucGF5bG9hZCA/PyBudWxsLFxuICAgIG1lLFxuICAgIG90aGVyc1xuICB9KTtcbn1cbnZhciByb29tQ2hhbm5lbExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpIHtcbiAgY29uc3QgbGlzdGVuZXIgPSByb29tQ2hhbm5lbExpc3RlbmVycy5nZXQocm9vbUlkKTtcbiAgcm9vbUNoYW5uZWxMaXN0ZW5lcnMuZGVsZXRlKHJvb21JZCk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpbmtEZXZUb29scyhyb29tSWQsIHJvb20pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlbmRUb1BhbmVsKHsgbXNnOiBcInJvb206OmF2YWlsYWJsZVwiLCByb29tSWQsIGNsaWVudFZlcnNpb246IFZFUlNJT04gfSk7XG4gIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCk7XG4gIHJvb21DaGFubmVsTGlzdGVuZXJzLnNldChcbiAgICByb29tSWQsXG4gICAgLy8gUmV0dXJucyB0aGUgdW5zdWJzY3JpYmUgY2FsbGJhY2ssIHRoYXQgd2Ugc3RvcmUgaW4gdGhlXG4gICAgLy8gcm9vbUNoYW5uZWxMaXN0ZW5lcnMgcmVnaXN0cnlcbiAgICBvbk1lc3NhZ2VGcm9tUGFuZWwuc3Vic2NyaWJlKChtc2cpID0+IHtcbiAgICAgIHN3aXRjaCAobXNnLm1zZykge1xuICAgICAgICBjYXNlIFwicm9vbTo6c3Vic2NyaWJlXCI6IHtcbiAgICAgICAgICBpZiAobXNnLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICAgICAgICBzdGFydFN5bmNTdHJlYW0ocm9vbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyb29tOjp1bnN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgaWYgKG1zZy5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgICAgICAgc3RvcFN5bmNTdHJlYW0ocm9vbUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gdW5saW5rRGV2VG9vbHMocm9vbUlkKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBzdG9wU3luY1N0cmVhbShyb29tSWQpO1xuICBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpO1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnVuYXZhaWxhYmxlXCIsXG4gICAgcm9vbUlkXG4gIH0pO1xufVxuXG4vLyBzcmMvbGliL3N0cmluZ2lmeS50c1xuZnVuY3Rpb24gc3RyaW5naWZ5KG9iamVjdCwgLi4uYXJncykge1xuICBpZiAodHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIiB8fCBvYmplY3QgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iamVjdCwgLi4uYXJncyk7XG4gIH1cbiAgY29uc3Qgc29ydGVkT2JqZWN0ID0gT2JqZWN0LmtleXMob2JqZWN0KS5zb3J0KCkucmVkdWNlKFxuICAgIChzb3J0ZWRPYmplY3QyLCBrZXkpID0+IHtcbiAgICAgIHNvcnRlZE9iamVjdDJba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgcmV0dXJuIHNvcnRlZE9iamVjdDI7XG4gICAgfSxcbiAgICB7fVxuICApO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc29ydGVkT2JqZWN0LCAuLi5hcmdzKTtcbn1cblxuLy8gc3JjL2xpYi9iYXRjaC50c1xudmFyIERFRkFVTFRfU0laRSA9IDUwO1xudmFyIERFRkFVTFRfREVMQVkgPSAxMDA7XG52YXIgbm9vcCA9ICgpID0+IHtcbn07XG52YXIgQmF0Y2hDYWxsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5yZXNvbHZlID0gbm9vcDtcbiAgICB0aGlzLnJlamVjdCA9IG5vb3A7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2Uobm9vcCk7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxufTtcbnZhciBCYXRjaCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnNpemUgPSBvcHRpb25zPy5zaXplID8/IERFRkFVTFRfU0laRTtcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucz8uZGVsYXkgPz8gREVGQVVMVF9ERUxBWTtcbiAgfVxuICBjbGVhckRlbGF5VGltZW91dCgpIHtcbiAgICBpZiAodGhpcy5kZWxheVRpbWVvdXRJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVvdXRJZCk7XG4gICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBzY2hlZHVsZSgpIHtcbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IHRoaXMuc2l6ZSkge1xuICAgICAgdm9pZCB0aGlzLmZsdXNoKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5jbGVhckRlbGF5VGltZW91dCgpO1xuICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gdm9pZCB0aGlzLmZsdXNoKCksIHRoaXMuZGVsYXkpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmbHVzaCgpIHtcbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FsbHMgPSB0aGlzLnF1ZXVlLnNwbGljZSgwKTtcbiAgICBjb25zdCBhcmdzID0gY2FsbHMubWFwKChjYWxsKSA9PiBjYWxsLmFyZ3MpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5jYWxsYmFjayhhcmdzKTtcbiAgICAgIHRoaXMuZXJyb3IgPSBmYWxzZTtcbiAgICAgIGNhbGxzLmZvckVhY2goKGNhbGwsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHM/LltpbmRleF07XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGNhbGwucmVqZWN0KHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjYWxsLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICAgICAgY2FsbC5yZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgQmF0Y2ggY2FsbGJhY2sgbXVzdCByZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBudW1iZXIgb2YgY2FsbHMgaW4gdGhlIGJhdGNoLiBFeHBlY3RlZCAke2NhbGxzLmxlbmd0aH0sIGJ1dCBnb3QgJHtyZXN1bHRzLmxlbmd0aH0uYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsLnJlamVjdChuZXcgRXJyb3IoXCJCYXRjaCBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheS5cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IzKSB7XG4gICAgICB0aGlzLmVycm9yID0gdHJ1ZTtcbiAgICAgIGNhbGxzLmZvckVhY2goKGNhbGwpID0+IHtcbiAgICAgICAgY2FsbC5yZWplY3QoZXJyb3IzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQoLi4uYXJncykge1xuICAgIGNvbnN0IGV4aXN0aW5nQ2FsbCA9IHRoaXMucXVldWUuZmluZChcbiAgICAgIChjYWxsMikgPT4gc3RyaW5naWZ5KGNhbGwyLmFyZ3MpID09PSBzdHJpbmdpZnkoYXJncylcbiAgICApO1xuICAgIGlmIChleGlzdGluZ0NhbGwpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0NhbGwucHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgY2FsbCA9IG5ldyBCYXRjaENhbGwoYXJncyk7XG4gICAgY2FsbC5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY2FsbC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIGNhbGwucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHRoaXMucXVldWUucHVzaChjYWxsKTtcbiAgICB0aGlzLnNjaGVkdWxlKCk7XG4gICAgcmV0dXJuIGNhbGwucHJvbWlzZTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJEZWxheVRpbWVvdXQoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoU3RvcmUoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgY29uc3QgYmF0Y2ggPSBuZXcgQmF0Y2goY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGV2ZW50U291cmNlMiA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBnZXRDYWNoZUtleShhcmdzKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShhcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRTdGF0ZUFuZE5vdGlmeShjYWNoZUtleSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZS5kZWxldGUoY2FjaGVLZXkpO1xuICAgIH1cbiAgICBldmVudFNvdXJjZTIubm90aWZ5KHN0YXRlKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXQoLi4uYXJncykge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoYXJncyk7XG4gICAgaWYgKGNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHNldFN0YXRlQW5kTm90aWZ5KGNhY2hlS2V5LCB7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhdGNoLmdldCguLi5hcmdzKTtcbiAgICAgIHNldFN0YXRlQW5kTm90aWZ5KGNhY2hlS2V5LCB7IGlzTG9hZGluZzogZmFsc2UsIGRhdGE6IHJlc3VsdCB9KTtcbiAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgIHNldFN0YXRlQW5kTm90aWZ5KGNhY2hlS2V5LCB7XG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvcjNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTdGF0ZSguLi5hcmdzKSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShhcmdzKTtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmV2ZW50U291cmNlMixcbiAgICBnZXQsXG4gICAgZ2V0U3RhdGVcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9jcmVhdGUtc3RvcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKGluaXRpYWxTdGF0ZSkge1xuICBsZXQgc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBzZXQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IGNhbGxiYWNrKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUgPT09IG5ld1N0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXRlID0gbmV3U3RhdGU7XG4gICAgZm9yIChjb25zdCBzdWJzY3JpYmVyIG9mIHN1YnNjcmliZXJzKSB7XG4gICAgICBzdWJzY3JpYmVyKHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgc3Vic2NyaWJlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICBjYWxsYmFjayhzdGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCxcbiAgICBzZXQsXG4gICAgc3Vic2NyaWJlXG4gIH07XG59XG5cbi8vIHNyYy9saWIvZGVwcmVjYXRpb24udHNcbnZhciBfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuZnVuY3Rpb24gZGVwcmVjYXRlKG1lc3NhZ2UsIGtleSA9IG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzLmhhcyhrZXkpKSB7XG4gICAgICBfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MuYWRkKGtleSk7XG4gICAgICBlcnJvcldpdGhUaXRsZShcIkRlcHJlY2F0aW9uIHdhcm5pbmdcIiwgbWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXByZWNhdGVJZihjb25kaXRpb24sIG1lc3NhZ2UsIGtleSA9IG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIGRlcHJlY2F0ZShtZXNzYWdlLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGhyb3dVc2FnZUVycm9yKG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IHVzYWdlRXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgdXNhZ2VFcnJvci5uYW1lID0gXCJVc2FnZSBlcnJvclwiO1xuICAgIGVycm9yV2l0aFRpdGxlKFwiVXNhZ2UgZXJyb3JcIiwgbWVzc2FnZSk7XG4gICAgdGhyb3cgdXNhZ2VFcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JJZihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHRocm93VXNhZ2VFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2NvbnZlcnQtcGxhaW4tZGF0YS50c1xuZnVuY3Rpb24gY29udmVydFRvQ29tbWVudERhdGEoZGF0YSkge1xuICBjb25zdCBlZGl0ZWRBdCA9IGRhdGEuZWRpdGVkQXQgPyBuZXcgRGF0ZShkYXRhLmVkaXRlZEF0KSA6IHZvaWQgMDtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCByZWFjdGlvbnMgPSBkYXRhLnJlYWN0aW9ucy5tYXAoKHJlYWN0aW9uKSA9PiAoe1xuICAgIC4uLnJlYWN0aW9uLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUocmVhY3Rpb24uY3JlYXRlZEF0KVxuICB9KSk7XG4gIGlmIChkYXRhLmJvZHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIHJlYWN0aW9ucyxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGVkaXRlZEF0XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkZWxldGVkQXQgPSBuZXcgRGF0ZShkYXRhLmRlbGV0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdCxcbiAgICAgIGRlbGV0ZWRBdFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1RocmVhZERhdGEoZGF0YSkge1xuICBjb25zdCB1cGRhdGVkQXQgPSBkYXRhLnVwZGF0ZWRBdCA/IG5ldyBEYXRlKGRhdGEudXBkYXRlZEF0KSA6IHZvaWQgMDtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCBjb21tZW50cyA9IGRhdGEuY29tbWVudHMubWFwKFxuICAgIChjb21tZW50KSA9PiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KVxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgY3JlYXRlZEF0LFxuICAgIHVwZGF0ZWRBdCxcbiAgICBjb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbihkYXRhKSB7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KVxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKGRhdGEpIHtcbiAgY29uc3Qgbm90aWZpZWRBdCA9IG5ldyBEYXRlKGRhdGEubm90aWZpZWRBdCk7XG4gIGNvbnN0IHJlYWRBdCA9IGRhdGEucmVhZEF0ID8gbmV3IERhdGUoZGF0YS5yZWFkQXQpIDogbnVsbDtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIG5vdGlmaWVkQXQsXG4gICAgcmVhZEF0XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREZWxldGVJbmZvKGRhdGEpIHtcbiAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgZGVsZXRlZEF0XG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm8oZGF0YSkge1xuICBjb25zdCBkZWxldGVkQXQgPSBuZXcgRGF0ZShkYXRhLmRlbGV0ZWRBdCk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBkZWxldGVkQXRcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi91cmwudHNcbmZ1bmN0aW9uIHRvVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXJsam9pbihiYXNlVXJsLCBwYXRoLCBwYXJhbXMpIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVXJsKTtcbiAgaWYgKHBhcmFtcyAhPT0gdm9pZCAwKSB7XG4gICAgdXJsLnNlYXJjaCA9IChwYXJhbXMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBwYXJhbXMgOiB0b1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cblxuLy8gc3JjL25vdGlmaWNhdGlvbnMudHNcbnZhciBNQVJLX0lOQk9YX05PVElGSUNBVElPTlNfQVNfUkVBRF9CQVRDSF9ERUxBWSA9IDUwO1xuZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uc0FwaSh7XG4gIGJhc2VVcmwsXG4gIGF1dGhNYW5hZ2VyLFxuICBjdXJyZW50VXNlcklkU3RvcmUsXG4gIGZldGNoZXJcbn0pIHtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hKc29uKGVuZHBvaW50LCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiXG4gICAgfSk7XG4gICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiICYmIGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8pIHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQudWlkO1xuICAgICAgY3VycmVudFVzZXJJZFN0b3JlLnNldCgoKSA9PiB1c2VySWQpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSB1cmxqb2luKGJhc2VVcmwsIGAvdjIvYyR7ZW5kcG9pbnR9YCwgcGFyYW1zKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoZXIodXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtnZXRBdXRoQmVhcmVySGVhZGVyRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpfWBcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgbGV0IGVycm9yMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIGVycm9yQm9keS5tZXNzYWdlLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3JCb2R5XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEluYm94Tm90aWZpY2F0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGZldGNoSnNvbihcIi9pbmJveC1ub3RpZmljYXRpb25zXCIsIHZvaWQgMCwge1xuICAgICAgbGltaXQ6IG9wdGlvbnM/LmxpbWl0LFxuICAgICAgc2luY2U6IG9wdGlvbnM/LnNpbmNlPy50b0lTT1N0cmluZygpXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRocmVhZHM6IGpzb24udGhyZWFkcy5tYXAoKHRocmVhZCkgPT4gY29udmVydFRvVGhyZWFkRGF0YSh0aHJlYWQpKSxcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAobm90aWZpY2F0aW9uKSA9PiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEobm90aWZpY2F0aW9uKVxuICAgICAgKSxcbiAgICAgIGRlbGV0ZWRUaHJlYWRzOiBqc29uLmRlbGV0ZWRUaHJlYWRzLm1hcChcbiAgICAgICAgKGluZm8pID0+IGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8oaW5mbylcbiAgICAgICksXG4gICAgICBkZWxldGVkSW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAoaW5mbykgPT4gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvKGluZm8pXG4gICAgICApLFxuICAgICAgbWV0YToge1xuICAgICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoKSB7XG4gICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnMvY291bnRcIik7XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoKSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaW5ib3hOb3RpZmljYXRpb25JZHM6IFwiYWxsXCIgfSlcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaW5ib3hOb3RpZmljYXRpb25JZHMgfSlcbiAgICB9KTtcbiAgfVxuICBjb25zdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZCA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzKSA9PiB7XG4gICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbklkcyA9IGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcy5mbGF0KCk7XG4gICAgICBhd2FpdCBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKTtcbiAgICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbklkcztcbiAgICB9LFxuICAgIHsgZGVsYXk6IE1BUktfSU5CT1hfTk9USUZJQ0FUSU9OU19BU19SRUFEX0JBVENIX0RFTEFZIH1cbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBhd2FpdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZC5nZXQoaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9wb3NpdGlvbi50c1xudmFyIE1JTl9DT0RFID0gMzI7XG52YXIgTUFYX0NPREUgPSAxMjY7XG52YXIgTlVNX0RJR0lUUyA9IE1BWF9DT0RFIC0gTUlOX0NPREUgKyAxO1xudmFyIFpFUk8gPSBudGhEaWdpdCgwKTtcbnZhciBPTkUgPSBudGhEaWdpdCgxKTtcbnZhciBaRVJPX05JTkUgPSBaRVJPICsgbnRoRGlnaXQoLTEpO1xuZnVuY3Rpb24gbnRoRGlnaXQobikge1xuICBjb25zdCBjb2RlID0gTUlOX0NPREUgKyAobiA8IDAgPyBOVU1fRElHSVRTICsgbiA6IG4pO1xuICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuIHZhbHVlOiAke259YCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59XG5mdW5jdGlvbiBtYWtlUG9zaXRpb24oeCwgeSkge1xuICBpZiAoeCAhPT0gdm9pZCAwICYmIHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZXR3ZWVuKHgsIHkpO1xuICB9IGVsc2UgaWYgKHggIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBhZnRlcih4KTtcbiAgfSBlbHNlIGlmICh5ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYmVmb3JlKHkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPTkU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJlZm9yZShwb3MpIHtcbiAgY29uc3QgbGFzdEluZGV4ID0gcG9zLmxlbmd0aCAtIDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDw9IE1JTl9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkgPT09IGxhc3RJbmRleCkge1xuICAgICAgaWYgKGNvZGUgPT09IE1JTl9DT0RFICsgMSkge1xuICAgICAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFpFUk9fTklORTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkgKyAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9ORTtcbn1cbmZ1bmN0aW9uIGFmdGVyKHBvcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBwb3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID49IE1BWF9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAxKTtcbiAgfVxuICByZXR1cm4gcG9zICsgT05FO1xufVxuZnVuY3Rpb24gYmV0d2VlbihsbywgaGkpIHtcbiAgaWYgKGxvIDwgaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4obG8sIGhpKTtcbiAgfSBlbHNlIGlmIChsbyA+IGhpKSB7XG4gICAgcmV0dXJuIF9iZXR3ZWVuKGhpLCBsbyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgdmFsdWUgYmV0d2VlbiB0d28gZXF1YWwgcG9zaXRpb25zXCIpO1xuICB9XG59XG5mdW5jdGlvbiBfYmV0d2VlbihsbywgaGkpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3QgbG9MZW4gPSBsby5sZW5ndGg7XG4gIGNvbnN0IGhpTGVuID0gaGkubGVuZ3RoO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGxvQ29kZSA9IGluZGV4IDwgbG9MZW4gPyBsby5jaGFyQ29kZUF0KGluZGV4KSA6IE1JTl9DT0RFO1xuICAgIGNvbnN0IGhpQ29kZSA9IGluZGV4IDwgaGlMZW4gPyBoaS5jaGFyQ29kZUF0KGluZGV4KSA6IE1BWF9DT0RFO1xuICAgIGlmIChsb0NvZGUgPT09IGhpQ29kZSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaGlDb2RlIC0gbG9Db2RlID09PSAxKSB7XG4gICAgICBjb25zdCBzaXplID0gaW5kZXggKyAxO1xuICAgICAgbGV0IHByZWZpeCA9IGxvLnN1YnN0cmluZygwLCBzaXplKTtcbiAgICAgIGlmIChwcmVmaXgubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICBwcmVmaXggKz0gWkVSTy5yZXBlYXQoc2l6ZSAtIHByZWZpeC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VmZml4ID0gbG8uc3Vic3RyaW5nKHNpemUpO1xuICAgICAgY29uc3QgbmluZXMgPSBcIlwiO1xuICAgICAgcmV0dXJuIHByZWZpeCArIF9iZXR3ZWVuKHN1ZmZpeCwgbmluZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGFrZU4obG8sIGluZGV4KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlDb2RlICsgbG9Db2RlID4+IDEpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGFrZU4ocG9zLCBuKSB7XG4gIHJldHVybiBuIDwgcG9zLmxlbmd0aCA/IHBvcy5zdWJzdHJpbmcoMCwgbikgOiBwb3MgKyBaRVJPLnJlcGVhdChuIC0gcG9zLmxlbmd0aCk7XG59XG52YXIgTUlOX05PTl9aRVJPX0NPREUgPSBNSU5fQ09ERSArIDE7XG5mdW5jdGlvbiBpc1BvcyhzdHIpIHtcbiAgaWYgKHN0ciA9PT0gXCJcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0SWR4ID0gc3RyLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGxhc3QgPSBzdHIuY2hhckNvZGVBdChsYXN0SWR4KTtcbiAgaWYgKGxhc3QgPCBNSU5fTk9OX1pFUk9fQ09ERSB8fCBsYXN0ID4gTUFYX0NPREUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SWR4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCBNSU5fQ09ERSB8fCBjb2RlID4gTUFYX0NPREUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Qb3Moc3RyKSB7XG4gIGNvbnN0IGNvZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGNvZGVzLnB1c2goY29kZSA8IE1JTl9DT0RFID8gTUlOX0NPREUgOiBjb2RlID4gTUFYX0NPREUgPyBNQVhfQ09ERSA6IGNvZGUpO1xuICB9XG4gIHdoaWxlIChjb2Rlcy5sZW5ndGggPiAwICYmIGNvZGVzW2NvZGVzLmxlbmd0aCAtIDFdID09PSBNSU5fQ09ERSkge1xuICAgIGNvZGVzLmxlbmd0aC0tO1xuICB9XG4gIHJldHVybiBjb2Rlcy5sZW5ndGggPiAwID8gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5jb2RlcykgOiAoXG4gICAgLy8gRWRnZSBjYXNlOiB0aGUgc3RyIHdhcyBhIDAtb25seSBzdHJpbmcsIHdoaWNoIGlzIGludmFsaWQuIERlZmF1bHQgYmFjayB0byAuMVxuICAgIE9ORVxuICApO1xufVxuZnVuY3Rpb24gYXNQb3Moc3RyKSB7XG4gIHJldHVybiBpc1BvcyhzdHIpID8gc3RyIDogY29udmVydFRvUG9zKHN0cik7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9PcC50c1xudmFyIE9wQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE9wQ29kZTIpID0+IHtcbiAgT3BDb2RlMltPcENvZGUyW1wiSU5JVFwiXSA9IDBdID0gXCJJTklUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlNFVF9QQVJFTlRfS0VZXCJdID0gMV0gPSBcIlNFVF9QQVJFTlRfS0VZXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9MSVNUXCJdID0gMl0gPSBcIkNSRUFURV9MSVNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlVQREFURV9PQkpFQ1RcIl0gPSAzXSA9IFwiVVBEQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfT0JKRUNUXCJdID0gNF0gPSBcIkNSRUFURV9PQkpFQ1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX0NSRFRcIl0gPSA1XSA9IFwiREVMRVRFX0NSRFRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX09CSkVDVF9LRVlcIl0gPSA2XSA9IFwiREVMRVRFX09CSkVDVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX01BUFwiXSA9IDddID0gXCJDUkVBVEVfTUFQXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9SRUdJU1RFUlwiXSA9IDhdID0gXCJDUkVBVEVfUkVHSVNURVJcIjtcbiAgcmV0dXJuIE9wQ29kZTI7XG59KShPcENvZGUgfHwge30pO1xuZnVuY3Rpb24gYWNrT3Aob3BJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgaWQ6IFwiQUNLXCIsXG4gICAgLy8gKEgpQUNLXG4gICAgb3BJZFxuICB9O1xufVxuZnVuY3Rpb24gaXNBY2tPcChvcCkge1xuICByZXR1cm4gb3AudHlwZSA9PT0gNSAvKiBERUxFVEVfQ1JEVCAqLyAmJiBvcC5pZCA9PT0gXCJBQ0tcIjtcbn1cblxuLy8gc3JjL2NyZHRzL0Fic3RyYWN0Q3JkdC50c1xuZnVuY3Rpb24gY3JkdEFzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gSGFzUGFyZW50KG5vZGUsIGtleSwgcG9zID0gYXNQb3Moa2V5KSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiSGFzUGFyZW50XCIsIG5vZGUsIGtleSwgcG9zIH0pO1xufVxudmFyIE5vUGFyZW50ID0gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiTm9QYXJlbnRcIiB9KTtcbmZ1bmN0aW9uIE9ycGhhbmVkKG9sZEtleSwgb2xkUG9zID0gYXNQb3Mob2xkS2V5KSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHR5cGU6IFwiT3JwaGFuZWRcIiwgb2xkS2V5LCBvbGRQb3MgfSk7XG59XG52YXIgQWJzdHJhY3RDcmR0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcGFyZW50ID0gTm9QYXJlbnQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZ2V0UGFyZW50S2V5T3JUaHJvdygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmtleTtcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQga2V5IGlzIG1pc3NpbmdcIik7XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9sZEtleTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcGFyZW50UG9zKCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zO1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkUG9zO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wb29sKCkge1xuICAgIHJldHVybiB0aGlzLl9fcG9vbDtcbiAgfVxuICBnZXQgcm9vbUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9fcG9vbCA/IHRoaXMuX19wb29sLnJvb21JZCA6IG51bGw7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX2lkKCkge1xuICAgIHJldHVybiB0aGlzLl9faWQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3BhcmVudEtleSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmtleTtcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkS2V5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBfaXNMb2NhbCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSA1IC8qIERFTEVURV9DUkRUICovOiB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGUuX2RldGFjaENoaWxkKGNyZHRBc0xpdmVOb2RlKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2V0UGFyZW50TGluayhuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpIHtcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjpcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Lm5vZGUgIT09IG5ld1BhcmVudE5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHBhcmVudDogbm9kZSBhbHJlYWR5IGhhcyBhIHBhcmVudFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBIYXNQYXJlbnQobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gSGFzUGFyZW50KG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBpZiAodGhpcy5fX2lkIHx8IHRoaXMuX19wb29sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXR0YWNoIG5vZGU6IGFscmVhZHkgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIHBvb2wuYWRkTm9kZShpZCwgY3JkdEFzTGl2ZU5vZGUodGhpcykpO1xuICAgIHRoaXMuX19pZCA9IGlkO1xuICAgIHRoaXMuX19wb29sID0gcG9vbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2goKSB7XG4gICAgaWYgKHRoaXMuX19wb29sICYmIHRoaXMuX19pZCkge1xuICAgICAgdGhpcy5fX3Bvb2wuZGVsZXRlTm9kZSh0aGlzLl9faWQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJIYXNQYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBPcnBoYW5lZCh0aGlzLnBhcmVudC5rZXksIHRoaXMucGFyZW50LnBvcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6IHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gTm9QYXJlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6IHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgICB0aGlzLl9fcG9vbCA9IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIENsZWFyIHRoZSBJbW11dGFibGUgY2FjaGUsIHNvIHRoYXQgdGhlIG5leHQgY2FsbCB0byBgLnRvSW1tdXRhYmxlKClgIHdpbGxcbiAgICogcmVjb21wdXRlIHRoZSBlcXVpdmFsZW50IEltbXV0YWJsZSB2YWx1ZSBhZ2Fpbi4gIENhbGwgdGhpcyBhZnRlciBldmVyeVxuICAgKiBtdXRhdGlvbiB0byB0aGUgTGl2ZSBub2RlLlxuICAgKi9cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkSW1tdXRhYmxlICE9PSB2b2lkIDAgfHwgdGhpcy5fY2FjaGVkVHJlZU5vZGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGVkSW1tdXRhYmxlID0gdm9pZCAwO1xuICAgICAgdGhpcy5fY2FjaGVkVHJlZU5vZGUgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBSZXR1cm4gYW4gc25hcHNob3Qgb2YgdGhpcyBMaXZlIHRyZWUgZm9yIHVzZSBpbiBEZXZUb29scy5cbiAgICovXG4gIHRvVHJlZU5vZGUoa2V5KSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFRyZWVOb2RlID09PSB2b2lkIDAgfHwgdGhpcy5fY2FjaGVkVHJlZU5vZGVLZXkgIT09IGtleSkge1xuICAgICAgdGhpcy5fY2FjaGVkVHJlZU5vZGVLZXkgPSBrZXk7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZSA9IHRoaXMuX3RvVHJlZU5vZGUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFRyZWVOb2RlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gaW1tdXRhYmxlIHNuYXBzaG90IG9mIHRoaXMgTGl2ZSBub2RlIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqL1xuICB0b0ltbXV0YWJsZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkSW1tdXRhYmxlID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2NhY2hlZEltbXV0YWJsZSA9IHRoaXMuX3RvSW1tdXRhYmxlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRJbW11dGFibGU7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9TZXJpYWxpemVkQ3JkdC50c1xudmFyIENyZHRUeXBlID0gLyogQF9fUFVSRV9fICovICgoQ3JkdFR5cGUyKSA9PiB7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJPQkpFQ1RcIl0gPSAwXSA9IFwiT0JKRUNUXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJMSVNUXCJdID0gMV0gPSBcIkxJU1RcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIk1BUFwiXSA9IDJdID0gXCJNQVBcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIlJFR0lTVEVSXCJdID0gM10gPSBcIlJFR0lTVEVSXCI7XG4gIHJldHVybiBDcmR0VHlwZTI7XG59KShDcmR0VHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBpc1Jvb3RDcmR0KGNyZHQpIHtcbiAgcmV0dXJuIGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8gJiYgIWlzQ2hpbGRDcmR0KGNyZHQpO1xufVxuZnVuY3Rpb24gaXNDaGlsZENyZHQoY3JkdCkge1xuICByZXR1cm4gY3JkdC5wYXJlbnRJZCAhPT0gdm9pZCAwICYmIGNyZHQucGFyZW50S2V5ICE9PSB2b2lkIDA7XG59XG5cbi8vIHNyYy9saWIvbmFub2lkLnRzXG5mdW5jdGlvbiBuYW5vaWQobGVuZ3RoID0gNykge1xuICBjb25zdCBhbHBoYWJldCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODksLi87W11+IUAjJCUmKigpXys9LVwiO1xuICBjb25zdCBsZW4gPSBhbHBoYWJldC5sZW5ndGg7XG4gIHJldHVybiBBcnJheS5mcm9tKFxuICAgIHsgbGVuZ3RoIH0sXG4gICAgKCkgPT4gYWxwaGFiZXQuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbikpXG4gICkuam9pbihcIlwiKTtcbn1cblxuLy8gc3JjL2NyZHRzL0xpdmVSZWdpc3Rlci50c1xudmFyIExpdmVSZWdpc3RlciA9IGNsYXNzIF9MaXZlUmVnaXN0ZXIgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgX3BhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCByZWdpc3RlciA9IG5ldyBfTGl2ZVJlZ2lzdGVyKGl0ZW0uZGF0YSk7XG4gICAgcmVnaXN0ZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgcmV0dXJuIHJlZ2lzdGVyO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNhbm5vdCBzZXJpYWxpemUgcmVnaXN0ZXIgaWYgcGFyZW50SWQgb3IgcGFyZW50S2V5IGlzIHVuZGVmaW5lZFwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgcGFyZW50SWQsXG4gICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZVJlZ2lzdGVyIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMyAvKiBSRUdJU1RFUiAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKF9vcCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKF9jcmR0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkpzb25cIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuX2RhdGFcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhpcy5kYXRhKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVMaXN0LnRzXG5mdW5jdGlvbiBjb21wYXJlTm9kZVBvc2l0aW9uKGl0ZW1BLCBpdGVtQikge1xuICBjb25zdCBwb3NBID0gaXRlbUEuX3BhcmVudFBvcztcbiAgY29uc3QgcG9zQiA9IGl0ZW1CLl9wYXJlbnRQb3M7XG4gIHJldHVybiBwb3NBID09PSBwb3NCID8gMCA6IHBvc0EgPCBwb3NCID8gLTEgOiAxO1xufVxudmFyIExpdmVMaXN0ID0gY2xhc3MgX0xpdmVMaXN0IGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgY29uc3RydWN0b3IoaXRlbXMgPSBbXSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgdGhpcy5fdW5hY2tub3dsZWRnZWRTZXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgcG9zaXRpb24gPSB2b2lkIDA7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICBjb25zdCBub2RlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgICBub2RlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld1Bvc2l0aW9uKTtcbiAgICAgIHRoaXMuX2l0ZW1zLnB1c2gobm9kZSk7XG4gICAgICBwb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpc3QgPSBuZXcgX0xpdmVMaXN0KCk7XG4gICAgbGlzdC5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGlkKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkMiwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemUoW2lkMiwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobGlzdCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbGlzdC5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlIHJlc3VsdGluZyBvcHMgd2lsbCBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIgaWYgdGhleSBoYXZlIGFuICdvcElkJ1xuICAgKiBzbyB3ZSBtdXRhdGUgX3VuYWNrbm93bGVkZ2VkU2V0cyB0byBhdm9pZCBwb3RlbnRpYWwgZmxpY2tlcmluZ1xuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWJsb2Nrcy9saXZlYmxvY2tzL3B1bGwvMTE3N1xuICAgKlxuICAgKiBUaGlzIGlzIHF1aXRlIHVuaW50dWl0aXZlIGFuZCBzaG91bGQgZGlzYXBwZWFyIGFzIHNvb24gYXNcbiAgICogd2UgaW50cm9kdWNlIGFuIGV4cGxpY2l0IExpdmVMaXN0LlNldCBvcGVyYXRpb25cbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiAyIC8qIENSRUFURV9MSVNUICovLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXlcbiAgICB9O1xuICAgIG9wcy5wdXNoKG9wKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleTIgPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgICBjb25zdCBjaGlsZE9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwYXJlbnRLZXkyLCBwb29sKSxcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgICAgY29uc3QgY2hpbGRPcElkID0gY2hpbGRPcHNbMF0ub3BJZDtcbiAgICAgIGlmIChjaGlsZE9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KHBhcmVudEtleTIsIGNoaWxkT3BJZCk7XG4gICAgICB9XG4gICAgICBvcHMucHVzaCguLi5jaGlsZE9wcyk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gaW50byB0aGUgc29ydGVkIGxpc3QsIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uLlxuICAgKi9cbiAgX2luc2VydEFuZFNvcnQoaXRlbSkge1xuICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc29ydEl0ZW1zKCkge1xuICAgIHRoaXMuX2l0ZW1zLnNvcnQoY29tcGFyZU5vZGVQb3NpdGlvbik7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW5kZXhPZlBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmZpbmRJbmRleChcbiAgICAgIChpdGVtKSA9PiBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkgPT09IHBvc2l0aW9uXG4gICAgKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGl0ZW0uX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRSZW1vdGUob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBkZWxldGVkSWQgPSBvcC5kZWxldGVkSWQ7XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXTtcbiAgICAgIGlmIChpdGVtV2l0aFNhbWVQb3NpdGlvbi5faWQgPT09IGRlbGV0ZWRJZCkge1xuICAgICAgICBpdGVtV2l0aFNhbWVQb3NpdGlvbi5fZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChpdGVtV2l0aFNhbWVQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBbXG4gICAgICAgICAgc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCBjaGlsZClcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZGVsZXRlRGVsdGEyID0gdGhpcy5fZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGRlbGV0ZURlbHRhMikge1xuICAgICAgICAgIGRlbHRhLnB1c2goZGVsZXRlRGVsdGEyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgICBjb25zdCBkZWxldGVEZWx0YTIgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlRGVsdGEyKSB7XG4gICAgICAgIHVwZGF0ZXMucHVzaChkZWxldGVEZWx0YTIpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB1cGRhdGVzLnB1c2goaW5zZXJ0RGVsdGEodGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSksIGNoaWxkKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXZlcnNlOiBbXSxcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgdXBkYXRlcylcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0QWNrKG9wKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBbXTtcbiAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWREZWx0YSkge1xuICAgICAgZGVsdGEucHVzaChkZWxldGVkRGVsdGEpO1xuICAgIH1cbiAgICBjb25zdCB1bmFja25vd2xlZGdlZE9wSWQgPSB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuZ2V0KG9wLnBhcmVudEtleSk7XG4gICAgaWYgKHVuYWNrbm93bGVkZ2VkT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodW5hY2tub3dsZWRnZWRPcElkICE9PSBvcC5vcElkKSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5sZW5ndGggPT09IDAgPyB7IG1vZGlmaWVkOiBmYWxzZSB9IDogeyBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSksIHJldmVyc2U6IFtdIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuZGVsZXRlKG9wLnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uX2lkID09PSBvcC5pZCk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtLl9wYXJlbnRLZXkgPT09IG9wLnBhcmVudEtleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBkZWx0YS5sZW5ndGggPiAwID8gbWFrZVVwZGF0ZSh0aGlzLCBkZWx0YSkgOiBmYWxzZSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5hZGQoXG4gICAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCAxKTtcbiAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24pKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBleGlzdGluZ0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICBpZiAobmV3SW5kZXggIT09IHByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgZGVsdGEucHVzaChtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JwaGFuID0gdGhpcy5fcG9vbC5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCByZWNyZWF0ZWRJdGVtSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKG9ycGhhbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGlzIHBvc2l0aW9uLCB1cGRhdGUgaXMgYSBzZXQsIGVsc2UgaXQncyBhbiBpbnNlcnRcbiAgICAgICAgICAgIGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9PT0gLTEgPyBpbnNlcnREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbikgOiBzZXREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbiksXG4gICAgICAgICAgICAuLi5kZWx0YVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KFxuICAgICAgICAgIG9wLFxuICAgICAgICAgIG9wLnBhcmVudEtleVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhpcyBwb3NpdGlvbiwgdXBkYXRlIGlzIGEgc2V0LCBlbHNlIGl0J3MgYW4gaW5zZXJ0XG4gICAgICAgICAgICBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPT09IC0xID8gaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pIDogc2V0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pLFxuICAgICAgICAgICAgLi4uZGVsdGFcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdXBkYXRlIGRlbHRhIG9mIHRoZSBkZWxldGlvbiBvciBudWxsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oZGVsZXRlZElkKSB7XG4gICAgaWYgKGRlbGV0ZWRJZCA9PT0gdm9pZCAwIHx8IHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRlbGV0ZWRJdGVtID0gdGhpcy5fcG9vbC5nZXROb2RlKGRlbGV0ZWRJZCk7XG4gICAgaWYgKGRlbGV0ZWRJdGVtID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZXRhY2hDaGlsZChkZWxldGVkSXRlbSk7XG4gICAgaWYgKHJlc3VsdC5tb2RpZmllZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lm1vZGlmaWVkLnVwZGF0ZXNbMF07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlSZW1vdGVJbnNlcnQob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBhc1BvcyhvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fc2hpZnRJdGVtUG9zaXRpb24oZXhpc3RpbmdJdGVtSW5kZXgsIGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pXSksXG4gICAgICByZXZlcnNlOiBbXVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlJbnNlcnRBY2sob3ApIHtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLl9pZCA9PT0gb3AuaWQpO1xuICAgIGNvbnN0IGtleSA9IGFzUG9zKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgaXRlbUluZGV4QXRQb3NpdGlvbiA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW0pIHtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW0uX3BhcmVudEtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvbGRQb3NpdGlvbkluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihleGlzdGluZ0l0ZW0pO1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4aXN0aW5nSXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSBvbGRQb3NpdGlvbkluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEob2xkUG9zaXRpb25JbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcnBoYW4gPSBubih0aGlzLl9wb29sKS5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgb3JwaGFuKV0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlbUluZGV4QXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihpdGVtSW5kZXhBdFBvc2l0aW9uLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSldKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseUluc2VydFVuZG9SZWRvKG9wKSB7XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIGlmICh0aGlzLl9wb29sPy5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBsZXQgbmV3S2V5ID0ga2V5O1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGJlZm9yZTIgPSB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0/Ll9wYXJlbnRQb3M7XG4gICAgICBjb25zdCBhZnRlcjIgPSB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zO1xuICAgICAgbmV3S2V5ID0gbWFrZVBvc2l0aW9uKGJlZm9yZTIsIGFmdGVyMik7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0VW5kb1JlZG8ob3ApIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2w/LmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBuZXdLZXkgPSBrZXk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgIT09IC0xKSB7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XTtcbiAgICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgICB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XSA9IGNoaWxkO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGV4aXN0aW5nSXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBrZXksIHRoaXMuX3Bvb2wpLFxuICAgICAgICBvcC5pZFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gW3NldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXksIGNoaWxkKV07XG4gICAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICAgIGRlbHRhLnB1c2goZGVsZXRlZERlbHRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChvcC5pbnRlbnQgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5U2V0UmVtb3RlKG9wKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldEFjayhvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVNldFVuZG9SZWRvKG9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlSZW1vdGVJbnNlcnQob3ApO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5SW5zZXJ0QWNrKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5SW5zZXJ0VW5kb1JlZG8ob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhubih0aGlzLl9pZCksIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBpbmRleFRvRGVsZXRlID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAoaW5kZXhUb0RlbGV0ZSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleFRvRGVsZXRlLCAxKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4VG9EZWxldGUpXSksXG4gICAgICAgIHJldmVyc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCkge1xuICAgIGlmICh0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBjaGlsZC5fcGFyZW50S2V5O1xuICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChuZXdJbmRleCA9PT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGlmICh0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShjaGlsZCk7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChwcmV2aW91c0luZGV4ID09PSBuZXdJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKSB7XG4gICAgY29uc3QgcHJldmlvdXNLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9pdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICApO1xuICAgIH1cbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgIHJldmVyc2U6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQ6IG5uKGNoaWxkLl9pZCksXG4gICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c0tleVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRDaGlsZEtleShuZXdLZXksIGNoaWxkLCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlSZW1vdGUobmV3S2V5LCBjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleUFjayhuZXdLZXksIGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0Q2hpbGRLZXlVbmRvUmVkbyhuZXdLZXksIGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIGlzTG9jYWwpIHtcbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgIT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgTGl2ZUxpc3QgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAxIC8qIExJU1QgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzLlxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9uZSBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIExpdmVMaXN0LlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIHJldHVybiB0aGlzLmluc2VydChlbGVtZW50LCB0aGlzLmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgb25lIGVsZW1lbnQgYXQgYSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB5b3Ugd2FudCB0byBpbnNlcnQgdGhlIGVsZW1lbnQuXG4gICAqL1xuICBpbnNlcnQoZWxlbWVudCwgaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBpbnNlcnQgbGlzdCBpdGVtIGF0IGluZGV4IFwiXHUwMDFkJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYmVmb3JlMiA9IHRoaXMuX2l0ZW1zW2luZGV4IC0gMV0gPyB0aGlzLl9pdGVtc1tpbmRleCAtIDFdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgYWZ0ZXIyID0gdGhpcy5faXRlbXNbaW5kZXhdID8gdGhpcy5faXRlbXNbaW5kZXhdLl9wYXJlbnRQb3MgOiB2b2lkIDA7XG4gICAgY29uc3QgcG9zaXRpb24gPSBtYWtlUG9zaXRpb24oYmVmb3JlMiwgYWZ0ZXIyKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxzb25Ub0xpdmVOb2RlKGVsZW1lbnQpO1xuICAgIHZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KHZhbHVlKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIHZhbHVlLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgdmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdGhpcy5fcG9vbCksXG4gICAgICAgIFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShpbmRleCwgdmFsdWUpXSldXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTW92ZSBvbmUgZWxlbWVudCBmcm9tIG9uZSBpbmRleCB0byBhbm90aGVyLlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIG1vdmVcbiAgICogQHBhcmFtIHRhcmdldEluZGV4IFRoZSBpbmRleCB3aGVyZSB0aGUgZWxlbWVudCBzaG91bGQgYmUgYWZ0ZXIgbW92aW5nLlxuICAgKi9cbiAgbW92ZShpbmRleCwgdGFyZ2V0SW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInRhcmdldEluZGV4IGNhbm5vdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRoYW4gdGhlIGxpc3QgbGVuZ3RoXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIik7XG4gICAgfVxuICAgIGxldCBiZWZvcmVQb3NpdGlvbiA9IG51bGw7XG4gICAgbGV0IGFmdGVyUG9zaXRpb24gPSBudWxsO1xuICAgIGlmIChpbmRleCA8IHRhcmdldEluZGV4KSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGFyZ2V0SW5kZXggPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgPyB2b2lkIDAgOiB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleCArIDFdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRoaXMuX2l0ZW1zW3RhcmdldEluZGV4XS5fcGFyZW50UG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlclBvc2l0aW9uID0gdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXhdLl9wYXJlbnRQb3M7XG4gICAgICBiZWZvcmVQb3NpdGlvbiA9IHRhcmdldEluZGV4ID09PSAwID8gdm9pZCAwIDogdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXggLSAxXS5fcGFyZW50UG9zO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihiZWZvcmVQb3NpdGlvbiwgYWZ0ZXJQb3NpdGlvbik7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICBjb25zdCBwcmV2aW91c1Bvc2l0aW9uID0gaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgIGl0ZW0uX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW3RoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEoaW5kZXgsIHRhcmdldEluZGV4LCBpdGVtKV0pXVxuICAgICAgXSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICAgIGlkOiBubihpdGVtLl9pZCksXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgICBpZDogbm4oaXRlbS5faWQpLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwcmV2aW91c1Bvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoaW5kZXgpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZGVsZXRlIGxpc3QgaXRlbSBhdCBpbmRleCBcIiR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wpIHtcbiAgICAgIGNvbnN0IGNoaWxkUmVjb3JkSWQgPSBpdGVtLl9pZDtcbiAgICAgIGlmIChjaGlsZFJlY29yZElkKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgIG5uKHRoaXMuX2lkKSxcbiAgICAgICAgICBtYWtlVXBkYXRlKHRoaXMsIFtkZWxldGVEZWx0YShpbmRleCldKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWQ6IGNoaWxkUmVjb3JkSWQsXG4gICAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCksXG4gICAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGl0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwgaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpKSxcbiAgICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0aGlzLl9wb29sKSB7XG4gICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICAgIGNvbnN0IHVwZGF0ZURlbHRhID0gW107XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgICAgIGNvbnN0IGNoaWxkSWQgPSBpdGVtLl9pZDtcbiAgICAgICAgaWYgKGNoaWxkSWQpIHtcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICAgICAgaWQ6IGNoaWxkSWQsXG4gICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV2ZXJzZU9wcy5wdXNoKFxuICAgICAgICAgICAgLi4uaXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB1cGRhdGVEZWx0YS5wdXNoKGRlbGV0ZURlbHRhKDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KG5uKHRoaXMuX2lkKSwgbWFrZVVwZGF0ZSh0aGlzLCB1cGRhdGVEZWx0YSkpO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBzZXQoaW5kZXgsIGl0ZW0pIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc2V0IGxpc3QgaXRlbSBhdCBpbmRleCBcIlx1MDAxZCR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5faXRlbXMubGVuZ3RoIC0gMX1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG4gICAgY29uc3QgcG9zaXRpb24gPSBleGlzdGluZ0l0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICBjb25zdCBleGlzdGluZ0lkID0gZXhpc3RpbmdJdGVtLl9pZDtcbiAgICBleGlzdGluZ0l0ZW0uX2RldGFjaCgpO1xuICAgIGNvbnN0IHZhbHVlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX2l0ZW1zW2luZGV4XSA9IHZhbHVlO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgdmFsdWUuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW3NldERlbHRhKGluZGV4LCB2YWx1ZSldKSk7XG4gICAgICBjb25zdCBvcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICB2YWx1ZS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB0aGlzLl9wb29sKSxcbiAgICAgICAgZXhpc3RpbmdJZFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQocG9zaXRpb24sIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICBjb25zdCByZXZlcnNlT3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgZXhpc3RpbmdJdGVtLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHZvaWQgMCksXG4gICAgICAgIGlkXG4gICAgICApO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gQXJyYXkgb2YgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgTGl2ZUxpc3QuXG4gICAqL1xuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5tYXAoXG4gICAgICAoZW50cnkpID0+IGxpdmVOb2RlVG9Mc29uKGVudHJ5KVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciBhbGwgZWxlbWVudHMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LCB0YWtpbmcgdHdvIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQgYW5kIGl0cyBpbmRleCkuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBldmVyeSBlbGVtZW50LiBPdGhlcndpc2UsIGZhbHNlLlxuICAgKi9cbiAgZXZlcnkocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmV2ZXJ5KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGVhY2ggZWxlbWVudCBvZiB0aGUgTGl2ZUxpc3QuIFJldHVybiBhIHZhbHVlIHRoYXQgY29lcmNlcyB0byB0cnVlIHRvIGtlZXAgdGhlIGVsZW1lbnQsIG9yIHRvIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0LlxuICAgKi9cbiAgZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maWx0ZXIocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUuXG4gICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uIE90aGVyd2lzZSwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZmluZChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZChwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlIHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGluZGljYXRpbmcgdGhhdCB0aGUgc2F0aXNmeWluZyBlbGVtZW50IHdhcyBmb3VuZC5cbiAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHBhc3NlcyB0aGUgdGVzdC4gT3RoZXJ3aXNlLCAtMS5cbiAgICovXG4gIGZpbmRJbmRleChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcGFyYW0gY2FsbGJhY2tmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2tmbikge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGNhbGxiYWNrZm4pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvbiB0aGUgZWxlbWVudCB0byBnZXQuXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih0aGlzLl9pdGVtc1tpbmRleF0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBMaXZlTGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGF0LlxuICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0OyAtMSBpZiBub3QgZm91bmQuXG4gICAqL1xuICBpbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5pbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgTGl2ZUxpc3QsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LiBUaGUgTGl2ZUxzaXQgaXMgc2VhcmNoZWQgYmFja3dhcmRzLCBzdGFydGluZyBhdCBmcm9tSW5kZXguXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlLlxuICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmcgYmFja3dhcmRzLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggdGhlIHJlc3VsdHMgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5IGVsZW1lbnQuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZXZlcnkgZWxlbWVudC5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCBlYWNoIGVsZW1lbnQgYmVpbmcgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBtYXAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubWFwKFxuICAgICAgKGVudHJ5LCBpKSA9PiBjYWxsYmFjayhcbiAgICAgICAgbGl2ZU5vZGVUb0xzb24oZW50cnkpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIEZJWE1FISBUaGlzIGlzbid0IHNhZmUuXG4gICAgICAgIGlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCBwYXNzZXMgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3IgYXQgbGVhc3Qgb25lIGVsZW1lbnQuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBzb21lKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5zb21lKHByZWRpY2F0ZSk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdEl0ZXJhdG9yKHRoaXMuX2l0ZW1zKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9jcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KSB7XG4gICAgY29uc3QgbmV3SXRlbSA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBuZXdJdGVtLl9hdHRhY2gob3AuaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBuZXdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydChuZXdJdGVtKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIHJldHVybiB7IG5ld0l0ZW0sIG5ld0luZGV4IH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2hpZnRJdGVtUG9zaXRpb24oaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHNoaWZ0ZWRQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihcbiAgICAgIGtleSxcbiAgICAgIHRoaXMuX2l0ZW1zLmxlbmd0aCA+IGluZGV4ICsgMSA/IHRoaXMuX2l0ZW1zW2luZGV4ICsgMV0/Ll9wYXJlbnRQb3MgOiB2b2lkIDBcbiAgICApO1xuICAgIHRoaXMuX2l0ZW1zW2luZGV4XS5fc2V0UGFyZW50TGluayh0aGlzLCBzaGlmdGVkUG9zaXRpb24pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuX2l0ZW1zLm1hcChcbiAgICAgICAgKGl0ZW0sIGluZGV4KSA9PiBpdGVtLnRvVHJlZU5vZGUoaW5kZXgudG9TdHJpbmcoKSlcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2l0ZW1zLm1hcCgobm9kZSkgPT4gbm9kZS50b0ltbXV0YWJsZSgpKTtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gcmVzdWx0IDogT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVMaXN0KHRoaXMuX2l0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5jbG9uZSgpKSk7XG4gIH1cbn07XG52YXIgTGl2ZUxpc3RJdGVyYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaXRlbXMpIHtcbiAgICB0aGlzLl9pbm5lckl0ZXJhdG9yID0gaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5leHQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5faW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1ha2VVcGRhdGUobGl2ZUxpc3QsIGRlbHRhVXBkYXRlcykge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IGxpdmVMaXN0LFxuICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICB1cGRhdGVzOiBkZWx0YVVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldERlbHRhKGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJzZXRcIixcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlRGVsdGEoaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcImRlbGV0ZVwiXG4gIH07XG59XG5mdW5jdGlvbiBpbnNlcnREZWx0YShpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwiaW5zZXJ0XCIsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwibW92ZVwiLFxuICAgIHByZXZpb3VzSW5kZXgsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24ob3BzLCBkZWxldGVkSWQpIHtcbiAgcmV0dXJuIG9wcy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgY29uc3QgZmlyc3RPcCA9IG9wO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmlyc3RPcCxcbiAgICAgICAgaW50ZW50OiBcInNldFwiLFxuICAgICAgICBkZWxldGVkSWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbGliL2ZyZWV6ZS50c1xudmFyIGZyZWV6ZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IChcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgKHgpID0+IHhcbikgOiBPYmplY3QuZnJlZXplO1xuXG4vLyBzcmMvY3JkdHMvTGl2ZU1hcC50c1xudmFyIExpdmVNYXAgPSBjbGFzcyBfTGl2ZU1hcCBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIGNvbnN0cnVjdG9yKGVudHJpZXMyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAoZW50cmllczIpIHtcbiAgICAgIGNvbnN0IG1hcHBlZEVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgICAgIG5vZGUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgbWFwcGVkRW50cmllcy5wdXNoKFtrZXksIG5vZGVdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAobWFwcGVkRW50cmllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IG9wID0ge1xuICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgb3BJZDogcG9vbD8uZ2VuZXJhdGVPcElkKCksXG4gICAgICB0eXBlOiA3IC8qIENSRUFURV9NQVAgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgb3BzLnB1c2goLi4udmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHBvb2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplKFtpZCwgX2l0ZW1dLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IF9MaXZlTWFwKCk7XG4gICAgbWFwLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZDIsIGNyZHRdIG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGRlc2VyaWFsaXplKFtpZDIsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKG1hcCwgY3JkdC5wYXJlbnRLZXkpO1xuICAgICAgbWFwLl9tYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBtYXAuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcGFyZW50S2V5LCBvcElkIH0gPSBvcDtcbiAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXk7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICBjb25zdCBsYXN0VXBkYXRlT3BJZCA9IHRoaXMudW5hY2tub3dsZWRnZWRTZXQuZ2V0KGtleSk7XG4gICAgICBpZiAobGFzdFVwZGF0ZU9wSWQgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy51bmFja25vd2xlZGdlZFNldC5kZWxldGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9IGVsc2UgaWYgKGxhc3RVcGRhdGVPcElkICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICBjb25zdCB0aGlzSWQgPSBubih0aGlzLl9pZCk7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XTtcbiAgICB9XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICB0aGlzLl9tYXAuc2V0KGtleSwgY2hpbGQpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9tYXAudmFsdWVzKCkpIHtcbiAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKGlkLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIHVwZGF0ZXM6IHsgW3BhcmVudEtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICB9O1xuICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTWFwIGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMiAvKiBNQVAgKi8sXG4gICAgICBwYXJlbnRJZDogbm4odGhpcy5wYXJlbnQubm9kZS5faWQsIFwiUGFyZW50IG5vZGUgZXhwZWN0ZWQgdG8gaGF2ZSBJRFwiKSxcbiAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhlIExpdmVNYXAuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsaXZlTm9kZVRvTHNvbih2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCBhIHZhbHVlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkLiBTaG91bGQgYmUgc2VyaWFsaXphYmxlIHRvIEpTT04uXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIHRoaXMuX21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIGl0ZW0uX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgb3BzID0gaXRlbS5fdG9PcHModGhpcy5faWQsIGtleSwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LnNldChrZXksIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKSxcbiAgICAgICAgb2xkVmFsdWUgPyBvbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSkgOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHRlc3QgZm9yIHByZXNlbmNlLlxuICAgKi9cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGJ5IGtleS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IGV4aXN0ZWQgYW5kIGhhcyBiZWVuIHJlbW92ZWQsIG9yIGZhbHNlIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBpZiAoaXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiBpdGVtLl9pZCkge1xuICAgICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXNJZCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgICAgIGlkOiBpdGVtLl9pZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXNJZCwga2V5KSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBba2V5LCB2YWx1ZV0gcGFpcnMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGVudHJpZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclZhbHVlID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyYXRvclZhbHVlLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlcmF0b3JWYWx1ZS52YWx1ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gZW50cnlbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24oaXRlcmF0b3JWYWx1ZS52YWx1ZVsxXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IFtrZXksIHZhbHVlXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlbnRyaWVzIG1ldGhvZC5cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUga2V5cyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICB2YWx1ZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuX21hcC52YWx1ZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yVmFsdWUgPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yVmFsdWUuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihpdGVyYXRvclZhbHVlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgcGVyIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIE1hcCBvYmplY3QsIGluIGluc2VydGlvbiBvcmRlci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZW50cnkgaW4gdGhlIG1hcC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMpIHtcbiAgICAgIGNhbGxiYWNrKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLl9tYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsXSkgPT4gdmFsLnRvVHJlZU5vZGUoa2V5MilcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUudG9JbW11dGFibGUoKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlTWFwKFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLl9tYXApLm1hcCgoW2tleSwgbm9kZV0pID0+IFtrZXksIG5vZGUuY2xvbmUoKV0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVPYmplY3QudHNcbnZhciBMaXZlT2JqZWN0ID0gY2xhc3MgX0xpdmVPYmplY3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihvYmogPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgbyA9IGNvbXBhY3RPYmplY3Qob2JqKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvW2tleV07XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhvKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2J1aWxkUm9vdEFuZFBhcmVudFRvQ2hpbGRyZW4oaXRlbXMpIHtcbiAgICBjb25zdCBwYXJlbnRUb0NoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgcm9vdCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBbaWQsIGNyZHRdIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAoaXNSb290Q3JkdChjcmR0KSkge1xuICAgICAgICByb290ID0gW2lkLCBjcmR0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHR1cGxlID0gW2lkLCBjcmR0XTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRUb0NoaWxkcmVuLmdldChjcmR0LnBhcmVudElkKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHR1cGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnRUb0NoaWxkcmVuLnNldChjcmR0LnBhcmVudElkLCBbdHVwbGVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBjYW4ndCBiZSBudWxsXCIpO1xuICAgIH1cbiAgICByZXR1cm4gW3Jvb3QsIHBhcmVudFRvQ2hpbGRyZW5dO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9mcm9tSXRlbXMoaXRlbXMsIHBvb2wpIHtcbiAgICBjb25zdCBbcm9vdCwgcGFyZW50VG9DaGlsZHJlbl0gPSBfTGl2ZU9iamVjdC5fYnVpbGRSb290QW5kUGFyZW50VG9DaGlsZHJlbihpdGVtcyk7XG4gICAgcmV0dXJuIF9MaXZlT2JqZWN0Ll9kZXNlcmlhbGl6ZShcbiAgICAgIHJvb3QsXG4gICAgICBwYXJlbnRUb0NoaWxkcmVuLFxuICAgICAgcG9vbFxuICAgICk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcElkID0gcG9vbD8uZ2VuZXJhdGVPcElkKCk7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXksXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIG9wcy5wdXNoKC4uLnZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCBwb29sKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpdmVPYmogPSBuZXcgX0xpdmVPYmplY3QoaXRlbS5kYXRhKTtcbiAgICBsaXZlT2JqLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KG5uKGxpdmVPYmouX2lkKSk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsaXZlT2JqO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemVUb0xzb24oW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXZlT2JqLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgICBsaXZlT2JqLl9tYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBsaXZlT2JqLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVPYmo7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgb3BJZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTHNvbihvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLykge1xuICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihvcElkKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChpc0xpdmVOb2RlKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZDogdGhpc0lkLCBrZXkgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgaWQ6IHRoaXNJZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBwcmV2aW91c1ZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5fbWFwLnNldChrZXksIGNoaWxkKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBbcGFyZW50S2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2goKSB7XG4gICAgc3VwZXIuX2RldGFjaCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5fbWFwLnZhbHVlcygpKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIGlmIChvcC50eXBlID09PSAzIC8qIFVQREFURV9PQkpFQ1QgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVVwZGF0ZShvcCwgaXNMb2NhbCk7XG4gICAgfSBlbHNlIGlmIChvcC50eXBlID09PSA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlEZWxldGVPYmplY3RLZXkob3AsIGlzTG9jYWwpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuX2FwcGx5KG9wLCBpc0xvY2FsKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmICghaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiICYmIHRoaXMucGFyZW50Lm5vZGUuX2lkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwIC8qIE9CSkVDVCAqLyxcbiAgICAgICAgcGFyZW50SWQ6IHRoaXMucGFyZW50Lm5vZGUuX2lkLFxuICAgICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBPQkpFQ1QgKi8sXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5VXBkYXRlKG9wLCBpc0xvY2FsKSB7XG4gICAgbGV0IGlzTW9kaWZpZWQgPSBmYWxzZTtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCByZXZlcnNlID0gW107XG4gICAgY29uc3QgcmV2ZXJzZVVwZGF0ZSA9IHtcbiAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgIGlkLFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIHJldmVyc2UucHVzaCguLi5vbGRWYWx1ZS5fdG9PcHMoaWQsIGtleSkpO1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZS5kYXRhW2tleV0gPSBvbGRWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlLnB1c2goeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZCwga2V5IH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1cGRhdGVEZWx0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3AuZGF0YVtrZXldO1xuICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG5uKG9wLm9wSWQpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSBvcC5vcElkKSB7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICBpc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZURlbHRhW2tleV0gPSB7IHR5cGU6IFwidXBkYXRlXCIgfTtcbiAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHJldmVyc2VVcGRhdGUuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBpc01vZGlmaWVkID8ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHVwZGF0ZURlbHRhXG4gICAgICB9LFxuICAgICAgcmV2ZXJzZVxuICAgIH0gOiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5RGVsZXRlT2JqZWN0S2V5KG9wLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qga2V5ID0gb3Aua2V5O1xuICAgIGlmICh0aGlzLl9tYXAuaGFzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKCFpc0xvY2FsICYmIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGxldCByZXZlcnNlID0gW107XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKGlkLCBvcC5rZXkpO1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBvbGRWYWx1ZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW29wLmtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBMaXZlT2JqZWN0IGludG8gYSBqYXZhc2NyaXB0IG9iamVjdFxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLl9tYXApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYSBwcm9wZXJ0eSB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYWRkXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgdGhpcy51cGRhdGUoeyBba2V5XTogdmFsdWUgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSB0aGUgTGl2ZU9iamVjdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXRcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEga2V5IGZyb20gdGhlIExpdmVPYmplY3RcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGtleUFzU3RyaW5nID0ga2V5O1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXlBc1N0cmluZyk7XG4gICAgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXlBc1N0cmluZyk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXlBc1N0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgZGF0YTogeyBba2V5QXNTdHJpbmddOiBvbGRWYWx1ZSB9LFxuICAgICAgICAgIGlkOiB0aGlzLl9pZFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLl9tYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sXG4gICAgICAgICAga2V5OiBrZXlBc1N0cmluZyxcbiAgICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZSB3aXRoIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHBhdGNoIFRoZSBvYmplY3QgdXNlZCB0byBvdmVycmlkZXMgcHJvcGVydGllc1xuICAgKi9cbiAgdXBkYXRlKHBhdGNoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwIHx8IHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpdmVOb2RlKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICBjb25zdCBvcElkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCB1cGRhdGVkUHJvcHMgPSB7fTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlT3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRGVsdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICByZXZlcnNlT3BzLnB1c2goLi4ub2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpKTtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2VPcHMucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzLl9pZCwga2V5IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZU9wLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGl2ZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG5ld1ZhbHVlLl9hdHRhY2godGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCksIHRoaXMuX3Bvb2wpO1xuICAgICAgICBjb25zdCBuZXdBdHRhY2hDaGlsZE9wcyA9IG5ld1ZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgICAgY29uc3QgY3JlYXRlQ3JkdE9wID0gbmV3QXR0YWNoQ2hpbGRPcHMuZmluZChcbiAgICAgICAgICAob3ApID0+IG9wLnBhcmVudElkID09PSB0aGlzLl9pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoY3JlYXRlQ3JkdE9wKSB7XG4gICAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihjcmVhdGVDcmR0T3Aub3BJZCkpO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKC4uLm5ld0F0dGFjaENoaWxkT3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRQcm9wc1trZXldID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgb3BJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB1cGRhdGVEZWx0YVtrZXldID0geyB0eXBlOiBcInVwZGF0ZVwiIH07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyZXZlcnNlVXBkYXRlT3AuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlT3BzLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZU9wKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZWRQcm9wcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICBvcHMudW5zaGlmdCh7XG4gICAgICAgIG9wSWQsXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICBkYXRhOiB1cGRhdGVkUHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB1cGRhdGVEZWx0YVxuICAgIH0pO1xuICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiBzdXBlci50b1RyZWVOb2RlKGtleSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICBjb25zdCBub2RlSWQgPSB0aGlzLl9pZCA/PyBuYW5vaWQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBpZDogbm9kZUlkLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLl9tYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsdWVdKSA9PiBpc0xpdmVOb2RlKHZhbHVlKSA/IHZhbHVlLnRvVHJlZU5vZGUoa2V5MikgOiB7IHR5cGU6IFwiSnNvblwiLCBpZDogYCR7bm9kZUlkfToke2tleTJ9YCwga2V5OiBrZXkyLCBwYXlsb2FkOiB2YWx1ZSB9XG4gICAgICApXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGlzTGl2ZVN0cnVjdHVyZSh2YWwpID8gdmFsLnRvSW1tdXRhYmxlKCkgOiB2YWw7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU9iamVjdChcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9tYXApLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgPyB2YWx1ZS5jbG9uZSgpIDogZGVlcENsb25lKHZhbHVlKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9saXZlYmxvY2tzLWhlbHBlcnMudHNcbmZ1bmN0aW9uIGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKSB7XG4gIHJldHVybiBsc29uVG9MaXZlTm9kZShjcmVhdGlvbk9wVG9Mc29uKG9wKSk7XG59XG5mdW5jdGlvbiBjcmVhdGlvbk9wVG9Mc29uKG9wKSB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86XG4gICAgICByZXR1cm4gb3AuZGF0YTtcbiAgICBjYXNlIDQgLyogQ1JFQVRFX09CSkVDVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChvcC5kYXRhKTtcbiAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU1hcCgpO1xuICAgIGNhc2UgMiAvKiBDUkVBVEVfTElTVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZUxpc3QoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKG9wLCBcIlVua25vd24gY3JlYXRpb24gT3BcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZSwgcGFyZW50KSB7XG4gIGlmIChub2RlID09PSBwYXJlbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgIHJldHVybiBpc1NhbWVOb2RlT3JDaGlsZE9mKG5vZGUucGFyZW50Lm5vZGUsIHBhcmVudCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICBzd2l0Y2ggKGNyZHQudHlwZSkge1xuICAgIGNhc2UgMCAvKiBPQkpFQ1QgKi86IHtcbiAgICAgIHJldHVybiBMaXZlT2JqZWN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAxIC8qIExJU1QgKi86IHtcbiAgICAgIHJldHVybiBMaXZlTGlzdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMiAvKiBNQVAgKi86IHtcbiAgICAgIHJldHVybiBMaXZlTWFwLl9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAzIC8qIFJFR0lTVEVSICovOiB7XG4gICAgICByZXR1cm4gTGl2ZVJlZ2lzdGVyLl9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVRvTHNvbihbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBjcmR0LmRhdGE7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgQ1JEVCB0eXBlXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNMaXZlU3RydWN0dXJlKHZhbHVlKSB7XG4gIHJldHVybiBpc0xpdmVMaXN0KHZhbHVlKSB8fCBpc0xpdmVNYXAodmFsdWUpIHx8IGlzTGl2ZU9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0xpdmVOb2RlKHZhbHVlKSB7XG4gIHJldHVybiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHx8IGlzTGl2ZVJlZ2lzdGVyKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZUxpc3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVNYXAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0O1xufVxuZnVuY3Rpb24gaXNMaXZlUmVnaXN0ZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyO1xufVxuZnVuY3Rpb24gY2xvbmVMc29uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNMaXZlU3RydWN0dXJlKHZhbHVlKSA/IHZhbHVlLmNsb25lKCkgOiBkZWVwQ2xvbmUodmFsdWUpO1xufVxuZnVuY3Rpb24gbGl2ZU5vZGVUb0xzb24ob2JqKSB7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIpIHtcbiAgICByZXR1cm4gb2JqLmRhdGE7XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGl2ZUxpc3QgfHwgb2JqIGluc3RhbmNlb2YgTGl2ZU1hcCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob2JqLCBcIlVua25vd24gQWJzdHJhY3RDcmR0XCIpO1xuICB9XG59XG5mdW5jdGlvbiBsc29uVG9MaXZlTm9kZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0IHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIExpdmVMaXN0KSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgTGl2ZVJlZ2lzdGVyKHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHJlZXNEaWZmT3BlcmF0aW9ucyhjdXJyZW50SXRlbXMsIG5ld0l0ZW1zKSB7XG4gIGNvbnN0IG9wcyA9IFtdO1xuICBjdXJyZW50SXRlbXMuZm9yRWFjaCgoXywgaWQpID0+IHtcbiAgICBpZiAoIW5ld0l0ZW1zLmdldChpZCkpIHtcbiAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIG5ld0l0ZW1zLmZvckVhY2goKGNyZHQsIGlkKSA9PiB7XG4gICAgY29uc3QgY3VycmVudENyZHQgPSBjdXJyZW50SXRlbXMuZ2V0KGlkKTtcbiAgICBpZiAoY3VycmVudENyZHQpIHtcbiAgICAgIGlmIChjcmR0LnR5cGUgPT09IDAgLyogT0JKRUNUICovKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q3JkdC50eXBlICE9PSAwIC8qIE9CSkVDVCAqLyB8fCBKU09OLnN0cmluZ2lmeShjcmR0LmRhdGEpICE9PSBKU09OLnN0cmluZ2lmeShjdXJyZW50Q3JkdC5kYXRhKSkge1xuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjcmR0LnBhcmVudEtleSAhPT0gY3VycmVudENyZHQucGFyZW50S2V5KSB7XG4gICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhcmVudEtleTogbm4oY3JkdC5wYXJlbnRLZXksIFwiUGFyZW50IGtleSBtdXN0IG5vdCBiZSBtaXNzaW5nXCIpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGNyZHQudHlwZSkge1xuICAgICAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogOCAvKiBDUkVBVEVfUkVHSVNURVIgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgLyogTElTVCAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyIC8qIENSRUFURV9MSVNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogY3JkdC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudEtleTogY3JkdC5wYXJlbnRLZXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAwIC8qIE9CSkVDVCAqLzpcbiAgICAgICAgICBpZiAoY3JkdC5wYXJlbnRJZCA9PT0gdm9pZCAwIHx8IGNyZHQucGFyZW50S2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJbnRlcm5hbCBlcnJvci4gQ2Fubm90IHNlcmlhbGl6ZSBzdG9yYWdlIHJvb3QgaW50byBhbiBvcGVyYXRpb25cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogNCAvKiBDUkVBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJlbnRJZDogY3JkdC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudEtleTogY3JkdC5wYXJlbnRLZXksXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIE1BUCAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA3IC8qIENSRUFURV9NQVAgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvcHM7XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSBmaXJzdC51cGRhdGVzO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKHNlY29uZC51cGRhdGVzKSkge1xuICAgIHVwZGF0ZXNba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc2Vjb25kLFxuICAgIHVwZGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlTGlzdFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIHJldHVybiB7XG4gICAgLi4uc2Vjb25kLFxuICAgIHVwZGF0ZXM6IHVwZGF0ZXMuY29uY2F0KHNlY29uZC51cGRhdGVzKVxuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGlmIChmaXJzdCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHNlY29uZDtcbiAgfVxuICBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZU9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlTWFwXCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZU1hcFwiKSB7XG4gICAgcmV0dXJuIG1lcmdlTWFwU3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoZmlyc3QudHlwZSA9PT0gXCJMaXZlTGlzdFwiICYmIHNlY29uZC50eXBlID09PSBcIkxpdmVMaXN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCk7XG4gIH0gZWxzZSB7XG4gIH1cbiAgcmV0dXJuIHNlY29uZDtcbn1cbmZ1bmN0aW9uIGlzUGxhaW4odmFsdWUpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHZhbHVlLCBwYXRoID0gXCJcIikge1xuICBpZiAoIWlzUGxhaW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aCB8fCBcInJvb3RcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgbmVzdGVkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmICghaXNQbGFpbihuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IG5lc3RlZFBhdGgsXG4gICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3Qgbm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoXG4gICAgICAgIG5lc3RlZFZhbHVlLFxuICAgICAgICBuZXN0ZWRQYXRoXG4gICAgICApO1xuICAgICAgaWYgKG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcmMvbGliL2RlYnVnLnRzXG5mdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShtc2csIHRyYWNlUm9vdCkge1xuICBjb25zdCBlcnJvckxpa2UgPSB7IG5hbWU6IG1zZyB9O1xuICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yTGlrZSwgdHJhY2VSb290KTtcbiAgcmV0dXJuIGVycm9yTGlrZS5zdGFjaztcbn1cblxuLy8gc3JjL2xpYi9Kc29uLnRzXG5mdW5jdGlvbiBpc0pzb25TY2FsYXIoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZGF0YSA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBpc0pzb25BcnJheShkYXRhKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGEpO1xufVxuZnVuY3Rpb24gaXNKc29uT2JqZWN0KGRhdGEpIHtcbiAgcmV0dXJuICFpc0pzb25TY2FsYXIoZGF0YSkgJiYgIWlzSnNvbkFycmF5KGRhdGEpO1xufVxuXG4vLyBzcmMvcHJvdG9jb2wvQ2xpZW50TXNnLnRzXG52YXIgQ2xpZW50TXNnQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENsaWVudE1zZ0NvZGUyKSA9PiB7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiVVBEQVRFX1BSRVNFTkNFXCJdID0gMTAwXSA9IFwiVVBEQVRFX1BSRVNFTkNFXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiQlJPQURDQVNUX0VWRU5UXCJdID0gMTAzXSA9IFwiQlJPQURDQVNUX0VWRU5UXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiRkVUQ0hfU1RPUkFHRVwiXSA9IDIwMF0gPSBcIkZFVENIX1NUT1JBR0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfU1RPUkFHRVwiXSA9IDIwMV0gPSBcIlVQREFURV9TVE9SQUdFXCI7XG4gIENsaWVudE1zZ0NvZGUyW0NsaWVudE1zZ0NvZGUyW1wiRkVUQ0hfWURPQ1wiXSA9IDMwMF0gPSBcIkZFVENIX1lET0NcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfWURPQ1wiXSA9IDMwMV0gPSBcIlVQREFURV9ZRE9DXCI7XG4gIHJldHVybiBDbGllbnRNc2dDb2RlMjtcbn0pKENsaWVudE1zZ0NvZGUgfHwge30pO1xuXG4vLyBzcmMvcmVmcy9JbW11dGFibGVSZWYudHNcbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgcGF0Y2gpIHtcbiAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgY29uc3QgbmV3VmFsdWUgPSB7IC4uLnRhcmdldCB9O1xuICBPYmplY3Qua2V5cyhwYXRjaCkuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgY29uc3QgdmFsID0gcGF0Y2hba2V5XTtcbiAgICBpZiAobmV3VmFsdWVba2V5XSAhPT0gdmFsKSB7XG4gICAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVsZXRlIG5ld1ZhbHVlW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZVtrZXldID0gdmFsO1xuICAgICAgfVxuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHVwZGF0ZWQgPyBuZXdWYWx1ZSA6IHRhcmdldDtcbn1cbnZhciBJbW11dGFibGVSZWYgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2V2ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIH1cbiAgZ2V0IGRpZEludmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V2Lm9ic2VydmFibGU7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9ldi5ub3RpZnkoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlID8/ICh0aGlzLl9jYWNoZSA9IHRoaXMuX3RvSW1tdXRhYmxlKCkpO1xuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9PdGhlcnNSZWYudHNcbmZ1bmN0aW9uIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKSB7XG4gIGNvbnN0IHsgY29ubmVjdGlvbklkLCBpZCwgaW5mbyB9ID0gY29ubjtcbiAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoY29ubi5zY29wZXMpO1xuICByZXR1cm4gZnJlZXplKFxuICAgIGNvbXBhY3RPYmplY3Qoe1xuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgaWQsXG4gICAgICBpbmZvLFxuICAgICAgY2FuV3JpdGUsXG4gICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGNvbm4uc2NvcGVzKSxcbiAgICAgIGlzUmVhZE9ubHk6ICFjYW5Xcml0ZSxcbiAgICAgIC8vIERlcHJlY2F0ZWQsIGtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHlcbiAgICAgIHByZXNlbmNlXG4gICAgfSlcbiAgKTtcbn1cbnZhciBPdGhlcnNSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIC8vXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3ByZXNlbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fdXNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGNvbm5lY3Rpb25JZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25zLmtleXMoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCB1c2VycyA9IGNvbXBhY3QoXG4gICAgICBBcnJheS5mcm9tKHRoaXMuX3ByZXNlbmNlcy5rZXlzKCkpLm1hcChcbiAgICAgICAgKGNvbm5lY3Rpb25JZCkgPT4gdGhpcy5nZXRVc2VyKE51bWJlcihjb25uZWN0aW9uSWQpKVxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIHVzZXJzO1xuICB9XG4gIGNsZWFyT3RoZXJzKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wcmVzZW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3VzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IGNvbm4gPSB0aGlzLl9jb25uZWN0aW9ucy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBjb25zdCBwcmVzZW5jZSA9IHRoaXMuX3ByZXNlbmNlcy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBpZiAoY29ubiAhPT0gdm9pZCAwICYmIHByZXNlbmNlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBtYWtlVXNlcihjb25uLCBwcmVzZW5jZSk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZ2V0VXNlcihjb25uZWN0aW9uSWQpIHtcbiAgICBjb25zdCBjYWNoZWRVc2VyID0gdGhpcy5fdXNlcnMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNhY2hlZFVzZXIpIHtcbiAgICAgIHJldHVybiBjYWNoZWRVc2VyO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZFVzZXIgPSB0aGlzLl9nZXRVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNvbXB1dGVkVXNlcikge1xuICAgICAgdGhpcy5fdXNlcnMuc2V0KGNvbm5lY3Rpb25JZCwgY29tcHV0ZWRVc2VyKTtcbiAgICAgIHJldHVybiBjb21wdXRlZFVzZXI7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJzLmhhcyhjb25uZWN0aW9uSWQpKSB7XG4gICAgICB0aGlzLl91c2Vycy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlY29yZHMgYSBrbm93biBjb25uZWN0aW9uLiBUaGlzIHJlY29yZHMgdGhlIGNvbm5lY3Rpb24gSUQgYW5kIHRoZVxuICAgKiBhc3NvY2lhdGVkIG1ldGFkYXRhLlxuICAgKi9cbiAgc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIG1ldGFVc2VySWQsIG1ldGFVc2VySW5mbywgc2NvcGVzKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMuc2V0KFxuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgZnJlZXplKHtcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICBpZDogbWV0YVVzZXJJZCxcbiAgICAgICAgaW5mbzogbWV0YVVzZXJJbmZvLFxuICAgICAgICBzY29wZXNcbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAodGhpcy5fcHJlc2VuY2VzLmhhcyhjb25uZWN0aW9uSWQpKSB7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIGtub3duIGNvbm5lY3Rpb25JZC4gUmVtb3ZlcyBib3RoIHRoZSBjb25uZWN0aW9uJ3MgbWV0YWRhdGEgYW5kXG4gICAqIHRoZSBwcmVzZW5jZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbklkKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgdGhpcy5fcHJlc2VuY2VzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3JlcyBhIG5ldyB1c2VyIGZyb20gYSBmdWxsIHByZXNlbmNlIHVwZGF0ZS4gSWYgdGhlIHVzZXIgYWxyZWFkeSBleGlzdHMsXG4gICAqIGl0cyBrbm93biBwcmVzZW5jZSBkYXRhIGlzIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgc2V0T3RoZXIoY29ubmVjdGlvbklkLCBwcmVzZW5jZSkge1xuICAgIHRoaXMuX3ByZXNlbmNlcy5zZXQoY29ubmVjdGlvbklkLCBmcmVlemUoY29tcGFjdE9iamVjdChwcmVzZW5jZSkpKTtcbiAgICBpZiAodGhpcy5fY29ubmVjdGlvbnMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXRjaGVzIHRoZSBwcmVzZW5jZSBkYXRhIGZvciBhbiBleGlzdGluZyBcIm90aGVyXCIuIElmIHdlIGRvbid0IGtub3cgdGhlXG4gICAqIGluaXRpYWwgcHJlc2VuY2UgZGF0YSBmb3IgdGhpcyB1c2VyIHlldCwgZGlzY2FyZCB0aGlzIHBhdGNoIGFuZCBhd2FpdCB0aGVcbiAgICogZnVsbCAuc2V0T3RoZXIoKSBjYWxsIGZpcnN0LlxuICAgKi9cbiAgcGF0Y2hPdGhlcihjb25uZWN0aW9uSWQsIHBhdGNoKSB7XG4gICAgY29uc3Qgb2xkUHJlc2VuY2UgPSB0aGlzLl9wcmVzZW5jZXMuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKG9sZFByZXNlbmNlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3UHJlc2VuY2UgPSBtZXJnZShvbGRQcmVzZW5jZSwgcGF0Y2gpO1xuICAgIGlmIChvbGRQcmVzZW5jZSAhPT0gbmV3UHJlc2VuY2UpIHtcbiAgICAgIHRoaXMuX3ByZXNlbmNlcy5zZXQoY29ubmVjdGlvbklkLCBmcmVlemUobmV3UHJlc2VuY2UpKTtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9QYXRjaGFibGVSZWYudHNcbnZhciBQYXRjaGFibGVSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RhdGEgPSBmcmVlemUoY29tcGFjdE9iamVjdChkYXRhKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFBhdGNoZXMgdGhlIGN1cnJlbnQgb2JqZWN0LlxuICAgKi9cbiAgcGF0Y2gocGF0Y2gpIHtcbiAgICBjb25zdCBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBuZXdEYXRhID0gbWVyZ2Uob2xkRGF0YSwgcGF0Y2gpO1xuICAgIGlmIChvbGREYXRhICE9PSBuZXdEYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZnJlZXplKG5ld0RhdGEpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcmVmcy9WYWx1ZVJlZi50c1xudmFyIFZhbHVlUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3ZhbHVlID0gZnJlZXplKGluaXRpYWxWYWx1ZSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldChuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlID0gZnJlZXplKG5ld1ZhbHVlKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxufTtcbnZhciBEZXJpdmVkUmVmID0gY2xhc3MgZXh0ZW5kcyBJbW11dGFibGVSZWYge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1GbiA9IGFyZ3MucG9wKCk7XG4gICAgY29uc3Qgb3RoZXJSZWZzID0gYXJncztcbiAgICB0aGlzLl9yZWZzID0gb3RoZXJSZWZzO1xuICAgIHRoaXMuX3JlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICByZWYuZGlkSW52YWxpZGF0ZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5pbnZhbGlkYXRlKCkpO1xuICAgIH0pO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybUZuO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm0oXG4gICAgICAuLi50aGlzLl9yZWZzLm1hcCgocmVmKSA9PiByZWYuY3VycmVudClcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvcm9vbS50c1xudmFyIE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFID0gMTAyNCAqIDEwMjQgLSAxMDI0O1xuZnVuY3Rpb24gbWFrZUlkRmFjdG9yeShjb25uZWN0aW9uSWQpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgcmV0dXJuICgpID0+IGAke2Nvbm5lY3Rpb25JZH06JHtjb3VudCsrfWA7XG59XG5mdW5jdGlvbiB1c2VyVG9UcmVlTm9kZShrZXksIHVzZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlVzZXJcIixcbiAgICBpZDogYCR7dXNlci5jb25uZWN0aW9uSWR9YCxcbiAgICBrZXksXG4gICAgcGF5bG9hZDogdXNlclxuICB9O1xufVxuZnVuY3Rpb24gaW5zdGFsbEJhY2tncm91bmRUYWJTcHkoKSB7XG4gIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICBjb25zdCBpbkJhY2tncm91bmRTaW5jZSA9IHsgY3VycmVudDogbnVsbCB9O1xuICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgaWYgKGRvYz8udmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiKSB7XG4gICAgICBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID0gaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCA/PyBEYXRlLm5vdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZG9jPy5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICBjb25zdCB1bnN1YiA9ICgpID0+IHtcbiAgICBkb2M/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIH07XG4gIHJldHVybiBbaW5CYWNrZ3JvdW5kU2luY2UsIHVuc3ViXTtcbn1cbnZhciBDb21tZW50c0FwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRzQXBpKHJvb21JZCwgZ2V0QXV0aFZhbHVlLCBmZXRjaENsaWVudEFwaSkge1xuICBhc3luYyBmdW5jdGlvbiBmZXRjaENvbW1lbnRzQXBpKGVuZHBvaW50LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBnZXRBdXRoVmFsdWUoKTtcbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkocm9vbUlkLCBlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoSnNvbihlbmRwb2ludCwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENvbW1lbnRzQXBpKGVuZHBvaW50LCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDYwMCkge1xuICAgICAgICBsZXQgZXJyb3IzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgQ29tbWVudHNBcGlFcnJvcihcbiAgICAgICAgICAgIGVycm9yQm9keS5tZXNzYWdlLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3JCb2R5XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IENvbW1lbnRzQXBpRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjM7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBib2R5O1xuICAgIHRyeSB7XG4gICAgICBib2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgYm9keSA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gYm9keTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQ29tbWVudHNBcGkoXG4gICAgICBcIi90aHJlYWRzL3NlYXJjaFwiLFxuICAgICAge1xuICAgICAgICBzaW5jZTogb3B0aW9ucz8uc2luY2U/LnRvSVNPU3RyaW5nKClcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAuLi5vcHRpb25zPy5xdWVyeT8ubWV0YWRhdGEgJiYgeyBtZXRhZGF0YTogb3B0aW9ucy5xdWVyeS5tZXRhZGF0YSB9XG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIlxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkczoganNvbi5kYXRhLm1hcCgodGhyZWFkKSA9PiBjb252ZXJ0VG9UaHJlYWREYXRhKHRocmVhZCkpLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IGpzb24uaW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgICAobm90aWZpY2F0aW9uKSA9PiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEobm90aWZpY2F0aW9uKVxuICAgICAgICApLFxuICAgICAgICBkZWxldGVkVGhyZWFkczoganNvbi5kZWxldGVkVGhyZWFkcy5tYXAoXG4gICAgICAgICAgKGluZm8pID0+IGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8oaW5mbylcbiAgICAgICAgKSxcbiAgICAgICAgZGVsZXRlZEluYm94Tm90aWZpY2F0aW9uczoganNvbi5kZWxldGVkSW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgICAoaW5mbykgPT4gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvKGluZm8pXG4gICAgICAgICksXG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZHM6IFtdLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IFtdLFxuICAgICAgICBkZWxldGVkVGhyZWFkczogW10sXG4gICAgICAgIGRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnM6IFtdLFxuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgcmVxdWVzdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRocmVhZHMuXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWQoeyB0aHJlYWRJZCB9KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENvbW1lbnRzQXBpKFxuICAgICAgYC90aHJlYWQtd2l0aC1ub3RpZmljYXRpb24vJHt0aHJlYWRJZH1gXG4gICAgKTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWQ6IGNvbnZlcnRUb1RocmVhZERhdGEoanNvbi50aHJlYWQpLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbjoganNvbi5pbmJveE5vdGlmaWNhdGlvbiA/IGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShqc29uLmluYm94Tm90aWZpY2F0aW9uKSA6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhyZWFkICR7dGhyZWFkSWR9LmApO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUaHJlYWQoe1xuICAgIG1ldGFkYXRhLFxuICAgIGJvZHksXG4gICAgY29tbWVudElkLFxuICAgIHRocmVhZElkXG4gIH0pIHtcbiAgICBjb25zdCB0aHJlYWQgPSBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBcIi90aHJlYWRzXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaWQ6IHRocmVhZElkLFxuICAgICAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlZGl0VGhyZWFkTWV0YWRhdGEoe1xuICAgIG1ldGFkYXRhLFxuICAgIHRocmVhZElkXG4gIH0pIHtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vbWV0YWRhdGFgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21tZW50KHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgYm9keVxuICB9KSB7XG4gICAgY29uc3QgY29tbWVudCA9IGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L2NvbW1lbnRzYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlZGl0Q29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGJvZHlcbiAgfSkge1xuICAgIGNvbnN0IGNvbW1lbnQgPSBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgYm9keVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUNvbW1lbnQyKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWRcbiAgfSkge1xuICAgIGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L2NvbW1lbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBjb21tZW50SWRcbiAgICAgICl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBhZGRSZWFjdGlvbjIoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBlbW9qaVxuICB9KSB7XG4gICAgY29uc3QgcmVhY3Rpb24gPSBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfS9yZWFjdGlvbnNgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbW9qaSB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24ocmVhY3Rpb24pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVJlYWN0aW9uMih7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGVtb2ppXG4gIH0pIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9jb21tZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY29tbWVudElkXG4gICAgICApfS9yZWFjdGlvbnMvJHtlbmNvZGVVUklDb21wb25lbnQoZW1vamkpfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJERUxFVEVcIlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRUaHJlYWRzLFxuICAgIGdldFRocmVhZCxcbiAgICBjcmVhdGVUaHJlYWQsXG4gICAgZWRpdFRocmVhZE1ldGFkYXRhLFxuICAgIGNyZWF0ZUNvbW1lbnQsXG4gICAgZWRpdENvbW1lbnQsXG4gICAgZGVsZXRlQ29tbWVudDogZGVsZXRlQ29tbWVudDIsXG4gICAgYWRkUmVhY3Rpb246IGFkZFJlYWN0aW9uMixcbiAgICByZW1vdmVSZWFjdGlvbjogcmVtb3ZlUmVhY3Rpb24yXG4gIH07XG59XG52YXIgTUFSS19JTkJPWF9OT1RJRklDQVRJT05TX0FTX1JFQURfQkFUQ0hfREVMQVkyID0gNTA7XG5mdW5jdGlvbiBjcmVhdGVSb29tKG9wdGlvbnMsIGNvbmZpZykge1xuICBjb25zdCBpbml0aWFsUHJlc2VuY2UgPSB0eXBlb2Ygb3B0aW9ucy5pbml0aWFsUHJlc2VuY2UgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuaW5pdGlhbFByZXNlbmNlKGNvbmZpZy5yb29tSWQpIDogb3B0aW9ucy5pbml0aWFsUHJlc2VuY2U7XG4gIGNvbnN0IGluaXRpYWxTdG9yYWdlID0gdHlwZW9mIG9wdGlvbnMuaW5pdGlhbFN0b3JhZ2UgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuaW5pdGlhbFN0b3JhZ2UoY29uZmlnLnJvb21JZCkgOiBvcHRpb25zLmluaXRpYWxTdG9yYWdlO1xuICBjb25zdCBbaW5CYWNrZ3JvdW5kU2luY2UsIHVuaW5zdGFsbEJnVGFiU3B5XSA9IGluc3RhbGxCYWNrZ3JvdW5kVGFiU3B5KCk7XG4gIGNvbnN0IGRlbGVnYXRlcyA9IHtcbiAgICAuLi5jb25maWcuZGVsZWdhdGVzLFxuICAgIC8vIEEgY29ubmVjdGlvbiBpcyBhbGxvd2VkIHRvIGdvIGludG8gXCJ6b21iaWUgc3RhdGVcIiBvbmx5IGlmIGFsbCBvZiB0aGVcbiAgICAvLyBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcHBseTpcbiAgICAvL1xuICAgIC8vIC0gVGhlIGBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dGAgY2xpZW50IG9wdGlvbiBpcyBjb25maWd1cmVkXG4gICAgLy8gLSBUaGUgYnJvd3NlciB3aW5kb3cgaGFzIGJlZW4gaW4gdGhlIGJhY2tncm91bmQgZm9yIGF0IGxlYXN0XG4gICAgLy8gICBgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRgIG1pbGxpc2Vjb25kc1xuICAgIC8vIC0gVGhlcmUgYXJlIG5vIHBlbmRpbmcgY2hhbmdlc1xuICAgIC8vXG4gICAgY2FuWm9tYmllKCkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCAhPT0gdm9pZCAwICYmIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgIT09IG51bGwgJiYgRGF0ZS5ub3coKSA+IGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgKyBjb25maWcuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgJiYgZ2V0U3RvcmFnZVN0YXR1cygpICE9PSBcInN5bmNocm9uaXppbmdcIjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1hbmFnZWRTb2NrZXQgPSBuZXcgTWFuYWdlZFNvY2tldChcbiAgICBkZWxlZ2F0ZXMsXG4gICAgY29uZmlnLmVuYWJsZURlYnVnTG9nZ2luZ1xuICApO1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIGJ1ZmZlcjoge1xuICAgICAgZmx1c2hUaW1lcklEOiB2b2lkIDAsXG4gICAgICBsYXN0Rmx1c2hlZEF0OiAwLFxuICAgICAgcHJlc2VuY2VVcGRhdGVzOiAoXG4gICAgICAgIC8vIFF1ZXVlIHVwIHRoZSBpbml0aWFsIHByZXNlbmNlIG1lc3NhZ2UgYXMgYSBGdWxsIFByZXNlbmNl4oSiIHVwZGF0ZVxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJmdWxsXCIsXG4gICAgICAgICAgZGF0YTogaW5pdGlhbFByZXNlbmNlXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBtZXNzYWdlczogW10sXG4gICAgICBzdG9yYWdlT3BlcmF0aW9uczogW11cbiAgICB9LFxuICAgIHN0YXRpY1Nlc3Npb25JbmZvOiBuZXcgVmFsdWVSZWYobnVsbCksXG4gICAgZHluYW1pY1Nlc3Npb25JbmZvOiBuZXcgVmFsdWVSZWYobnVsbCksXG4gICAgbXlQcmVzZW5jZTogbmV3IFBhdGNoYWJsZVJlZihpbml0aWFsUHJlc2VuY2UpLFxuICAgIG90aGVyczogbmV3IE90aGVyc1JlZigpLFxuICAgIGluaXRpYWxTdG9yYWdlLFxuICAgIGlkRmFjdG9yeTogbnVsbCxcbiAgICAvLyBTdG9yYWdlXG4gICAgY2xvY2s6IDAsXG4gICAgb3BDbG9jazogMCxcbiAgICBub2RlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICByb290OiB2b2lkIDAsXG4gICAgdW5kb1N0YWNrOiBbXSxcbiAgICByZWRvU3RhY2s6IFtdLFxuICAgIHBhdXNlZEhpc3Rvcnk6IG51bGwsXG4gICAgYWN0aXZlQmF0Y2g6IG51bGwsXG4gICAgdW5hY2tub3dsZWRnZWRPcHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgLy8gRGVidWdcbiAgICBvcFN0YWNrVHJhY2VzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpIDogdm9pZCAwXG4gIH07XG4gIGNvbnN0IGRvTm90QmF0Y2hVcGRhdGVzID0gKGNiKSA9PiBjYigpO1xuICBjb25zdCBiYXRjaFVwZGF0ZXMgPSBjb25maWcudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPz8gZG9Ob3RCYXRjaFVwZGF0ZXM7XG4gIGxldCBsYXN0VG9rZW5LZXk7XG4gIGZ1bmN0aW9uIG9uU3RhdHVzRGlkQ2hhbmdlKG5ld1N0YXR1cykge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlO1xuICAgIGlmIChhdXRoVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRva2VuS2V5ID0gZ2V0QXV0aEJlYXJlckhlYWRlckZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKTtcbiAgICAgIGlmICh0b2tlbktleSAhPT0gbGFzdFRva2VuS2V5KSB7XG4gICAgICAgIGxhc3RUb2tlbktleSA9IHRva2VuS2V5O1xuICAgICAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIpIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IGF1dGhWYWx1ZS50b2tlbi5wYXJzZWQ7XG4gICAgICAgICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mby5zZXQoe1xuICAgICAgICAgICAgdXNlcklkOiB0b2tlbi5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovID8gdG9rZW4uaWQgOiB0b2tlbi51aWQsXG4gICAgICAgICAgICB1c2VySW5mbzogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmluZm8gOiB0b2tlbi51aVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm8uc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdm9pZCAwLFxuICAgICAgICAgICAgdXNlckluZm86IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBldmVudEh1Yi5zdGF0dXMubm90aWZ5KG5ld1N0YXR1cyk7XG4gICAgICBub3RpZnlTZWxmQ2hhbmdlZChkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gIH1cbiAgbGV0IF9jb25uZWN0aW9uTG9zc1RpbWVySWQ7XG4gIGxldCBfaGFzTG9zdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgZnVuY3Rpb24gaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudChuZXdTdGF0dXMpIHtcbiAgICBpZiAobmV3U3RhdHVzID09PSBcInJlY29ubmVjdGluZ1wiKSB7XG4gICAgICBfY29ubmVjdGlvbkxvc3NUaW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwibG9zdFwiKTtcbiAgICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGNvbnRleHQub3RoZXJzLmNsZWFyT3RoZXJzKCk7XG4gICAgICAgICAgbm90aWZ5KHsgb3RoZXJzOiBbeyB0eXBlOiBcInJlc2V0XCIgfV0gfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGNvbmZpZy5sb3N0Q29ubmVjdGlvblRpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZCk7XG4gICAgICBpZiAoX2hhc0xvc3RDb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChuZXdTdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwiZmFpbGVkXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJyZXN0b3JlZFwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfaGFzTG9zdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25EaWRDb25uZWN0KCkge1xuICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHtcbiAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgZGF0YTogKFxuICAgICAgICAvLyBCZWNhdXNlIGNvbnRleHQubWUuY3VycmVudCBpcyBhIHJlYWRvbmx5IG9iamVjdCwgd2UnbGwgaGF2ZSB0b1xuICAgICAgICAvLyBtYWtlIGEgY29weSBoZXJlLiBPdGhlcndpc2UsIHR5cGUgZXJyb3JzIGhhcHBlbiBsYXRlciB3aGVuXG4gICAgICAgIC8vIFwicGF0Y2hpbmdcIiBteSBwcmVzZW5jZS5cbiAgICAgICAgeyAuLi5jb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCB9XG4gICAgICApXG4gICAgfTtcbiAgICBpZiAoX2dldFN0b3JhZ2UkICE9PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRpZERpc2Nvbm5lY3QoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gIH1cbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25NZXNzYWdlLnN1YnNjcmliZShoYW5kbGVTZXJ2ZXJNZXNzYWdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShvblN0YXR1c0RpZENoYW5nZSk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLnN0YXR1c0RpZENoYW5nZS5zdWJzY3JpYmUoaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZENvbm5lY3Quc3Vic2NyaWJlKG9uRGlkQ29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZERpc2Nvbm5lY3Quc3Vic2NyaWJlKG9uRGlkRGlzY29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLm9uTGl2ZWJsb2Nrc0Vycm9yLnN1YnNjcmliZSgoZXJyKSA9PiB7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZXJyb3IyKFxuICAgICAgICAgIGBDb25uZWN0aW9uIHRvIHdlYnNvY2tldCBzZXJ2ZXIgY2xvc2VkLiBSZWFzb246ICR7ZXJyLm1lc3NhZ2V9IChjb2RlOiAke2Vyci5jb2RlfSkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZXZlbnRIdWIuZXJyb3Iubm90aWZ5KGVycik7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBwb29sID0ge1xuICAgIHJvb21JZDogY29uZmlnLnJvb21JZCxcbiAgICBnZXROb2RlOiAoaWQpID0+IGNvbnRleHQubm9kZXMuZ2V0KGlkKSxcbiAgICBhZGROb2RlOiAoaWQsIG5vZGUpID0+IHZvaWQgY29udGV4dC5ub2Rlcy5zZXQoaWQsIG5vZGUpLFxuICAgIGRlbGV0ZU5vZGU6IChpZCkgPT4gdm9pZCBjb250ZXh0Lm5vZGVzLmRlbGV0ZShpZCksXG4gICAgZ2VuZXJhdGVJZDogKCkgPT4gYCR7Z2V0Q29ubmVjdGlvbklkKCl9OiR7Y29udGV4dC5jbG9jaysrfWAsXG4gICAgZ2VuZXJhdGVPcElkOiAoKSA9PiBgJHtnZXRDb25uZWN0aW9uSWQoKX06JHtjb250ZXh0Lm9wQ2xvY2srK31gLFxuICAgIGRpc3BhdGNoKG9wcywgcmV2ZXJzZSwgc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhY2tUcmFjZSA9IGNhcHR1cmVTdGFja1RyYWNlKFwiU3RvcmFnZSBtdXRhdGlvblwiLCB0aGlzLmRpc3BhdGNoKTtcbiAgICAgICAgaWYgKHN0YWNrVHJhY2UpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgICAgICAgaWYgKG9wLm9wSWQpIHtcbiAgICAgICAgICAgICAgbm4oY29udGV4dC5vcFN0YWNrVHJhY2VzKS5zZXQob3Aub3BJZCwgc3RhY2tUcmFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlQmF0Y2gpIHtcbiAgICAgICAgYWN0aXZlQmF0Y2gub3BzLnB1c2goLi4ub3BzKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICBhY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgIGFjdGl2ZUJhdGNoLnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuZ2V0KGtleSksXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnVuc2hpZnQoLi4ucmV2ZXJzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKHJldmVyc2UsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICAgICAgICAgIGRpc3BhdGNoT3BzKG9wcyk7XG4gICAgICAgICAgbm90aWZ5KHsgc3RvcmFnZVVwZGF0ZXMgfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlOiAoKSA9PiB7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50Py5zY29wZXM7XG4gICAgICBpZiAoc2NvcGVzID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKTtcbiAgICAgIGlmICghY2FuV3JpdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ2Fubm90IHdyaXRlIHRvIHN0b3JhZ2Ugd2l0aCBhIHJlYWQgb25seSB1c2VyLCBwbGVhc2UgZW5zdXJlIHRoZSB1c2VyIGhhcyB3cml0ZSBwZXJtaXNzaW9uc1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBldmVudEh1YiA9IHtcbiAgICBjb25uZWN0aW9uOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAvLyBPbGQvZGVwcmVjYXRlZCBBUElcbiAgICBzdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIE5ldy9yZWNvbW1lbmRlZCBBUElcbiAgICBsb3N0Q29ubmVjdGlvbjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgY3VzdG9tRXZlbnQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHNlbGY6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG15UHJlc2VuY2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIG90aGVyczogbWFrZUV2ZW50U291cmNlKCksXG4gICAgZXJyb3I6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGhpc3Rvcnk6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VEaWRMb2FkOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzdG9yYWdlU3RhdHVzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICB5ZG9jOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBjb21tZW50czogbWFrZUV2ZW50U291cmNlKClcbiAgfTtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDbGllbnRBcGkocm9vbUlkLCBlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zMiwgcGFyYW1zKSB7XG4gICAgY29uc3QgdXJsID0gdXJsam9pbihcbiAgICAgIGNvbmZpZy5iYXNlVXJsLFxuICAgICAgYC92Mi9jL3Jvb21zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHJvb21JZCl9JHtlbmRwb2ludH1gLFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgICBjb25zdCBmZXRjaGVyID0gY29uZmlnLnBvbHlmaWxscz8uZmV0Y2ggfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmZXRjaDtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hlcih1cmwsIHtcbiAgICAgIC4uLm9wdGlvbnMyLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5vcHRpb25zMj8uaGVhZGVycyxcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2dldEF1dGhCZWFyZXJIZWFkZXJGcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSl9YFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbUZldGNoKGF1dGhWYWx1ZSwgcm9vbUlkKSB7XG4gICAgcmV0dXJuIGZldGNoQ2xpZW50QXBpKHJvb21JZCwgXCIvc3RvcmFnZVwiLCBhdXRoVmFsdWUsIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBodHRwUG9zdFRvUm9vbShlbmRwb2ludCwgYm9keSkge1xuICAgIGlmICghbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhdXRob3JpemVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkoY29uZmlnLnJvb21JZCwgZW5kcG9pbnQsIG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShtZXNzYWdlcyk7XG4gICAgY29uc3Qgbm9uY2UgPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mby5jdXJyZW50Py5ub25jZTtcbiAgICBpZiAoY29uZmlnLnVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQICYmIG5vbmNlKSB7XG4gICAgICBjb25zdCBzaXplID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlcmlhbGl6ZWRQYXlsb2FkKS5sZW5ndGg7XG4gICAgICBpZiAoc2l6ZSA+IE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFKSB7XG4gICAgICAgIHZvaWQgaHR0cFBvc3RUb1Jvb20oXCIvc2VuZC1tZXNzYWdlXCIsIHsgbm9uY2UsIG1lc3NhZ2VzIH0pLnRoZW4oXG4gICAgICAgICAgKHJlc3ApID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzcC5vayAmJiByZXNwLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICAgIG1hbmFnZWRTb2NrZXQucmVjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWVzc2FnZSB3YXMgdG9vIGxhcmdlIGZvciB3ZWJzb2NrZXRzIGFuZCBzZW50IG92ZXIgSFRUUCBpbnN0ZWFkXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBtYW5hZ2VkU29ja2V0LnNlbmQoc2VyaWFsaXplZFBheWxvYWQpO1xuICB9XG4gIGNvbnN0IHNlbGYgPSBuZXcgRGVyaXZlZFJlZihcbiAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvLFxuICAgIGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLFxuICAgIGNvbnRleHQubXlQcmVzZW5jZSxcbiAgICAoc3RhdGljU2Vzc2lvbiwgZHluYW1pY1Nlc3Npb24sIG15UHJlc2VuY2UpID0+IHtcbiAgICAgIGlmIChzdGF0aWNTZXNzaW9uID09PSBudWxsIHx8IGR5bmFtaWNTZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoZHluYW1pY1Nlc3Npb24uc2NvcGVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb25uZWN0aW9uSWQ6IGR5bmFtaWNTZXNzaW9uLmFjdG9yLFxuICAgICAgICAgIGlkOiBzdGF0aWNTZXNzaW9uLnVzZXJJZCxcbiAgICAgICAgICBpbmZvOiBzdGF0aWNTZXNzaW9uLnVzZXJJbmZvLFxuICAgICAgICAgIHByZXNlbmNlOiBteVByZXNlbmNlLFxuICAgICAgICAgIGNhbldyaXRlLFxuICAgICAgICAgIGNhbkNvbW1lbnQ6IGNhbkNvbW1lbnQoZHluYW1pY1Nlc3Npb24uc2NvcGVzKSxcbiAgICAgICAgICBpc1JlYWRPbmx5OiAhY2FuV3JpdGVcbiAgICAgICAgICAvLyBEZXByZWNhdGVkLCBrZXB0IGZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICApO1xuICBsZXQgX2xhc3RTZWxmO1xuICBmdW5jdGlvbiBub3RpZnlTZWxmQ2hhbmdlZChiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBjb25zdCBjdXJyU2VsZiA9IHNlbGYuY3VycmVudDtcbiAgICBpZiAoY3VyclNlbGYgIT09IG51bGwgJiYgY3VyclNlbGYgIT09IF9sYXN0U2VsZikge1xuICAgICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgICAgZXZlbnRIdWIuc2VsZi5ub3RpZnkoY3VyclNlbGYpO1xuICAgICAgfSk7XG4gICAgICBfbGFzdFNlbGYgPSBjdXJyU2VsZjtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2VsZkFzVHJlZU5vZGUgPSBuZXcgRGVyaXZlZFJlZihcbiAgICBzZWxmLFxuICAgIChtZSkgPT4gbWUgIT09IG51bGwgPyB1c2VyVG9UcmVlTm9kZShcIk1lXCIsIG1lKSA6IG51bGxcbiAgKTtcbiAgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVSb290RnJvbU1lc3NhZ2UobWVzc2FnZSwgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKG1lc3NhZ2UuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogY2Fubm90IGxvYWQgc3RvcmFnZSB3aXRob3V0IGl0ZW1zXCIpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5yb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHVwZGF0ZVJvb3QobWVzc2FnZS5pdGVtcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5yb290ID0gTGl2ZU9iamVjdC5fZnJvbUl0ZW1zKG1lc3NhZ2UuaXRlbXMsIHBvb2wpO1xuICAgIH1cbiAgICBjb25zdCBzdGFja1NpemVCZWZvcmUgPSBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGg7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29udGV4dC5pbml0aWFsU3RvcmFnZSkge1xuICAgICAgaWYgKGNvbnRleHQucm9vdC5nZXQoa2V5KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRleHQucm9vdC5zZXQoa2V5LCBjbG9uZUxzb24oY29udGV4dC5pbml0aWFsU3RvcmFnZVtrZXldKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA9IHN0YWNrU2l6ZUJlZm9yZTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSb290KGl0ZW1zLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAoY29udGV4dC5yb290ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgbm9kZV0gb2YgY29udGV4dC5ub2Rlcykge1xuICAgICAgY3VycmVudEl0ZW1zLnNldChpZCwgbm9kZS5fc2VyaWFsaXplKCkpO1xuICAgIH1cbiAgICBjb25zdCBvcHMgPSBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3IE1hcChpdGVtcykpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKG9wcywgZmFsc2UpO1xuICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgfVxuICBmdW5jdGlvbiBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPj0gNTApIHtcbiAgICAgIGNvbnRleHQudW5kb1N0YWNrLnNoaWZ0KCk7XG4gICAgfVxuICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2goaGlzdG9yeU9wcyk7XG4gICAgb25IaXN0b3J5Q2hhbmdlKGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gIH1cbiAgZnVuY3Rpb24gYWRkVG9VbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKGNvbnRleHQucGF1c2VkSGlzdG9yeSAhPT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wYXVzZWRIaXN0b3J5LnVuc2hpZnQoLi4uaGlzdG9yeU9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KHVwZGF0ZXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gdXBkYXRlcy5zdG9yYWdlVXBkYXRlcztcbiAgICBjb25zdCBvdGhlcnNVcGRhdGVzID0gdXBkYXRlcy5vdGhlcnM7XG4gICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgIGlmIChvdGhlcnNVcGRhdGVzICE9PSB2b2lkIDAgJiYgb3RoZXJzVXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG90aGVycyA9IGNvbnRleHQub3RoZXJzLmN1cnJlbnQ7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2Ygb3RoZXJzVXBkYXRlcykge1xuICAgICAgICAgIGV2ZW50SHViLm90aGVycy5ub3RpZnkoeyAuLi5ldmVudCwgb3RoZXJzIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlcy5wcmVzZW5jZSA/PyBmYWxzZSkge1xuICAgICAgICBub3RpZnlTZWxmQ2hhbmdlZChkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIGV2ZW50SHViLm15UHJlc2VuY2Uubm90aWZ5KGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdG9yYWdlVXBkYXRlcyAhPT0gdm9pZCAwICYmIHN0b3JhZ2VVcGRhdGVzLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMyID0gQXJyYXkuZnJvbShzdG9yYWdlVXBkYXRlcy52YWx1ZXMoKSk7XG4gICAgICAgIGV2ZW50SHViLnN0b3JhZ2Uubm90aWZ5KHVwZGF0ZXMyKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDb25uZWN0aW9uSWQoKSB7XG4gICAgY29uc3QgaW5mbyA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLmN1cnJlbnQ7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmFjdG9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludGVybmFsLiBUcmllZCB0byBnZXQgY29ubmVjdGlvbiBpZCBidXQgY29ubmVjdGlvbiB3YXMgbmV2ZXIgb3BlblwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wcyhyYXdPcHMsIGlzTG9jYWwpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICByZXZlcnNlOiBbXSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgcHJlc2VuY2U6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVkTm9kZUlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgb3BzID0gcmF3T3BzLm1hcCgob3ApID0+IHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIgJiYgIW9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ub3AsIG9wSWQ6IHBvb2wuZ2VuZXJhdGVPcElkKCkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgPT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb25zdCByZXZlcnNlID0ge1xuICAgICAgICAgIHR5cGU6IFwicHJlc2VuY2VcIixcbiAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgcmV2ZXJzZS5kYXRhW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubXlQcmVzZW5jZS5wYXRjaChvcC5kYXRhKTtcbiAgICAgICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHsgdHlwZTogXCJwYXJ0aWFsXCIsIGRhdGE6IG9wLmRhdGEgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVtrZXldID0gb3AuZGF0YVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucmV2ZXJzZS51bnNoaWZ0KHJldmVyc2UpO1xuICAgICAgICBvdXRwdXQucHJlc2VuY2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHNvdXJjZTtcbiAgICAgICAgaWYgKGlzTG9jYWwpIHtcbiAgICAgICAgICBzb3VyY2UgPSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvcElkID0gbm4ob3Aub3BJZCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgbm4oY29udGV4dC5vcFN0YWNrVHJhY2VzKS5kZWxldGUob3BJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLmRlbGV0ZShvcElkKTtcbiAgICAgICAgICBzb3VyY2UgPSBkZWxldGVkID8gMiAvKiBBQ0sgKi8gOiAxIC8qIFJFTU9URSAqLztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBseU9wUmVzdWx0ID0gYXBwbHlPcChvcCwgc291cmNlKTtcbiAgICAgICAgaWYgKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQpIHtcbiAgICAgICAgICBjb25zdCBub2RlSWQgPSBhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkO1xuICAgICAgICAgIGlmICghKG5vZGVJZCAmJiBjcmVhdGVkTm9kZUlkcy5oYXMobm9kZUlkKSkpIHtcbiAgICAgICAgICAgIG91dHB1dC5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICAgIG5uKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQpLFxuICAgICAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKFxuICAgICAgICAgICAgICAgIG91dHB1dC5zdG9yYWdlVXBkYXRlcy5nZXQobm4oYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZCkpLFxuICAgICAgICAgICAgICAgIGFwcGx5T3BSZXN1bHQubW9kaWZpZWRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG91dHB1dC5yZXZlcnNlLnVuc2hpZnQoLi4uYXBwbHlPcFJlc3VsdC5yZXZlcnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wLnR5cGUgPT09IDIgLyogQ1JFQVRFX0xJU1QgKi8gfHwgb3AudHlwZSA9PT0gNyAvKiBDUkVBVEVfTUFQICovIHx8IG9wLnR5cGUgPT09IDQgLyogQ1JFQVRFX09CSkVDVCAqLykge1xuICAgICAgICAgICAgY3JlYXRlZE5vZGVJZHMuYWRkKG5uKG9wLmlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvcHMsXG4gICAgICByZXZlcnNlOiBvdXRwdXQucmV2ZXJzZSxcbiAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXM6IG91dHB1dC5zdG9yYWdlVXBkYXRlcyxcbiAgICAgICAgcHJlc2VuY2U6IG91dHB1dC5wcmVzZW5jZVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlPcChvcCwgc291cmNlKSB7XG4gICAgaWYgKGlzQWNrT3Aob3ApKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlIDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi86XG4gICAgICBjYXNlIDMgLyogVVBEQVRFX09CSkVDVCAqLzpcbiAgICAgIGNhc2UgNSAvKiBERUxFVEVfQ1JEVCAqLzoge1xuICAgICAgICBjb25zdCBub2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuX2FwcGx5KG9wLCBzb3VyY2UgPT09IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgMSAvKiBTRVRfUEFSRU5UX0tFWSAqLzoge1xuICAgICAgICBjb25zdCBub2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIgJiYgaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudC5ub2RlLl9zZXRDaGlsZEtleShcbiAgICAgICAgICAgIGFzUG9zKG9wLnBhcmVudEtleSksXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgNCAvKiBDUkVBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSAyIC8qIENSRUFURV9MSVNUICovOlxuICAgICAgY2FzZSA3IC8qIENSRUFURV9NQVAgKi86XG4gICAgICBjYXNlIDggLyogQ1JFQVRFX1JFR0lTVEVSICovOiB7XG4gICAgICAgIGlmIChvcC5wYXJlbnRJZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNvbnRleHQubm9kZXMuZ2V0KG9wLnBhcmVudElkKTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnROb2RlLl9hdHRhY2hDaGlsZChvcCwgc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUHJlc2VuY2UocGF0Y2gsIG9wdGlvbnMyKSB7XG4gICAgY29uc3Qgb2xkVmFsdWVzID0ge307XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0ge1xuICAgICAgICB0eXBlOiBcInBhcnRpYWxcIixcbiAgICAgICAgZGF0YToge31cbiAgICAgIH07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICBjb25zdCBvdmVycmlkZVZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgIGlmIChvdmVycmlkZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVtrZXldID0gb3ZlcnJpZGVWYWx1ZTtcbiAgICAgIG9sZFZhbHVlc1trZXldID0gY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnRba2V5XTtcbiAgICB9XG4gICAgY29udGV4dC5teVByZXNlbmNlLnBhdGNoKHBhdGNoKTtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgaWYgKG9wdGlvbnMyPy5hZGRUb0hpc3RvcnkpIHtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnVuc2hpZnQoe1xuICAgICAgICAgIHR5cGU6IFwicHJlc2VuY2VcIixcbiAgICAgICAgICBkYXRhOiBvbGRWYWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoLnVwZGF0ZXMucHJlc2VuY2UgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMyPy5hZGRUb0hpc3RvcnkpIHtcbiAgICAgICAgICBhZGRUb1VuZG9TdGFjayhcbiAgICAgICAgICAgIFt7IHR5cGU6IFwicHJlc2VuY2VcIiwgZGF0YTogb2xkVmFsdWVzIH1dLFxuICAgICAgICAgICAgZG9Ob3RCYXRjaFVwZGF0ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmeSh7IHByZXNlbmNlOiB0cnVlIH0sIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVwZGF0ZVByZXNlbmNlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UudGFyZ2V0QWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qgb2xkVXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBjb250ZXh0Lm90aGVycy5zZXRPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgY29uc3QgbmV3VXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBpZiAob2xkVXNlciA9PT0gdm9pZCAwICYmIG5ld1VzZXIgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVudGVyXCIsIHVzZXI6IG5ld1VzZXIgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5vdGhlcnMucGF0Y2hPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpLCBtZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgdXBkYXRlczogbWVzc2FnZS5kYXRhLFxuICAgICAgICB1c2VyXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGNvbnRleHQub3RoZXJzLnJlbW92ZUNvbm5lY3Rpb24obWVzc2FnZS5hY3Rvcik7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImxlYXZlXCIsIHVzZXIgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gb25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLnNldCh7XG4gICAgICBhY3RvcjogbWVzc2FnZS5hY3RvcixcbiAgICAgIG5vbmNlOiBtZXNzYWdlLm5vbmNlLFxuICAgICAgc2NvcGVzOiBtZXNzYWdlLnNjb3Blc1xuICAgIH0pO1xuICAgIGNvbnRleHQuaWRGYWN0b3J5ID0gbWFrZUlkRmFjdG9yeShtZXNzYWdlLmFjdG9yKTtcbiAgICBub3RpZnlTZWxmQ2hhbmdlZChiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIGZvciAoY29uc3QgY29ubmVjdGlvbklkIG9mIGNvbnRleHQub3RoZXJzLmNvbm5lY3Rpb25JZHMoKSkge1xuICAgICAgY29uc3QgdXNlciA9IG1lc3NhZ2UudXNlcnNbY29ubmVjdGlvbklkXTtcbiAgICAgIGlmICh1c2VyID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGV4dC5vdGhlcnMucmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXNzYWdlLnVzZXJzKSB7XG4gICAgICBjb25zdCB1c2VyID0gbWVzc2FnZS51c2Vyc1trZXldO1xuICAgICAgY29uc3QgY29ubmVjdGlvbklkID0gTnVtYmVyKGtleSk7XG4gICAgICBjb250ZXh0Lm90aGVycy5zZXRDb25uZWN0aW9uKFxuICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgIHVzZXIuaWQsXG4gICAgICAgIHVzZXIuaW5mbyxcbiAgICAgICAgdXNlci5zY29wZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwicmVzZXRcIiB9O1xuICB9XG4gIGZ1bmN0aW9uIGNhblVuZG8oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA+IDA7XG4gIH1cbiAgZnVuY3Rpb24gY2FuUmVkbygpIHtcbiAgICByZXR1cm4gY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBvbkhpc3RvcnlDaGFuZ2UoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKCgpID0+IHtcbiAgICAgIGV2ZW50SHViLmhpc3Rvcnkubm90aWZ5KHsgY2FuVW5kbzogY2FuVW5kbygpLCBjYW5SZWRvOiBjYW5SZWRvKCkgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gb25Vc2VySm9pbmVkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29udGV4dC5vdGhlcnMuc2V0Q29ubmVjdGlvbihcbiAgICAgIG1lc3NhZ2UuYWN0b3IsXG4gICAgICBtZXNzYWdlLmlkLFxuICAgICAgbWVzc2FnZS5pbmZvLFxuICAgICAgbWVzc2FnZS5zY29wZXNcbiAgICApO1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgIGRhdGE6IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50LFxuICAgICAgdGFyZ2V0QWN0b3I6IG1lc3NhZ2UuYWN0b3JcbiAgICB9KTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICAgIGNvbnN0IHVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgIHJldHVybiB1c2VyID8geyB0eXBlOiBcImVudGVyXCIsIHVzZXIgfSA6IHZvaWQgMDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVNlcnZlck1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICghaXNKc29uT2JqZWN0KGRhdGEpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTZXJ2ZXJNZXNzYWdlcyh0ZXh0KSB7XG4gICAgY29uc3QgZGF0YSA9IHRyeVBhcnNlSnNvbih0ZXh0KTtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGlzSnNvbkFycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm4gY29tcGFjdChkYXRhLm1hcCgoaXRlbSkgPT4gcGFyc2VTZXJ2ZXJNZXNzYWdlKGl0ZW0pKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb21wYWN0KFtwYXJzZVNlcnZlck1lc3NhZ2UoZGF0YSldKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlBbmRTZW5kT3BzKG9mZmxpbmVPcHMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChvZmZsaW5lT3BzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBjb25zdCBvcHMgPSBBcnJheS5mcm9tKG9mZmxpbmVPcHMudmFsdWVzKCkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKG9wcywgdHJ1ZSk7XG4gICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi8sXG4gICAgICBvcHM6IHJlc3VsdC5vcHNcbiAgICB9KTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVTZXJ2ZXJNZXNzYWdlKGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gcGFyc2VTZXJ2ZXJNZXNzYWdlcyhldmVudC5kYXRhKTtcbiAgICBpZiAobWVzc2FnZXMgPT09IG51bGwgfHwgbWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZXMgPSB7XG4gICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIG90aGVyczogW11cbiAgICB9O1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIDEwMSAvKiBVU0VSX0pPSU5FRCAqLzoge1xuICAgICAgICAgICAgY29uc3QgdXNlckpvaW5lZFVwZGF0ZSA9IG9uVXNlckpvaW5lZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodXNlckpvaW5lZFVwZGF0ZSkge1xuICAgICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKHVzZXJKb2luZWRVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLzoge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJzUHJlc2VuY2VVcGRhdGUgPSBvblVwZGF0ZVByZXNlbmNlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChvdGhlcnNQcmVzZW5jZVVwZGF0ZSkge1xuICAgICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG90aGVyc1ByZXNlbmNlVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwMyAvKiBCUk9BRENBU1RFRF9FVkVOVCAqLzoge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJzID0gY29udGV4dC5vdGhlcnMuY3VycmVudDtcbiAgICAgICAgICAgIGV2ZW50SHViLmN1c3RvbUV2ZW50Lm5vdGlmeSh7XG4gICAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogbWVzc2FnZS5hY3RvcixcbiAgICAgICAgICAgICAgdXNlcjogbWVzc2FnZS5hY3RvciA8IDAgPyBudWxsIDogb3RoZXJzLmZpbmQoKHUpID0+IHUuY29ubmVjdGlvbklkID09PSBtZXNzYWdlLmFjdG9yKSA/PyBudWxsLFxuICAgICAgICAgICAgICBldmVudDogbWVzc2FnZS5ldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDIgLyogVVNFUl9MRUZUICovOiB7XG4gICAgICAgICAgICBjb25zdCBldmVudDIgPSBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChldmVudDIpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5vdGhlcnMucHVzaChldmVudDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMzAwIC8qIFVQREFURV9ZRE9DICovOiB7XG4gICAgICAgICAgICBldmVudEh1Yi55ZG9jLm5vdGlmeShtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwNCAvKiBST09NX1NUQVRFICovOiB7XG4gICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG9uUm9vbVN0YXRlTWVzc2FnZShtZXNzYWdlLCBkb05vdEJhdGNoVXBkYXRlcykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjAwIC8qIElOSVRJQUxfU1RPUkFHRV9TVEFURSAqLzoge1xuICAgICAgICAgICAgcHJvY2Vzc0luaXRpYWxTdG9yYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjAxIC8qIFVQREFURV9TVE9SQUdFICovOiB7XG4gICAgICAgICAgICBjb25zdCBhcHBseVJlc3VsdCA9IGFwcGx5T3BzKG1lc3NhZ2Uub3BzLCBmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhcHBseVJlc3VsdC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuZ2V0KGtleSksIHZhbHVlKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMjk5IC8qIFJFSkVDVF9TVE9SQUdFX09QICovOiB7XG4gICAgICAgICAgICBlcnJvcldpdGhUaXRsZShcbiAgICAgICAgICAgICAgXCJTdG9yYWdlIG11dGF0aW9uIHJlamVjdGlvbiBlcnJvclwiLFxuICAgICAgICAgICAgICBtZXNzYWdlLnJlYXNvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHJhY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBvcElkIG9mIG1lc3NhZ2Uub3BJZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjZSA9IGNvbnRleHQub3BTdGFja1RyYWNlcz8uZ2V0KG9wSWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFjZSkge1xuICAgICAgICAgICAgICAgICAgdHJhY2VzLmFkZCh0cmFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0cmFjZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB3YXJuV2l0aFRpdGxlKFxuICAgICAgICAgICAgICAgICAgXCJUaGUgZm9sbG93aW5nIGZ1bmN0aW9uIGNhbGxzIGNhdXNlZCB0aGUgcmVqZWN0ZWQgc3RvcmFnZSBtdXRhdGlvbnM6XCIsXG4gICAgICAgICAgICAgICAgICBgXG5cbiR7QXJyYXkuZnJvbSh0cmFjZXMpLmpvaW4oXCJcXG5cXG5cIil9YFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBTdG9yYWdlIG11dGF0aW9ucyByZWplY3RlZCBieSBzZXJ2ZXI6ICR7bWVzc2FnZS5yZWFzb259YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNDAwIC8qIFRIUkVBRF9DUkVBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDAxIC8qIFRIUkVBRF9NRVRBREFUQV9VUERBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDA1IC8qIENPTU1FTlRfUkVBQ1RJT05fQURERUQgKi86XG4gICAgICAgICAgY2FzZSA0MDYgLyogQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEICovOlxuICAgICAgICAgIGNhc2UgNDAyIC8qIENPTU1FTlRfQ1JFQVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwMyAvKiBDT01NRU5UX0VESVRFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwNCAvKiBDT01NRU5UX0RFTEVURUQgKi86IHtcbiAgICAgICAgICAgIGV2ZW50SHViLmNvbW1lbnRzLm5vdGlmeShtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm90aWZ5KHVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmbHVzaE5vd09yU29vbigpIHtcbiAgICBjb25zdCBzdG9yYWdlT3BzID0gY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnM7XG4gICAgaWYgKHN0b3JhZ2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBvcCBvZiBzdG9yYWdlT3BzKSB7XG4gICAgICAgIGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuc2V0KG5uKG9wLm9wSWQpLCBvcCk7XG4gICAgICB9XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfVxuICAgIGlmIChtYW5hZ2VkU29ja2V0LmdldFN0YXR1cygpICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucyA9IFtdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWRNaWxsaXMgPSBub3cgLSBjb250ZXh0LmJ1ZmZlci5sYXN0Rmx1c2hlZEF0O1xuICAgIGlmIChlbGFwc2VkTWlsbGlzID49IGNvbmZpZy50aHJvdHRsZURlbGF5KSB7XG4gICAgICBjb25zdCBtZXNzYWdlc1RvRmx1c2ggPSBzZXJpYWxpemVCdWZmZXIoKTtcbiAgICAgIGlmIChtZXNzYWdlc1RvRmx1c2gubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbmRNZXNzYWdlcyhtZXNzYWdlc1RvRmx1c2gpO1xuICAgICAgY29udGV4dC5idWZmZXIgPSB7XG4gICAgICAgIGZsdXNoVGltZXJJRDogdm9pZCAwLFxuICAgICAgICBsYXN0Rmx1c2hlZEF0OiBub3csXG4gICAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgICAgc3RvcmFnZU9wZXJhdGlvbnM6IFtdLFxuICAgICAgICBwcmVzZW5jZVVwZGF0ZXM6IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dChjb250ZXh0LmJ1ZmZlci5mbHVzaFRpbWVySUQpO1xuICAgICAgY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEID0gc2V0VGltZW91dChcbiAgICAgICAgZmx1c2hOb3dPclNvb24sXG4gICAgICAgIGNvbmZpZy50aHJvdHRsZURlbGF5IC0gZWxhcHNlZE1pbGxpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2VyaWFsaXplQnVmZmVyKCkge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcykge1xuICAgICAgbWVzc2FnZXMucHVzaChcbiAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLnR5cGUgPT09IFwiZnVsbFwiID8ge1xuICAgICAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICAgICAgLy8gUG9wdWxhdGluZyB0aGUgYHRhcmdldEFjdG9yYCBmaWVsZCB0dXJucyB0aGlzIG1lc3NhZ2UgaW50b1xuICAgICAgICAgIC8vIGEgRnVsbCBQcmVzZW5jZeKEoiB1cGRhdGUgbWVzc2FnZSAobm90IGEgcGF0Y2gpLCB3aGljaCB3aWxsIGdldFxuICAgICAgICAgIC8vIGludGVycHJldGVkIGJ5IG90aGVyIGNsaWVudHMgYXMgc3VjaC5cbiAgICAgICAgICB0YXJnZXRBY3RvcjogLTEsXG4gICAgICAgICAgZGF0YTogY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgICAgIGRhdGE6IGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgY29udGV4dC5idWZmZXIubWVzc2FnZXMpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLyxcbiAgICAgICAgb3BzOiBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlcztcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVZRG9jKHVwZGF0ZSwgZ3VpZCkge1xuICAgIGNvbnN0IGNsaWVudE1zZyA9IHtcbiAgICAgIHR5cGU6IDMwMSAvKiBVUERBVEVfWURPQyAqLyxcbiAgICAgIHVwZGF0ZSxcbiAgICAgIGd1aWRcbiAgICB9O1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goY2xpZW50TXNnKTtcbiAgICBldmVudEh1Yi55ZG9jLm5vdGlmeShjbGllbnRNc2cpO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gYnJvYWRjYXN0RXZlbnQoZXZlbnQsIG9wdGlvbnMyID0ge1xuICAgIHNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5OiBmYWxzZVxuICB9KSB7XG4gICAgaWYgKG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCkgIT09IFwiY29ubmVjdGVkXCIgJiYgIW9wdGlvbnMyLnNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAzIC8qIEJST0FEQ0FTVF9FVkVOVCAqLyxcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaE9wcyhvcHMpIHtcbiAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKC4uLm9wcyk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBsZXQgX2dldFN0b3JhZ2UkID0gbnVsbDtcbiAgbGV0IF9yZXNvbHZlU3RvcmFnZVByb21pc2UgPSBudWxsO1xuICBmdW5jdGlvbiBwcm9jZXNzSW5pdGlhbFN0b3JhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHVuYWNrbm93bGVkZ2VkT3BzID0gbmV3IE1hcChjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzKTtcbiAgICBjcmVhdGVPclVwZGF0ZVJvb3RGcm9tTWVzc2FnZShtZXNzYWdlLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgYXBwbHlBbmRTZW5kT3BzKHVuYWNrbm93bGVkZ2VkT3BzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZT8uKCk7XG4gICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIGV2ZW50SHViLnN0b3JhZ2VEaWRMb2FkLm5vdGlmeSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0b3JhZ2UoKSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdHJlYW1GZXRjaChtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSwgY29uZmlnLnJvb21JZCk7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIHByb2Nlc3NJbml0aWFsU3RvcmFnZSh7IHR5cGU6IDIwMCAvKiBJTklUSUFMX1NUT1JBR0VfU1RBVEUgKi8sIGl0ZW1zIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2hTdG9yYWdlKG9wdGlvbnMyKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcztcbiAgICBpZiAoY29uZmlnLnVuc3RhYmxlX3N0cmVhbURhdGEpIHtcbiAgICAgIHZvaWQgc3RyZWFtU3RvcmFnZSgpO1xuICAgIH0gZWxzZSBpZiAoIW1lc3NhZ2VzLnNvbWUoKG1zZykgPT4gbXNnLnR5cGUgPT09IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovKSkge1xuICAgICAgbWVzc2FnZXMucHVzaCh7IHR5cGU6IDIwMCAvKiBGRVRDSF9TVE9SQUdFICovIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9uczIuZmx1c2gpIHtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0TG9hZGluZ1N0b3JhZ2UoKSB7XG4gICAgaWYgKF9nZXRTdG9yYWdlJCA9PT0gbnVsbCkge1xuICAgICAgcmVmcmVzaFN0b3JhZ2UoeyBmbHVzaDogdHJ1ZSB9KTtcbiAgICAgIF9nZXRTdG9yYWdlJCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIF9yZXNvbHZlU3RvcmFnZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgfVxuICAgIHJldHVybiBfZ2V0U3RvcmFnZSQ7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RvcmFnZVNuYXBzaG90KCkge1xuICAgIGNvbnN0IHJvb3QgPSBjb250ZXh0LnJvb3Q7XG4gICAgaWYgKHJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvaWQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JhZ2UoKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgcm9vdDogY29udGV4dC5yb290XG4gICAgICB9KTtcbiAgICB9XG4gICAgYXdhaXQgc3RhcnRMb2FkaW5nU3RvcmFnZSgpO1xuICAgIHJldHVybiB7XG4gICAgICByb290OiBubihjb250ZXh0LnJvb3QpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmZXRjaFlEb2ModmVjdG9yLCBndWlkKSB7XG4gICAgaWYgKCFjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5maW5kKChtKSA9PiB7XG4gICAgICByZXR1cm4gbS50eXBlID09PSAzMDAgLyogRkVUQ0hfWURPQyAqLyAmJiBtLnZlY3RvciA9PT0gdmVjdG9yICYmIG0uZ3VpZCA9PT0gZ3VpZDtcbiAgICB9KSkge1xuICAgICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IDMwMCAvKiBGRVRDSF9ZRE9DICovLFxuICAgICAgICB2ZWN0b3IsXG4gICAgICAgIGd1aWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZG8gaXMgbm90IGFsbG93ZWQgZHVyaW5nIGEgYmF0Y2hcIik7XG4gICAgfVxuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnVuZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoaGlzdG9yeU9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMoaGlzdG9yeU9wcywgdHJ1ZSk7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgY29udGV4dC5yZWRvU3RhY2sucHVzaChyZXN1bHQucmV2ZXJzZSk7XG4gICAgICBvbkhpc3RvcnlDaGFuZ2UoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiByZWRvKCkge1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWRvIGlzIG5vdCBhbGxvd2VkIGR1cmluZyBhIGJhdGNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC5yZWRvU3RhY2sucG9wKCk7XG4gICAgaWYgKGhpc3RvcnlPcHMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKGhpc3RvcnlPcHMsIHRydWUpO1xuICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2gocmVzdWx0LnJldmVyc2UpO1xuICAgICAgb25IaXN0b3J5Q2hhbmdlKGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIHJlc3VsdC5vcHMpIHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIpIHtcbiAgICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgY29udGV4dC51bmRvU3RhY2subGVuZ3RoID0gMDtcbiAgICBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPSAwO1xuICB9XG4gIGZ1bmN0aW9uIGJhdGNoKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBsZXQgcmV0dXJuVmFsdWUgPSB2b2lkIDA7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2ggPSB7XG4gICAgICAgIG9wczogW10sXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBzdG9yYWdlVXBkYXRlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgICAgICBwcmVzZW5jZTogZmFsc2UsXG4gICAgICAgICAgb3RoZXJzOiBbXVxuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlT3BzOiBbXVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYXRjaCA9IGNvbnRleHQuYWN0aXZlQmF0Y2g7XG4gICAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2ggPSBudWxsO1xuICAgICAgICBpZiAoY3VycmVudEJhdGNoLnJldmVyc2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKGN1cnJlbnRCYXRjaC5yZXZlcnNlT3BzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRCYXRjaC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRpc3BhdGNoT3BzKGN1cnJlbnRCYXRjaC5vcHMpO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmeShjdXJyZW50QmF0Y2gudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICBmbHVzaE5vd09yU29vbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZUhpc3RvcnkoKSB7XG4gICAgaWYgKGNvbnRleHQucGF1c2VkSGlzdG9yeSA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gW107XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZUhpc3RvcnkoKSB7XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQucGF1c2VkSGlzdG9yeTtcbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGlmIChoaXN0b3J5T3BzICE9PSBudWxsICYmIGhpc3RvcnlPcHMubGVuZ3RoID4gMCkge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaFVwZGF0ZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTdG9yYWdlU3RhdHVzKCkge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIF9nZXRTdG9yYWdlJCA9PT0gbnVsbCA/IFwibm90LWxvYWRlZFwiIDogXCJsb2FkaW5nXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNpemUgPT09IDAgPyBcInN5bmNocm9uaXplZFwiIDogXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9XG4gIGxldCBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBnZXRTdG9yYWdlU3RhdHVzKCk7XG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKSB7XG4gICAgY29uc3Qgc3RvcmFnZVN0YXR1cyA9IGdldFN0b3JhZ2VTdGF0dXMoKTtcbiAgICBpZiAoX2xhc3RTdG9yYWdlU3RhdHVzICE9PSBzdG9yYWdlU3RhdHVzKSB7XG4gICAgICBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBzdG9yYWdlU3RhdHVzO1xuICAgICAgZXZlbnRIdWIuc3RvcmFnZVN0YXR1cy5ub3RpZnkoc3RvcmFnZVN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG90aGVyc19mb3JEZXZUb29scyA9IG5ldyBEZXJpdmVkUmVmKFxuICAgIGNvbnRleHQub3RoZXJzLFxuICAgIChvdGhlcnMpID0+IG90aGVycy5tYXAoKG90aGVyLCBpbmRleCkgPT4gdXNlclRvVHJlZU5vZGUoYE90aGVyICR7aW5kZXh9YCwgb3RoZXIpKVxuICApO1xuICBjb25zdCBldmVudHMgPSB7XG4gICAgc3RhdHVzOiBldmVudEh1Yi5zdGF0dXMub2JzZXJ2YWJsZSxcbiAgICBsb3N0Q29ubmVjdGlvbjogZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ub2JzZXJ2YWJsZSxcbiAgICBjdXN0b21FdmVudDogZXZlbnRIdWIuY3VzdG9tRXZlbnQub2JzZXJ2YWJsZSxcbiAgICBvdGhlcnM6IGV2ZW50SHViLm90aGVycy5vYnNlcnZhYmxlLFxuICAgIHNlbGY6IGV2ZW50SHViLnNlbGYub2JzZXJ2YWJsZSxcbiAgICBteVByZXNlbmNlOiBldmVudEh1Yi5teVByZXNlbmNlLm9ic2VydmFibGUsXG4gICAgZXJyb3I6IGV2ZW50SHViLmVycm9yLm9ic2VydmFibGUsXG4gICAgc3RvcmFnZTogZXZlbnRIdWIuc3RvcmFnZS5vYnNlcnZhYmxlLFxuICAgIGhpc3Rvcnk6IGV2ZW50SHViLmhpc3Rvcnkub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlRGlkTG9hZDogZXZlbnRIdWIuc3RvcmFnZURpZExvYWQub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlU3RhdHVzOiBldmVudEh1Yi5zdG9yYWdlU3RhdHVzLm9ic2VydmFibGUsXG4gICAgeWRvYzogZXZlbnRIdWIueWRvYy5vYnNlcnZhYmxlLFxuICAgIGNvbW1lbnRzOiBldmVudEh1Yi5jb21tZW50cy5vYnNlcnZhYmxlXG4gIH07XG4gIGNvbnN0IGNvbW1lbnRzQXBpID0gY3JlYXRlQ29tbWVudHNBcGkoXG4gICAgY29uZmlnLnJvb21JZCxcbiAgICBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlLFxuICAgIGZldGNoQ2xpZW50QXBpXG4gICk7XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoTm90aWZpY2F0aW9uc0pzb24oZW5kcG9pbnQsIG9wdGlvbnMyKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gYXdhaXQgZGVsZWdhdGVzLmF1dGhlbnRpY2F0ZSgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hDbGllbnRBcGkoXG4gICAgICBjb25maWcucm9vbUlkLFxuICAgICAgZW5kcG9pbnQsXG4gICAgICBhdXRoVmFsdWUsXG4gICAgICBvcHRpb25zMlxuICAgICk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgIGxldCBlcnJvcjM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIGVycm9yMyA9IG5ldyBOb3RpZmljYXRpb25zQXBpRXJyb3IoXG4gICAgICAgICAgICBlcnJvckJvZHkubWVzc2FnZSxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIGVycm9yQm9keVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGVycm9yMyA9IG5ldyBOb3RpZmljYXRpb25zQXBpRXJyb3IoXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjM7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBib2R5O1xuICAgIHRyeSB7XG4gICAgICBib2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgYm9keSA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gYm9keTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MoKSB7XG4gICAgcmV0dXJuIGZldGNoTm90aWZpY2F0aW9uc0pzb24oXG4gICAgICBcIi9ub3RpZmljYXRpb24tc2V0dGluZ3NcIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIGZldGNoTm90aWZpY2F0aW9uc0pzb24oXG4gICAgICBcIi9ub3RpZmljYXRpb24tc2V0dGluZ3NcIixcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcykge1xuICAgIGF3YWl0IGZldGNoTm90aWZpY2F0aW9uc0pzb24oXCIvaW5ib3gtbm90aWZpY2F0aW9ucy9yZWFkXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpbmJveE5vdGlmaWNhdGlvbklkcyB9KVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGJhdGNoZWRNYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkID0gbmV3IEJhdGNoKFxuICAgIGFzeW5jIChiYXRjaGVkSW5ib3hOb3RpZmljYXRpb25JZHMpID0+IHtcbiAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9uSWRzID0gYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzLmZsYXQoKTtcbiAgICAgIGF3YWl0IG1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZHMpO1xuICAgICAgcmV0dXJuIGluYm94Tm90aWZpY2F0aW9uSWRzO1xuICAgIH0sXG4gICAgeyBkZWxheTogTUFSS19JTkJPWF9OT1RJRklDQVRJT05TX0FTX1JFQURfQkFUQ0hfREVMQVkyIH1cbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBhd2FpdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZC5nZXQoaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB7XG4gICAgICBba0ludGVybmFsXToge1xuICAgICAgICBnZXQgcHJlc2VuY2VCdWZmZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZXBDbG9uZShjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXM/LmRhdGEgPz8gbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBnZXQgdW5kb1N0YWNrKCkge1xuICAgICAgICAgIHJldHVybiBkZWVwQ2xvbmUoY29udGV4dC51bmRvU3RhY2spO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgZ2V0IG5vZGVDb3VudCgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5ub2Rlcy5zaXplO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgdGhlIExpdmVibG9ja3MgYnJvd3NlciBleHRlbnNpb25cbiAgICAgICAgZ2V0U2VsZl9mb3JEZXZUb29sczogKCkgPT4gc2VsZkFzVHJlZU5vZGUuY3VycmVudCxcbiAgICAgICAgZ2V0T3RoZXJzX2ZvckRldlRvb2xzOiAoKSA9PiBvdGhlcnNfZm9yRGV2VG9vbHMuY3VycmVudCxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHNpbXVsYXRlOiB7XG4gICAgICAgICAgLy8gVGhlc2UgZXhpc3Qgb25seSBmb3Igb3VyIEUyRSB0ZXN0aW5nIGFwcFxuICAgICAgICAgIGV4cGxpY2l0Q2xvc2U6IChldmVudCkgPT4gbWFuYWdlZFNvY2tldC5fcHJpdmF0ZVNlbmRNYWNoaW5lRXZlbnQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9DTE9TRVwiLCBldmVudCB9KSxcbiAgICAgICAgICByYXdTZW5kOiAoZGF0YSkgPT4gbWFuYWdlZFNvY2tldC5zZW5kKGRhdGEpXG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1lbnRzOiB7XG4gICAgICAgICAgLi4uY29tbWVudHNBcGlcbiAgICAgICAgfSxcbiAgICAgICAgbm90aWZpY2F0aW9uczoge1xuICAgICAgICAgIGdldFJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgICAgICB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgICAgICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpZDogY29uZmlnLnJvb21JZCxcbiAgICAgIHN1YnNjcmliZTogbWFrZUNsYXNzaWNTdWJzY3JpYmVGbihldmVudHMpLFxuICAgICAgY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5jb25uZWN0KCksXG4gICAgICByZWNvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQucmVjb25uZWN0KCksXG4gICAgICBkaXNjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LmRpc2Nvbm5lY3QoKSxcbiAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgdW5pbnN0YWxsQmdUYWJTcHkoKTtcbiAgICAgICAgbWFuYWdlZFNvY2tldC5kZXN0cm95KCk7XG4gICAgICB9LFxuICAgICAgLy8gUHJlc2VuY2VcbiAgICAgIHVwZGF0ZVByZXNlbmNlLFxuICAgICAgdXBkYXRlWURvYyxcbiAgICAgIGJyb2FkY2FzdEV2ZW50LFxuICAgICAgLy8gU3RvcmFnZVxuICAgICAgYmF0Y2gsXG4gICAgICBoaXN0b3J5OiB7XG4gICAgICAgIHVuZG8sXG4gICAgICAgIHJlZG8sXG4gICAgICAgIGNhblVuZG8sXG4gICAgICAgIGNhblJlZG8sXG4gICAgICAgIGNsZWFyLFxuICAgICAgICBwYXVzZTogcGF1c2VIaXN0b3J5LFxuICAgICAgICByZXN1bWU6IHJlc3VtZUhpc3RvcnlcbiAgICAgIH0sXG4gICAgICBmZXRjaFlEb2MsXG4gICAgICBnZXRTdG9yYWdlLFxuICAgICAgZ2V0U3RvcmFnZVNuYXBzaG90LFxuICAgICAgZ2V0U3RvcmFnZVN0YXR1cyxcbiAgICAgIGV2ZW50cyxcbiAgICAgIC8vIENvcmVcbiAgICAgIGdldFN0YXR1czogKCkgPT4gbWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSxcbiAgICAgIGdldENvbm5lY3Rpb25TdGF0ZTogKCkgPT4gbWFuYWdlZFNvY2tldC5nZXRMZWdhY3lTdGF0dXMoKSxcbiAgICAgIGdldFNlbGY6ICgpID0+IHNlbGYuY3VycmVudCxcbiAgICAgIC8vIFByZXNlbmNlXG4gICAgICBnZXRQcmVzZW5jZTogKCkgPT4gY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQsXG4gICAgICBnZXRPdGhlcnM6ICgpID0+IGNvbnRleHQub3RoZXJzLmN1cnJlbnRcbiAgICB9LFxuICAgIC8vIEV4cGxpY3RseSBtYWtlIHRoZSBpbnRlcm5hbCBmaWVsZCBub24tZW51bWVyYWJsZSwgdG8gYXZvaWQgYWdncmVzc2l2ZVxuICAgIC8vIGZyZWV6aW5nIHdoZW4gdXNlZCB3aXRoIEltbWVyXG4gICAga0ludGVybmFsLFxuICAgIHsgZW51bWVyYWJsZTogZmFsc2UgfVxuICApO1xufVxuZnVuY3Rpb24gbWFrZUNsYXNzaWNTdWJzY3JpYmVGbihldmVudHMpIHtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlRGVlcGx5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlLnN1YnNjcmliZSgodXBkYXRlcykgPT4ge1xuICAgICAgY29uc3QgcmVsYXRlZFVwZGF0ZXMgPSB1cGRhdGVzLmZpbHRlcihcbiAgICAgICAgKHVwZGF0ZSkgPT4gaXNTYW1lTm9kZU9yQ2hpbGRPZih1cGRhdGUubm9kZSwgbm9kZSlcbiAgICAgICk7XG4gICAgICBpZiAocmVsYXRlZFVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjYWxsYmFjayhyZWxhdGVkVXBkYXRlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlLnN1YnNjcmliZSgodXBkYXRlcykgPT4ge1xuICAgICAgZm9yIChjb25zdCB1cGRhdGUgb2YgdXBkYXRlcykge1xuICAgICAgICBpZiAodXBkYXRlLm5vZGUuX2lkID09PSBub2RlLl9pZCkge1xuICAgICAgICAgIGNhbGxiYWNrKHVwZGF0ZS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShmaXJzdCwgc2Vjb25kLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJzdHJpbmdcIiAmJiBpc1Jvb21FdmVudE5hbWUoZmlyc3QpKSB7XG4gICAgICBpZiAodHlwZW9mIHNlY29uZCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgY2FsbGJhY2sgZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHNlY29uZDtcbiAgICAgIHN3aXRjaCAoZmlyc3QpIHtcbiAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5jdXN0b21FdmVudC5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJteS1wcmVzZW5jZVwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMubXlQcmVzZW5jZS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwib3RoZXJzXCI6IHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrO1xuICAgICAgICAgIHJldHVybiBldmVudHMub3RoZXJzLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3RoZXJzLCAuLi5pbnRlcm5hbEV2ZW50IH0gPSBldmVudDtcbiAgICAgICAgICAgIHJldHVybiBjYihvdGhlcnMsIGludGVybmFsRXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuZXJyb3Iuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcImNvbm5lY3Rpb25cIjoge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2s7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKFxuICAgICAgICAgICAgKHN0YXR1cykgPT4gY2IobmV3VG9MZWdhY3lTdGF0dXMoc3RhdHVzKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzdGF0dXNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwibG9zdC1jb25uZWN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5sb3N0Q29ubmVjdGlvbi5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgXCJoaXN0b3J5XCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJzdG9yYWdlLXN0YXR1c1wiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuc3RvcmFnZVN0YXR1cy5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKFxuICAgICAgICAgICAgZmlyc3QsXG4gICAgICAgICAgICBgXCIke1N0cmluZyhmaXJzdCl9XCIgaXMgbm90IGEgdmFsaWQgZXZlbnQgbmFtZWBcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2Vjb25kID09PSB2b2lkIDAgfHwgdHlwZW9mIGZpcnN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgZmlyc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBzdG9yYWdlQ2FsbGJhY2sgPSBmaXJzdDtcbiAgICAgICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlLnN1YnNjcmliZShzdG9yYWdlQ2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNwZWNpZnkgYSBsaXN0ZW5lciBjYWxsYmFja1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTGl2ZU5vZGUoZmlyc3QpKSB7XG4gICAgICBjb25zdCBub2RlID0gZmlyc3Q7XG4gICAgICBpZiAob3B0aW9ucz8uaXNEZWVwKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDYWxsYmFjayA9IHNlY29uZDtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZURlZXBseShub2RlLCBzdG9yYWdlQ2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9kZUNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlU2hhbGxvd2x5KG5vZGUsIG5vZGVDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAke1N0cmluZyhmaXJzdCl9IGlzIG5vdCBhIHZhbHVlIHRoYXQgY2FuIGJlIHN1YnNjcmliZWQgdG8uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHN1YnNjcmliZTtcbn1cbmZ1bmN0aW9uIGlzUm9vbUV2ZW50TmFtZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFwibXktcHJlc2VuY2VcIiB8fCB2YWx1ZSA9PT0gXCJvdGhlcnNcIiB8fCB2YWx1ZSA9PT0gXCJldmVudFwiIHx8IHZhbHVlID09PSBcImVycm9yXCIgfHwgdmFsdWUgPT09IFwiaGlzdG9yeVwiIHx8IHZhbHVlID09PSBcInN0YXR1c1wiIHx8IHZhbHVlID09PSBcInN0b3JhZ2Utc3RhdHVzXCIgfHwgdmFsdWUgPT09IFwibG9zdC1jb25uZWN0aW9uXCIgfHwgdmFsdWUgPT09IFwiY29ubmVjdGlvblwiO1xufVxuZnVuY3Rpb24gbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcikge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJyb29tOnJlYWRcIiwgcm9vbUlkIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gbWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGJhc2VVcmwsIFdlYlNvY2tldFBvbHlmaWxsKSB7XG4gIHJldHVybiAoYXV0aFZhbHVlKSA9PiB7XG4gICAgY29uc3Qgd3MgPSBXZWJTb2NrZXRQb2x5ZmlsbCA/PyAodHlwZW9mIFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IFdlYlNvY2tldCk7XG4gICAgaWYgKHdzID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIFdlYlNvY2tldCBwb2x5ZmlsbC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChiYXNlVXJsKTtcbiAgICB1cmwucHJvdG9jb2wgPSB1cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIiA/IFwid3NcIiA6IFwid3NzXCI7XG4gICAgdXJsLnBhdGhuYW1lID0gXCIvdjdcIjtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInJvb21JZFwiLCByb29tSWQpO1xuICAgIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJzZWNyZXRcIikge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tcIiwgYXV0aFZhbHVlLnRva2VuLnJhdyk7XG4gICAgfSBlbHNlIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJwdWJrZXlcIiwgYXV0aFZhbHVlLnB1YmxpY0FwaUtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihhdXRoVmFsdWUsIFwiVW5oYW5kbGVkIGNhc2VcIik7XG4gICAgfVxuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwidmVyc2lvblwiLCBQS0dfVkVSU0lPTiB8fCBcImRldlwiKTtcbiAgICByZXR1cm4gbmV3IHdzKHVybC50b1N0cmluZygpKTtcbiAgfTtcbn1cblxuLy8gc3JjL3N0b3JlLnRzXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRTdG9yZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZSh7XG4gICAgdGhyZWFkczoge30sXG4gICAgcXVlcmllczoge30sXG4gICAgb3B0aW1pc3RpY1VwZGF0ZXM6IFtdLFxuICAgIGluYm94Tm90aWZpY2F0aW9uczoge30sXG4gICAgbm90aWZpY2F0aW9uU2V0dGluZ3M6IHt9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLnN0b3JlLFxuICAgIGRlbGV0ZVRocmVhZCh0aHJlYWRJZCkge1xuICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIHRocmVhZHM6IGRlbGV0ZUtleUltbXV0YWJsZShzdGF0ZS50aHJlYWRzLCB0aHJlYWRJZCksXG4gICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMpLmZpbHRlcihcbiAgICAgICAgICAgICAgKFtfaWQsIG5vdGlmaWNhdGlvbl0pID0+IG5vdGlmaWNhdGlvbi50aHJlYWRJZCAhPT0gdGhyZWFkSWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZVRocmVhZEFuZE5vdGlmaWNhdGlvbih0aHJlYWQsIGluYm94Tm90aWZpY2F0aW9uKSB7XG4gICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gc3RhdGUudGhyZWFkc1t0aHJlYWQuaWRdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIHRocmVhZHM6IGV4aXN0aW5nVGhyZWFkID09PSB2b2lkIDAgfHwgY29tcGFyZVRocmVhZHModGhyZWFkLCBleGlzdGluZ1RocmVhZCkgPT09IDEgPyB7IC4uLnN0YXRlLnRocmVhZHMsIFt0aHJlYWQuaWRdOiB0aHJlYWQgfSA6IHN0YXRlLnRocmVhZHMsXG4gICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBpbmJveE5vdGlmaWNhdGlvbiA9PT0gdm9pZCAwID8gc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zIDoge1xuICAgICAgICAgICAgLi4uc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgICAgW2luYm94Tm90aWZpY2F0aW9uLmlkXTogaW5ib3hOb3RpZmljYXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zKHRocmVhZHMsIGluYm94Tm90aWZpY2F0aW9ucywgZGVsZXRlZFRocmVhZHMsIGRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMsIHF1ZXJ5S2V5KSB7XG4gICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgdGhyZWFkczogYXBwbHlUaHJlYWRVcGRhdGVzKHN0YXRlLnRocmVhZHMsIHtcbiAgICAgICAgICBuZXdUaHJlYWRzOiB0aHJlYWRzLFxuICAgICAgICAgIGRlbGV0ZWRUaHJlYWRzXG4gICAgICAgIH0pLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IGFwcGx5Tm90aWZpY2F0aW9uc1VwZGF0ZXMoXG4gICAgICAgICAgc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5ld0luYm94Tm90aWZpY2F0aW9uczogaW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgICAgZGVsZXRlZE5vdGlmaWNhdGlvbnM6IGRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnNcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHF1ZXJpZXM6IHF1ZXJ5S2V5ICE9PSB2b2lkIDAgPyB7XG4gICAgICAgICAgLi4uc3RhdGUucXVlcmllcyxcbiAgICAgICAgICBbcXVlcnlLZXldOiB7XG4gICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9IDogc3RhdGUucXVlcmllc1xuICAgICAgfSkpO1xuICAgIH0sXG4gICAgdXBkYXRlUm9vbUluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbUlkLCBzZXR0aW5ncywgcXVlcnlLZXkpIHtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBub3RpZmljYXRpb25TZXR0aW5nczoge1xuICAgICAgICAgIC4uLnN0YXRlLm5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgICAgIFtyb29tSWRdOiBzZXR0aW5nc1xuICAgICAgICB9LFxuICAgICAgICBxdWVyaWVzOiB7XG4gICAgICAgICAgLi4uc3RhdGUucXVlcmllcyxcbiAgICAgICAgICBbcXVlcnlLZXldOiB7XG4gICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBwdXNoT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlKSB7XG4gICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IFsuLi5zdGF0ZS5vcHRpbWlzdGljVXBkYXRlcywgb3B0aW1pc3RpY1VwZGF0ZV1cbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIHNldFF1ZXJ5U3RhdGUocXVlcnlLZXksIHF1ZXJ5U3RhdGUpIHtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBxdWVyaWVzOiB7XG4gICAgICAgICAgLi4uc3RhdGUucXVlcmllcyxcbiAgICAgICAgICBbcXVlcnlLZXldOiBxdWVyeVN0YXRlXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVLZXlJbW11dGFibGUocmVjb3JkLCBrZXkpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWNvcmQsIGtleSkpIHtcbiAgICBjb25zdCB7IFtrZXldOiBfdG9EZWxldGUsIC4uLnJlc3QgfSA9IHJlY29yZDtcbiAgICByZXR1cm4gcmVzdDtcbiAgfVxuICByZXR1cm4gcmVjb3JkO1xufVxuZnVuY3Rpb24gY29tcGFyZVRocmVhZHModGhyZWFkMSwgdGhyZWFkMikge1xuICBpZiAodGhyZWFkMS51cGRhdGVkQXQgJiYgdGhyZWFkMi51cGRhdGVkQXQpIHtcbiAgICByZXR1cm4gdGhyZWFkMS51cGRhdGVkQXQgPiB0aHJlYWQyLnVwZGF0ZWRBdCA/IDEgOiB0aHJlYWQxLnVwZGF0ZWRBdCA8IHRocmVhZDIudXBkYXRlZEF0ID8gLTEgOiAwO1xuICB9IGVsc2UgaWYgKHRocmVhZDEudXBkYXRlZEF0IHx8IHRocmVhZDIudXBkYXRlZEF0KSB7XG4gICAgcmV0dXJuIHRocmVhZDEudXBkYXRlZEF0ID8gMSA6IC0xO1xuICB9XG4gIGlmICh0aHJlYWQxLmNyZWF0ZWRBdCA+IHRocmVhZDIuY3JlYXRlZEF0KSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAodGhyZWFkMS5jcmVhdGVkQXQgPCB0aHJlYWQyLmNyZWF0ZWRBdCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMoc3RhdGUpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHRocmVhZHM6IHtcbiAgICAgIC4uLnN0YXRlLnRocmVhZHNcbiAgICB9LFxuICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgLi4uc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zXG4gICAgfSxcbiAgICBub3RpZmljYXRpb25TZXR0aW5nczoge1xuICAgICAgLi4uc3RhdGUubm90aWZpY2F0aW9uU2V0dGluZ3NcbiAgICB9XG4gIH07XG4gIGZvciAoY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZSBvZiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcykge1xuICAgIHN3aXRjaCAob3B0aW1pc3RpY1VwZGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIFwiY3JlYXRlLXRocmVhZFwiOiB7XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkLmlkXSA9IG9wdGltaXN0aWNVcGRhdGUudGhyZWFkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJlZGl0LXRocmVhZC1tZXRhZGF0YVwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocmVhZC51cGRhdGVkQXQgIT09IHZvaWQgMCAmJiB0aHJlYWQudXBkYXRlZEF0ID4gb3B0aW1pc3RpY1VwZGF0ZS51cGRhdGVkQXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudGhyZWFkc1t0aHJlYWQuaWRdID0ge1xuICAgICAgICAgIC4uLnRocmVhZCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG9wdGltaXN0aWNVcGRhdGUudXBkYXRlZEF0LFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAuLi50aHJlYWQubWV0YWRhdGEsXG4gICAgICAgICAgICAuLi5vcHRpbWlzdGljVXBkYXRlLm1ldGFkYXRhXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJjcmVhdGUtY29tbWVudFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUuY29tbWVudC50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSB1cHNlcnRDb21tZW50KFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBPYmplY3QudmFsdWVzKHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMpLmZpbmQoXG4gICAgICAgICAgKG5vdGlmaWNhdGlvbikgPT4gbm90aWZpY2F0aW9uLnRocmVhZElkID09PSB0aHJlYWQuaWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGluYm94Tm90aWZpY2F0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zW2luYm94Tm90aWZpY2F0aW9uLmlkXSA9IHtcbiAgICAgICAgICAuLi5pbmJveE5vdGlmaWNhdGlvbixcbiAgICAgICAgICBub3RpZmllZEF0OiBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQuY3JlYXRlZEF0LFxuICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50LmNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJlZGl0LWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudGhyZWFkc1t0aHJlYWQuaWRdID0gdXBzZXJ0Q29tbWVudChcbiAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS1jb21tZW50XCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gcmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSBkZWxldGVDb21tZW50KFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmRlbGV0ZWRBdFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhZGQtcmVhY3Rpb25cIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnRocmVhZHNbdGhyZWFkLmlkXSA9IGFkZFJlYWN0aW9uKFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLnJlYWN0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInJlbW92ZS1yZWFjdGlvblwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudGhyZWFkc1t0aHJlYWQuaWRdID0gcmVtb3ZlUmVhY3Rpb24oXG4gICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudElkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuZW1vamksXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS51c2VySWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5yZW1vdmVkQXRcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay1pbmJveC1ub3RpZmljYXRpb24tYXMtcmVhZFwiOiB7XG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNbb3B0aW1pc3RpY1VwZGF0ZS5pbmJveE5vdGlmaWNhdGlvbklkXSA9IHtcbiAgICAgICAgICAuLi5zdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnNbb3B0aW1pc3RpY1VwZGF0ZS5pbmJveE5vdGlmaWNhdGlvbklkXSxcbiAgICAgICAgICByZWFkQXQ6IG9wdGltaXN0aWNVcGRhdGUucmVhZEF0XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hcmstaW5ib3gtbm90aWZpY2F0aW9ucy1hcy1yZWFkXCI6IHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBpbiByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zKSB7XG4gICAgICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9uc1tpZF0gPSB7XG4gICAgICAgICAgICAuLi5yZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zW2lkXSxcbiAgICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5yZWFkQXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVwZGF0ZS1ub3RpZmljYXRpb24tc2V0dGluZ3NcIjoge1xuICAgICAgICByZXN1bHQubm90aWZpY2F0aW9uU2V0dGluZ3Nbb3B0aW1pc3RpY1VwZGF0ZS5yb29tSWRdID0ge1xuICAgICAgICAgIC4uLnJlc3VsdC5ub3RpZmljYXRpb25TZXR0aW5nc1tvcHRpbWlzdGljVXBkYXRlLnJvb21JZF0sXG4gICAgICAgICAgLi4ub3B0aW1pc3RpY1VwZGF0ZS5zZXR0aW5nc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXBwbHlUaHJlYWRVcGRhdGVzKGV4aXN0aW5nVGhyZWFkcywgdXBkYXRlcykge1xuICBjb25zdCB1cGRhdGVkVGhyZWFkcyA9IHsgLi4uZXhpc3RpbmdUaHJlYWRzIH07XG4gIHVwZGF0ZXMubmV3VGhyZWFkcy5mb3JFYWNoKCh0aHJlYWQpID0+IHtcbiAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHVwZGF0ZWRUaHJlYWRzW3RocmVhZC5pZF07XG4gICAgaWYgKGV4aXN0aW5nVGhyZWFkKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJlVGhyZWFkcyhleGlzdGluZ1RocmVhZCwgdGhyZWFkKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IDEpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlZFRocmVhZHNbdGhyZWFkLmlkXSA9IHRocmVhZDtcbiAgfSk7XG4gIHVwZGF0ZXMuZGVsZXRlZFRocmVhZHMuZm9yRWFjaCgoeyBpZCwgZGVsZXRlZEF0IH0pID0+IHtcbiAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHVwZGF0ZWRUaHJlYWRzW2lkXTtcbiAgICBpZiAoZXhpc3RpbmdUaHJlYWQgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBleGlzdGluZ1RocmVhZC5kZWxldGVkQXQgPSBkZWxldGVkQXQ7XG4gICAgZXhpc3RpbmdUaHJlYWQudXBkYXRlZEF0ID0gZGVsZXRlZEF0O1xuICAgIGV4aXN0aW5nVGhyZWFkLmNvbW1lbnRzID0gW107XG4gIH0pO1xuICByZXR1cm4gdXBkYXRlZFRocmVhZHM7XG59XG5mdW5jdGlvbiBhcHBseU5vdGlmaWNhdGlvbnNVcGRhdGVzKGV4aXN0aW5nSW5ib3hOb3RpZmljYXRpb25zLCB1cGRhdGVzKSB7XG4gIGNvbnN0IHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnMgPSB7IC4uLmV4aXN0aW5nSW5ib3hOb3RpZmljYXRpb25zIH07XG4gIHVwZGF0ZXMubmV3SW5ib3hOb3RpZmljYXRpb25zLmZvckVhY2goKG5vdGlmaWNhdGlvbikgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nTm90aWZpY2F0aW9uID0gdXBkYXRlZEluYm94Tm90aWZpY2F0aW9uc1tub3RpZmljYXRpb24uaWRdO1xuICAgIGlmIChleGlzdGluZ05vdGlmaWNhdGlvbikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyZUluYm94Tm90aWZpY2F0aW9ucyhcbiAgICAgICAgZXhpc3RpbmdOb3RpZmljYXRpb24sXG4gICAgICAgIG5vdGlmaWNhdGlvblxuICAgICAgKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IDEpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlZEluYm94Tm90aWZpY2F0aW9uc1tub3RpZmljYXRpb24uaWRdID0gbm90aWZpY2F0aW9uO1xuICB9KTtcbiAgdXBkYXRlcy5kZWxldGVkTm90aWZpY2F0aW9ucy5mb3JFYWNoKFxuICAgICh7IGlkIH0pID0+IGRlbGV0ZSB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zW2lkXVxuICApO1xuICByZXR1cm4gdXBkYXRlZEluYm94Tm90aWZpY2F0aW9ucztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJbmJveE5vdGlmaWNhdGlvbnMoaW5ib3hOb3RpZmljYXRpb25BLCBpbmJveE5vdGlmaWNhdGlvbkIpIHtcbiAgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5ub3RpZmllZEF0ID4gaW5ib3hOb3RpZmljYXRpb25CLm5vdGlmaWVkQXQpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChpbmJveE5vdGlmaWNhdGlvbkEubm90aWZpZWRBdCA8IGluYm94Tm90aWZpY2F0aW9uQi5ub3RpZmllZEF0KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmIChpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0ICYmIGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQpIHtcbiAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA+IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQgPyAxIDogaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA8IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQgPyAtMSA6IDA7XG4gIH0gZWxzZSBpZiAoaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCB8fCBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0KSB7XG4gICAgcmV0dXJuIGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiB1cHNlcnRDb21tZW50KHRocmVhZCwgY29tbWVudCkge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoY29tbWVudC50aHJlYWRJZCAhPT0gdGhyZWFkLmlkKSB7XG4gICAgd2FybihcbiAgICAgIGBDb21tZW50ICR7Y29tbWVudC5pZH0gZG9lcyBub3QgYmVsb25nIHRvIHRocmVhZCAke3RocmVhZC5pZH1gXG4gICAgKTtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29tbWVudCA9IHRocmVhZC5jb21tZW50cy5maW5kKFxuICAgIChleGlzdGluZ0NvbW1lbnQyKSA9PiBleGlzdGluZ0NvbW1lbnQyLmlkID09PSBjb21tZW50LmlkXG4gICk7XG4gIGlmIChleGlzdGluZ0NvbW1lbnQgPT09IHZvaWQgMCkge1xuICAgIGNvbnN0IHVwZGF0ZWRBdCA9IG5ldyBEYXRlKFxuICAgICAgTWF0aC5tYXgodGhyZWFkLnVwZGF0ZWRBdD8uZ2V0VGltZSgpIHx8IDAsIGNvbW1lbnQuY3JlYXRlZEF0LmdldFRpbWUoKSlcbiAgICApO1xuICAgIGNvbnN0IHVwZGF0ZWRUaHJlYWQgPSB7XG4gICAgICAuLi50aHJlYWQsXG4gICAgICB1cGRhdGVkQXQsXG4gICAgICBjb21tZW50czogWy4uLnRocmVhZC5jb21tZW50cywgY29tbWVudF1cbiAgICB9O1xuICAgIHJldHVybiB1cGRhdGVkVGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZWRpdGVkQXQgPT09IHZvaWQgMCB8fCBjb21tZW50LmVkaXRlZEF0ID09PSB2b2lkIDAgfHwgZXhpc3RpbmdDb21tZW50LmVkaXRlZEF0IDw9IGNvbW1lbnQuZWRpdGVkQXQpIHtcbiAgICBjb25zdCB1cGRhdGVkQ29tbWVudHMgPSB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgICAgKGV4aXN0aW5nQ29tbWVudDIpID0+IGV4aXN0aW5nQ29tbWVudDIuaWQgPT09IGNvbW1lbnQuaWQgPyBjb21tZW50IDogZXhpc3RpbmdDb21tZW50MlxuICAgICk7XG4gICAgY29uc3QgdXBkYXRlZFRocmVhZCA9IHtcbiAgICAgIC4uLnRocmVhZCxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoXG4gICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgIHRocmVhZC51cGRhdGVkQXQ/LmdldFRpbWUoKSB8fCAwLFxuICAgICAgICAgIGNvbW1lbnQuZWRpdGVkQXQ/LmdldFRpbWUoKSB8fCBjb21tZW50LmNyZWF0ZWRBdC5nZXRUaW1lKClcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIGNvbW1lbnRzOiB1cGRhdGVkQ29tbWVudHNcbiAgICB9O1xuICAgIHJldHVybiB1cGRhdGVkVGhyZWFkO1xuICB9XG4gIHJldHVybiB0aHJlYWQ7XG59XG5mdW5jdGlvbiBkZWxldGVDb21tZW50KHRocmVhZCwgY29tbWVudElkLCBkZWxldGVkQXQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICBkZWxldGVkQXQsXG4gICAgICBib2R5OiB2b2lkIDBcbiAgICB9IDogY29tbWVudFxuICApO1xuICBpZiAoIXVwZGF0ZWRDb21tZW50cy5zb21lKChjb21tZW50KSA9PiBjb21tZW50LmRlbGV0ZWRBdCA9PT0gdm9pZCAwKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aHJlYWQsXG4gICAgICBkZWxldGVkQXQsXG4gICAgICB1cGRhdGVkQXQ6IGRlbGV0ZWRBdCxcbiAgICAgIGNvbW1lbnRzOiBbXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBkZWxldGVkQXQsXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gYWRkUmVhY3Rpb24odGhyZWFkLCBjb21tZW50SWQsIHJlYWN0aW9uKSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29tbWVudCA9IHRocmVhZC5jb21tZW50cy5maW5kKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCB1cGRhdGVkQ29tbWVudHMgPSB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWQgPyB7XG4gICAgICAuLi5jb21tZW50LFxuICAgICAgcmVhY3Rpb25zOiB1cHNlcnRSZWFjdGlvbihjb21tZW50LnJlYWN0aW9ucywgcmVhY3Rpb24pXG4gICAgfSA6IGNvbW1lbnRcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgIE1hdGgubWF4KHJlYWN0aW9uLmNyZWF0ZWRBdC5nZXRUaW1lKCksIHRocmVhZC51cGRhdGVkQXQ/LmdldFRpbWUoKSB8fCAwKVxuICAgICksXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlUmVhY3Rpb24odGhyZWFkLCBjb21tZW50SWQsIGVtb2ppLCB1c2VySWQsIHJlbW92ZWRBdCkge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCBleGlzdGluZ0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkXG4gICk7XG4gIGlmIChleGlzdGluZ0NvbW1lbnQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgdXBkYXRlZENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkID8ge1xuICAgICAgLi4uY29tbWVudCxcbiAgICAgIHJlYWN0aW9uczogY29tbWVudC5yZWFjdGlvbnMubWFwKFxuICAgICAgICAocmVhY3Rpb24pID0+IHJlYWN0aW9uLmVtb2ppID09PSBlbW9qaSA/IHtcbiAgICAgICAgICAuLi5yZWFjdGlvbixcbiAgICAgICAgICB1c2VyczogcmVhY3Rpb24udXNlcnMuZmlsdGVyKCh1c2VyKSA9PiB1c2VyLmlkICE9PSB1c2VySWQpXG4gICAgICAgIH0gOiByZWFjdGlvblxuICAgICAgKS5maWx0ZXIoKHJlYWN0aW9uKSA9PiByZWFjdGlvbi51c2Vycy5sZW5ndGggPiAwKVxuICAgICAgLy8gUmVtb3ZlIHJlYWN0aW9ucyB3aXRoIG5vIHVzZXJzIGxlZnRcbiAgICB9IDogY29tbWVudFxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLnRocmVhZCxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKFxuICAgICAgTWF0aC5tYXgocmVtb3ZlZEF0LmdldFRpbWUoKSwgdGhyZWFkLnVwZGF0ZWRBdD8uZ2V0VGltZSgpIHx8IDApXG4gICAgKSxcbiAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiB1cHNlcnRSZWFjdGlvbihyZWFjdGlvbnMsIHJlYWN0aW9uKSB7XG4gIGNvbnN0IGV4aXN0aW5nUmVhY3Rpb24gPSByZWFjdGlvbnMuZmluZChcbiAgICAoZXhpc3RpbmdSZWFjdGlvbjIpID0+IGV4aXN0aW5nUmVhY3Rpb24yLmVtb2ppID09PSByZWFjdGlvbi5lbW9qaVxuICApO1xuICBpZiAoZXhpc3RpbmdSZWFjdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLnJlYWN0aW9ucyxcbiAgICAgIHtcbiAgICAgICAgZW1vamk6IHJlYWN0aW9uLmVtb2ppLFxuICAgICAgICBjcmVhdGVkQXQ6IHJlYWN0aW9uLmNyZWF0ZWRBdCxcbiAgICAgICAgdXNlcnM6IFt7IGlkOiByZWFjdGlvbi51c2VySWQgfV1cbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGlmIChleGlzdGluZ1JlYWN0aW9uLnVzZXJzLnNvbWUoKHVzZXIpID0+IHVzZXIuaWQgPT09IHJlYWN0aW9uLnVzZXJJZCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHJlYWN0aW9ucy5tYXAoXG4gICAgICAoZXhpc3RpbmdSZWFjdGlvbjIpID0+IGV4aXN0aW5nUmVhY3Rpb24yLmVtb2ppID09PSByZWFjdGlvbi5lbW9qaSA/IHtcbiAgICAgICAgLi4uZXhpc3RpbmdSZWFjdGlvbjIsXG4gICAgICAgIHVzZXJzOiBbLi4uZXhpc3RpbmdSZWFjdGlvbjIudXNlcnMsIHsgaWQ6IHJlYWN0aW9uLnVzZXJJZCB9XVxuICAgICAgfSA6IGV4aXN0aW5nUmVhY3Rpb24yXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVhY3Rpb25zO1xufVxuXG4vLyBzcmMvY2xpZW50LnRzXG52YXIgTUlOX1RIUk9UVExFID0gMTY7XG52YXIgTUFYX1RIUk9UVExFID0gMWUzO1xudmFyIERFRkFVTFRfVEhST1RUTEUgPSAxMDA7XG52YXIgTUlOX0JBQ0tHUk9VTkRfS0VFUF9BTElWRV9USU1FT1VUID0gMTVlMztcbnZhciBNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAyMDA7XG52YXIgUkVDT01NRU5ERURfTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gMWUzO1xudmFyIE1BWF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDNlNDtcbnZhciBERUZBVUxUX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gNWUzO1xudmFyIFJFU09MVkVfVVNFUlNfQkFUQ0hfREVMQVkgPSA1MDtcbnZhciBSRVNPTFZFX1JPT01TX0lORk9fQkFUQ0hfREVMQVkgPSA1MDtcbmZ1bmN0aW9uIGdldEJhc2VVcmwoYmFzZVVybCkge1xuICBiYXNlVXJsIHx8IChiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTElWRUJMT0NLU19CQVNFX1VSTCB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19MSVZFQkxPQ0tTX0JBU0VfVVJMIHx8IHByb2Nlc3MuZW52LlZJVEVfTElWRUJMT0NLU19CQVNFX1VSTCB8fCB2b2lkIDApO1xuICBpZiAodHlwZW9mIGJhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgYmFzZVVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgIHJldHVybiBiYXNlVXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBERUZBVUxUX0JBU0VfVVJMO1xuICB9XG59XG5mdW5jdGlvbiBnZXRBdXRoQmVhcmVySGVhZGVyRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpIHtcbiAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgcmV0dXJuIGF1dGhWYWx1ZS5wdWJsaWNBcGlLZXk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF1dGhWYWx1ZS50b2tlbi5yYXc7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudChvcHRpb25zKSB7XG4gIGNvbnN0IGNsaWVudE9wdGlvbnMgPSBvcHRpb25zO1xuICBjb25zdCB0aHJvdHRsZURlbGF5ID0gZ2V0VGhyb3R0bGUoY2xpZW50T3B0aW9ucy50aHJvdHRsZSA/PyBERUZBVUxUX1RIUk9UVExFKTtcbiAgY29uc3QgbG9zdENvbm5lY3Rpb25UaW1lb3V0ID0gZ2V0TG9zdENvbm5lY3Rpb25UaW1lb3V0KFxuICAgIGNsaWVudE9wdGlvbnMubG9zdENvbm5lY3Rpb25UaW1lb3V0ID8/IERFRkFVTFRfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVRcbiAgKTtcbiAgY29uc3QgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgPSBnZXRCYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dChcbiAgICBjbGllbnRPcHRpb25zLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0XG4gICk7XG4gIGNvbnN0IGJhc2VVcmwgPSBnZXRCYXNlVXJsKGNsaWVudE9wdGlvbnMuYmFzZVVybCk7XG4gIGNvbnN0IGF1dGhNYW5hZ2VyID0gY3JlYXRlQXV0aE1hbmFnZXIob3B0aW9ucyk7XG4gIGNvbnN0IHJvb21zQnlJZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIHRlYXJkb3duUm9vbShyb29tKSB7XG4gICAgdW5saW5rRGV2VG9vbHMocm9vbS5pZCk7XG4gICAgcm9vbXNCeUlkLmRlbGV0ZShyb29tLmlkKTtcbiAgICByb29tLmRlc3Ryb3koKTtcbiAgfVxuICBmdW5jdGlvbiBsZWFzZVJvb20oaW5mbykge1xuICAgIGNvbnN0IGxlYXZlID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZiA9IGxlYXZlO1xuICAgICAgaWYgKCFpbmZvLnVuc3Vicy5kZWxldGUoc2VsZikpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIlRoaXMgbGVhdmUgZnVuY3Rpb24gd2FzIGFscmVhZHkgY2FsbGVkLiBDYWxsaW5nIGl0IG1vcmUgdGhhbiBvbmNlIGhhcyBubyBlZmZlY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbmZvLnVuc3Vicy5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGVhcmRvd25Sb29tKGluZm8ucm9vbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGluZm8udW5zdWJzLmFkZChsZWF2ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb206IGluZm8ucm9vbSxcbiAgICAgIGxlYXZlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBlbnRlclJvb20ocm9vbUlkLCBvcHRpb25zMikge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gcm9vbXNCeUlkLmdldChyb29tSWQpO1xuICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGVhc2VSb29tKGV4aXN0aW5nKTtcbiAgICB9XG4gICAgZGVwcmVjYXRlSWYoXG4gICAgICBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2UgPT09IG51bGwgfHwgb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlID09PSB2b2lkIDAsXG4gICAgICBcIlBsZWFzZSBwcm92aWRlIGFuIGluaXRpYWwgcHJlc2VuY2UgdmFsdWUgZm9yIHRoZSBjdXJyZW50IHVzZXIgd2hlbiBlbnRlcmluZyB0aGUgcm9vbS5cIlxuICAgICk7XG4gICAgY29uc3QgbmV3Um9vbSA9IGNyZWF0ZVJvb20oXG4gICAgICB7XG4gICAgICAgIGluaXRpYWxQcmVzZW5jZTogb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlID8/IHt9LFxuICAgICAgICBpbml0aWFsU3RvcmFnZTogb3B0aW9uczIuaW5pdGlhbFN0b3JhZ2VcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJvb21JZCxcbiAgICAgICAgdGhyb3R0bGVEZWxheSxcbiAgICAgICAgbG9zdENvbm5lY3Rpb25UaW1lb3V0LFxuICAgICAgICBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCxcbiAgICAgICAgcG9seWZpbGxzOiBjbGllbnRPcHRpb25zLnBvbHlmaWxscyxcbiAgICAgICAgZGVsZWdhdGVzOiBjbGllbnRPcHRpb25zLm1vY2tlZERlbGVnYXRlcyA/PyB7XG4gICAgICAgICAgY3JlYXRlU29ja2V0OiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tKFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgYmFzZVVybCxcbiAgICAgICAgICAgIGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5XZWJTb2NrZXRcbiAgICAgICAgICApLFxuICAgICAgICAgIGF1dGhlbnRpY2F0ZTogbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcilcbiAgICAgICAgfSxcbiAgICAgICAgZW5hYmxlRGVidWdMb2dnaW5nOiBjbGllbnRPcHRpb25zLmVuYWJsZURlYnVnTG9nZ2luZyxcbiAgICAgICAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IG9wdGlvbnMyPy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxcbiAgICAgICAgYmFzZVVybCxcbiAgICAgICAgdW5zdGFibGVfZmFsbGJhY2tUb0hUVFA6ICEhY2xpZW50T3B0aW9ucy51bnN0YWJsZV9mYWxsYmFja1RvSFRUUCxcbiAgICAgICAgdW5zdGFibGVfc3RyZWFtRGF0YTogISFjbGllbnRPcHRpb25zLnVuc3RhYmxlX3N0cmVhbURhdGFcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IG5ld1Jvb21JbmZvID0ge1xuICAgICAgcm9vbTogbmV3Um9vbSxcbiAgICAgIHVuc3ViczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgcm9vbXNCeUlkLnNldChyb29tSWQsIG5ld1Jvb21JbmZvKTtcbiAgICBzZXR1cERldlRvb2xzKCgpID0+IEFycmF5LmZyb20ocm9vbXNCeUlkLmtleXMoKSkpO1xuICAgIGxpbmtEZXZUb29scyhyb29tSWQsIG5ld1Jvb20pO1xuICAgIGNvbnN0IHNob3VsZENvbm5lY3QgPSBvcHRpb25zMi5hdXRvQ29ubmVjdCA/PyBvcHRpb25zMi5zaG91bGRJbml0aWFsbHlDb25uZWN0ID8/IHRydWU7XG4gICAgaWYgKHNob3VsZENvbm5lY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgYXRvYiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LmF0b2IgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiWW91IG5lZWQgdG8gcG9seWZpbGwgYXRvYiB0byB1c2UgdGhlIGNsaWVudCBpbiB5b3VyIGVudmlyb25tZW50LiBQbGVhc2UgZm9sbG93IHRoZSBpbnN0cnVjdGlvbnMgYXQgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2xpdmVibG9ja3MtY2xpZW50L2F0b2ItcG9seWZpbGxcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsLmF0b2IgPSBjbGllbnRPcHRpb25zLnBvbHlmaWxscy5hdG9iO1xuICAgICAgfVxuICAgICAgbmV3Um9vbS5jb25uZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiBsZWFzZVJvb20obmV3Um9vbUluZm8pO1xuICB9XG4gIGZ1bmN0aW9uIGVudGVyKHJvb21JZCwgb3B0aW9uczIpIHtcbiAgICBjb25zdCB7IHJvb20sIGxlYXZlOiBfIH0gPSBlbnRlclJvb20ocm9vbUlkLCBvcHRpb25zMik7XG4gICAgcmV0dXJuIHJvb207XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Um9vbShyb29tSWQpIHtcbiAgICBjb25zdCByb29tID0gcm9vbXNCeUlkLmdldChyb29tSWQpPy5yb29tO1xuICAgIHJldHVybiByb29tID8gcm9vbSA6IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZm9yY2VMZWF2ZShyb29tSWQpIHtcbiAgICBjb25zdCB1bnN1YnMgPSByb29tc0J5SWQuZ2V0KHJvb21JZCk/LnVuc3VicyA/PyAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdW5zdWIgb2YgdW5zdWJzKSB7XG4gICAgICB1bnN1YigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsb2dvdXQoKSB7XG4gICAgYXV0aE1hbmFnZXIucmVzZXQoKTtcbiAgICBmb3IgKGNvbnN0IHsgcm9vbSB9IG9mIHJvb21zQnlJZC52YWx1ZXMoKSkge1xuICAgICAgaWYgKCFpc0lkbGUocm9vbS5nZXRTdGF0dXMoKSkpIHtcbiAgICAgICAgcm9vbS5yZWNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgY3VycmVudFVzZXJJZFN0b3JlID0gY3JlYXRlU3RvcmUobnVsbCk7XG4gIGNvbnN0IHtcbiAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRcbiAgfSA9IGNyZWF0ZU5vdGlmaWNhdGlvbnNBcGkoe1xuICAgIGJhc2VVcmwsXG4gICAgZmV0Y2hlcjogY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LmZldGNoIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZmV0Y2gsXG4gICAgYXV0aE1hbmFnZXIsXG4gICAgY3VycmVudFVzZXJJZFN0b3JlXG4gIH0pO1xuICBjb25zdCBjYWNoZVN0b3JlID0gY3JlYXRlQ2xpZW50U3RvcmUoKTtcbiAgY29uc3QgcmVzb2x2ZVVzZXJzID0gY2xpZW50T3B0aW9ucy5yZXNvbHZlVXNlcnM7XG4gIGNvbnN0IHdhcm5JZk5vUmVzb2x2ZVVzZXJzID0gY3JlYXRlRGV2ZWxvcG1lbnRXYXJuaW5nKFxuICAgICgpID0+ICFyZXNvbHZlVXNlcnMsXG4gICAgXCJTZXQgdGhlIHJlc29sdmVVc2VycyBvcHRpb24gaW4gY3JlYXRlQ2xpZW50IHRvIHNwZWNpZnkgdXNlciBpbmZvLlwiXG4gICk7XG4gIGNvbnN0IHVzZXJzU3RvcmUgPSBjcmVhdGVCYXRjaFN0b3JlKFxuICAgIGFzeW5jIChiYXRjaGVkVXNlcklkcykgPT4ge1xuICAgICAgY29uc3QgdXNlcklkcyA9IGJhdGNoZWRVc2VySWRzLmZsYXQoKTtcbiAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzPy4oeyB1c2VySWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlVXNlcnMoKTtcbiAgICAgIHJldHVybiB1c2VycyA/PyB1c2VySWRzLm1hcCgoKSA9PiB2b2lkIDApO1xuICAgIH0sXG4gICAgeyBkZWxheTogUkVTT0xWRV9VU0VSU19CQVRDSF9ERUxBWSB9XG4gICk7XG4gIGNvbnN0IHJlc29sdmVSb29tc0luZm8gPSBjbGllbnRPcHRpb25zLnJlc29sdmVSb29tc0luZm87XG4gIGNvbnN0IHdhcm5JZk5vUmVzb2x2ZVJvb21zSW5mbyA9IGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhcbiAgICAoKSA9PiAhcmVzb2x2ZVJvb21zSW5mbyxcbiAgICBcIlNldCB0aGUgcmVzb2x2ZVJvb21zSW5mbyBvcHRpb24gaW4gY3JlYXRlQ2xpZW50IHRvIHNwZWNpZnkgcm9vbSBpbmZvLlwiXG4gICk7XG4gIGNvbnN0IHJvb21zSW5mb1N0b3JlID0gY3JlYXRlQmF0Y2hTdG9yZShcbiAgICBhc3luYyAoYmF0Y2hlZFJvb21JZHMpID0+IHtcbiAgICAgIGNvbnN0IHJvb21JZHMgPSBiYXRjaGVkUm9vbUlkcy5mbGF0KCk7XG4gICAgICBjb25zdCByb29tc0luZm8gPSBhd2FpdCByZXNvbHZlUm9vbXNJbmZvPy4oeyByb29tSWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlUm9vbXNJbmZvKCk7XG4gICAgICByZXR1cm4gcm9vbXNJbmZvID8/IHJvb21JZHMubWFwKCgpID0+IHZvaWQgMCk7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBSRVNPTFZFX1JPT01TX0lORk9fQkFUQ0hfREVMQVkgfVxuICApO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIGxvZ291dCxcbiAgICAgIC8vIE9sZCwgZGVwcmVjYXRlZCBBUElzXG4gICAgICBlbnRlcixcbiAgICAgIGdldFJvb20sXG4gICAgICBsZWF2ZTogZm9yY2VMZWF2ZSxcbiAgICAgIC8vIE5ldywgcHJlZmVycmVkIEFQSVxuICAgICAgZW50ZXJSb29tLFxuICAgICAgLy8gSW50ZXJuYWxcbiAgICAgIFtrSW50ZXJuYWxdOiB7XG4gICAgICAgIG5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgZ2V0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gICAgICAgICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICAgICAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRcbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVudFVzZXJJZFN0b3JlLFxuICAgICAgICByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zOiBjbGllbnRPcHRpb25zLnJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMsXG4gICAgICAgIGNhY2hlU3RvcmUsXG4gICAgICAgIHVzZXJzU3RvcmUsXG4gICAgICAgIHJvb21zSW5mb1N0b3JlLFxuICAgICAgICBnZXRSb29tSWRzKCkge1xuICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHJvb21zQnlJZC5rZXlzKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBrSW50ZXJuYWwsXG4gICAge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9XG4gICk7XG59XG52YXIgTm90aWZpY2F0aW9uc0FwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgZGV0YWlscykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufTtcbmZ1bmN0aW9uIGNoZWNrQm91bmRzKG9wdGlvbiwgdmFsdWUsIG1pbiwgbWF4LCByZWNvbW1lbmRlZE1pbikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDwgbWluIHx8IG1heCAhPT0gdm9pZCAwICYmIHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgbWF4ICE9PSB2b2lkIDAgPyBgJHtvcHRpb259IHNob3VsZCBiZSBiZXR3ZWVuICR7cmVjb21tZW5kZWRNaW4gPz8gbWlufSBhbmQgJHttYXh9LmAgOiBgJHtvcHRpb259IHNob3VsZCBiZSBhdCBsZWFzdCAke3JlY29tbWVuZGVkTWluID8/IG1pbn0uYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgcmV0dXJuIGNoZWNrQm91bmRzKFxuICAgIFwiYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRcIixcbiAgICB2YWx1ZSxcbiAgICBNSU5fQkFDS0dST1VORF9LRUVQX0FMSVZFX1RJTUVPVVRcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFRocm90dGxlKHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JvdW5kcyhcInRocm90dGxlXCIsIHZhbHVlLCBNSU5fVEhST1RUTEUsIE1BWF9USFJPVFRMRSk7XG59XG5mdW5jdGlvbiBnZXRMb3N0Q29ubmVjdGlvblRpbWVvdXQodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm91bmRzKFxuICAgIFwibG9zdENvbm5lY3Rpb25UaW1lb3V0XCIsXG4gICAgdmFsdWUsXG4gICAgTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VULFxuICAgIE1BWF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCxcbiAgICBSRUNPTU1FTkRFRF9NSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVRcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhjb25kaXRpb24sIC4uLmFyZ3MpIHtcbiAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghaGFzV2FybmVkICYmICh0eXBlb2YgY29uZGl0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBjb25kaXRpb24oKSA6IGNvbmRpdGlvbikpIHtcbiAgICAgICAgd2FybiguLi5hcmdzKTtcbiAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvY29tbWVudHMvY29tbWVudC1ib2R5LnRzXG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5UGFyYWdyYXBoKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcIm1lbnRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlUZXh0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidGV4dFwiIGluIGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQudGV4dCA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlNZW50aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcIm1lbnRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlMaW5rKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcImxpbmtcIjtcbn1cbnZhciBjb21tZW50Qm9keUVsZW1lbnRzR3VhcmRzID0ge1xuICBwYXJhZ3JhcGg6IGlzQ29tbWVudEJvZHlQYXJhZ3JhcGgsXG4gIHRleHQ6IGlzQ29tbWVudEJvZHlUZXh0LFxuICBsaW5rOiBpc0NvbW1lbnRCb2R5TGluayxcbiAgbWVudGlvbjogaXNDb21tZW50Qm9keU1lbnRpb25cbn07XG52YXIgY29tbWVudEJvZHlFbGVtZW50c1R5cGVzID0ge1xuICBwYXJhZ3JhcGg6IFwiYmxvY2tcIixcbiAgdGV4dDogXCJpbmxpbmVcIixcbiAgbGluazogXCJpbmxpbmVcIixcbiAgbWVudGlvbjogXCJpbmxpbmVcIlxufTtcbmZ1bmN0aW9uIHRyYXZlcnNlQ29tbWVudEJvZHkoYm9keSwgZWxlbWVudE9yVmlzaXRvciwgcG9zc2libHlWaXNpdG9yKSB7XG4gIGlmICghYm9keSB8fCAhYm9keT8uY29udGVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gdHlwZW9mIGVsZW1lbnRPclZpc2l0b3IgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50T3JWaXNpdG9yIDogdm9pZCAwO1xuICBjb25zdCB0eXBlID0gZWxlbWVudCA/IGNvbW1lbnRCb2R5RWxlbWVudHNUeXBlc1tlbGVtZW50XSA6IFwiYWxsXCI7XG4gIGNvbnN0IGd1YXJkID0gZWxlbWVudCA/IGNvbW1lbnRCb2R5RWxlbWVudHNHdWFyZHNbZWxlbWVudF0gOiAoKSA9PiB0cnVlO1xuICBjb25zdCB2aXNpdG9yID0gdHlwZW9mIGVsZW1lbnRPclZpc2l0b3IgPT09IFwiZnVuY3Rpb25cIiA/IGVsZW1lbnRPclZpc2l0b3IgOiBwb3NzaWJseVZpc2l0b3I7XG4gIGZvciAoY29uc3QgYmxvY2sgb2YgYm9keS5jb250ZW50KSB7XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIgfHwgdHlwZSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICBpZiAoZ3VhcmQoYmxvY2spKSB7XG4gICAgICAgIHZpc2l0b3I/LihibG9jayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImFsbFwiIHx8IHR5cGUgPT09IFwiaW5saW5lXCIpIHtcbiAgICAgIGZvciAoY29uc3QgaW5saW5lIG9mIGJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChndWFyZChpbmxpbmUpKSB7XG4gICAgICAgICAgdmlzaXRvcj8uKGlubGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShib2R5KSB7XG4gIGNvbnN0IG1lbnRpb25lZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHRyYXZlcnNlQ29tbWVudEJvZHkoXG4gICAgYm9keSxcbiAgICBcIm1lbnRpb25cIixcbiAgICAobWVudGlvbikgPT4gbWVudGlvbmVkSWRzLmFkZChtZW50aW9uLmlkKVxuICApO1xuICByZXR1cm4gQXJyYXkuZnJvbShtZW50aW9uZWRJZHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keShib2R5LCByZXNvbHZlVXNlcnMpIHtcbiAgY29uc3QgcmVzb2x2ZWRVc2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGlmICghcmVzb2x2ZVVzZXJzKSB7XG4gICAgcmV0dXJuIHJlc29sdmVkVXNlcnM7XG4gIH1cbiAgY29uc3QgdXNlcklkcyA9IGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShib2R5KTtcbiAgY29uc3QgdXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnMoe1xuICAgIHVzZXJJZHNcbiAgfSk7XG4gIGZvciAoY29uc3QgW2luZGV4LCB1c2VySWRdIG9mIHVzZXJJZHMuZW50cmllcygpKSB7XG4gICAgY29uc3QgdXNlciA9IHVzZXJzPy5baW5kZXhdO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICByZXNvbHZlZFVzZXJzLnNldCh1c2VySWQsIHVzZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRVc2Vycztcbn1cbnZhciBodG1sRXNjYXBhYmxlcyA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gICdcIic6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjMzk7XCJcbn07XG52YXIgaHRtbEVzY2FwYWJsZXNSZWdleCA9IG5ldyBSZWdFeHAoXG4gIE9iamVjdC5rZXlzKGh0bWxFc2NhcGFibGVzKS5tYXAoKGVudGl0eSkgPT4gYFxcXFwke2VudGl0eX1gKS5qb2luKFwifFwiKSxcbiAgXCJnXCJcbik7XG5mdW5jdGlvbiBodG1sU2FmZSh2YWx1ZSkge1xuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFtTdHJpbmcodmFsdWUpXSwgW10pO1xufVxuZnVuY3Rpb24gam9pbkh0bWwoc3RyaW5ncykge1xuICBpZiAoc3RyaW5ncy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoW1wiXCJdLCBbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhcbiAgICBbXCJcIiwgLi4uQXJyYXkoc3RyaW5ncy5sZW5ndGggLSAxKS5maWxsKFwiXCIpLCBcIlwiXSxcbiAgICBzdHJpbmdzXG4gICk7XG59XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEh0bWxTYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGpvaW5IdG1sKHZhbHVlKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoXG4gICAgaHRtbEVzY2FwYWJsZXNSZWdleCxcbiAgICAoY2hhcmFjdGVyKSA9PiBodG1sRXNjYXBhYmxlc1tjaGFyYWN0ZXJdXG4gICk7XG59XG52YXIgSHRtbFNhZmVTdHJpbmcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlcykge1xuICAgIHRoaXMuX3N0cmluZ3MgPSBzdHJpbmdzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyaW5ncy5yZWR1Y2UoKHJlc3VsdCwgc3RyLCBpKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlSHRtbChubih0aGlzLl92YWx1ZXNbaSAtIDFdKSkgKyBzdHI7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBodG1sKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKHN0cmluZ3MsIHZhbHVlcyk7XG59XG52YXIgbWFya2Rvd25Fc2NhcGFibGVzID0ge1xuICBfOiBcIlxcXFxfXCIsXG4gIFwiKlwiOiBcIlxcXFwqXCIsXG4gIFwiI1wiOiBcIlxcXFwjXCIsXG4gIFwiYFwiOiBcIlxcXFxgXCIsXG4gIFwiflwiOiBcIlxcXFx+XCIsXG4gIFwiIVwiOiBcIlxcXFwhXCIsXG4gIFwifFwiOiBcIlxcXFx8XCIsXG4gIFwiKFwiOiBcIlxcXFwoXCIsXG4gIFwiKVwiOiBcIlxcXFwpXCIsXG4gIFwie1wiOiBcIlxcXFx7XCIsXG4gIFwifVwiOiBcIlxcXFx9XCIsXG4gIFwiW1wiOiBcIlxcXFxbXCIsXG4gIFwiXVwiOiBcIlxcXFxdXCJcbn07XG52YXIgbWFya2Rvd25Fc2NhcGFibGVzUmVnZXggPSBuZXcgUmVnRXhwKFxuICBPYmplY3Qua2V5cyhtYXJrZG93bkVzY2FwYWJsZXMpLm1hcCgoZW50aXR5KSA9PiBgXFxcXCR7ZW50aXR5fWApLmpvaW4oXCJ8XCIpLFxuICBcImdcIlxuKTtcbmZ1bmN0aW9uIGpvaW5NYXJrZG93bihzdHJpbmdzKSB7XG4gIGlmIChzdHJpbmdzLmxlbmd0aCA8PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoW1wiXCJdLCBbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBNYXJrZG93blNhZmVTdHJpbmcoXG4gICAgW1wiXCIsIC4uLkFycmF5KHN0cmluZ3MubGVuZ3RoIC0gMSkuZmlsbChcIlwiKSwgXCJcIl0sXG4gICAgc3RyaW5nc1xuICApO1xufVxuZnVuY3Rpb24gZXNjYXBlTWFya2Rvd24odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFya2Rvd25TYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGpvaW5NYXJrZG93bih2YWx1ZSkudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKFxuICAgIG1hcmtkb3duRXNjYXBhYmxlc1JlZ2V4LFxuICAgIChjaGFyYWN0ZXIpID0+IG1hcmtkb3duRXNjYXBhYmxlc1tjaGFyYWN0ZXJdXG4gICk7XG59XG52YXIgTWFya2Rvd25TYWZlU3RyaW5nID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMpIHtcbiAgICB0aGlzLl9zdHJpbmdzID0gc3RyaW5ncztcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmluZ3MucmVkdWNlKChyZXN1bHQsIHN0ciwgaSkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZU1hcmtkb3duKG5uKHRoaXMuX3ZhbHVlc1tpIC0gMV0pKSArIHN0cjtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1hcmtkb3duKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhzdHJpbmdzLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gdG9BYnNvbHV0ZVVybCh1cmwpIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCB1cmwuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfSBlbHNlIGlmICh1cmwuc3RhcnRzV2l0aChcInd3dy5cIikpIHtcbiAgICByZXR1cm4gXCJodHRwczovL1wiICsgdXJsO1xuICB9XG4gIHJldHVybjtcbn1cbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keVBsYWluRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4gY2hpbGRyZW4sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC50ZXh0LFxuICBsaW5rOiAoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQudXJsLFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gYEAke3VzZXI/Lm5hbWUgPz8gZWxlbWVudC5pZH1gO1xuICB9XG59O1xudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5SHRtbEVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICByZXR1cm4gY2hpbGRyZW4gPyBodG1sYDxwPiR7aHRtbFNhZmUoY2hpbGRyZW4pfTwvcD5gIDogY2hpbGRyZW47XG4gIH0sXG4gIHRleHQ6ICh7IGVsZW1lbnQgfSkgPT4ge1xuICAgIGxldCBjaGlsZHJlbiA9IGVsZW1lbnQudGV4dDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmJvbGQpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8c3Ryb25nPiR7Y2hpbGRyZW59PC9zdHJvbmc+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaXRhbGljKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPGVtPiR7Y2hpbGRyZW59PC9lbT5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5zdHJpa2V0aHJvdWdoKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPHM+JHtjaGlsZHJlbn08L3M+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuY29kZSkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxjb2RlPiR7Y2hpbGRyZW59PC9jb2RlPmA7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgbGluazogKHsgZWxlbWVudCwgaHJlZiB9KSA9PiB7XG4gICAgcmV0dXJuIGh0bWxgPGEgaHJlZj1cIiR7aHJlZn1cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCI+JHtlbGVtZW50LnVybH08L2E+YDtcbiAgfSxcbiAgbWVudGlvbjogKHsgZWxlbWVudCwgdXNlciB9KSA9PiB7XG4gICAgcmV0dXJuIGh0bWxgPHNwYW4gZGF0YS1tZW50aW9uPkAke3VzZXI/Lm5hbWUgPz8gZWxlbWVudC5pZH08L3NwYW4+YDtcbiAgfVxufTtcbnZhciBzdHJpbmdpZnlDb21tZW50Qm9keU1hcmtkb3duRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiB7XG4gICAgbGV0IGNoaWxkcmVuID0gZWxlbWVudC50ZXh0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuYm9sZCkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmAqKiR7Y2hpbGRyZW59KipgO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pdGFsaWMpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gXyR7Y2hpbGRyZW59X2A7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnN0cmlrZXRocm91Z2gpIHtcbiAgICAgIGNoaWxkcmVuID0gbWFya2Rvd25gfn4ke2NoaWxkcmVufX5+YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuY29kZSkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmBcXGAke2NoaWxkcmVufVxcYGA7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgbGluazogKHsgZWxlbWVudCwgaHJlZiB9KSA9PiB7XG4gICAgcmV0dXJuIG1hcmtkb3duYFske2VsZW1lbnQudXJsfV0oJHtocmVmfSlgO1xuICB9LFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd25gQCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfWA7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBzdHJpbmdpZnlDb21tZW50Qm9keShib2R5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnM/LmZvcm1hdCA/PyBcInBsYWluXCI7XG4gIGNvbnN0IHNlcGFyYXRvciA9IG9wdGlvbnM/LnNlcGFyYXRvciA/PyAoZm9ybWF0ID09PSBcIm1hcmtkb3duXCIgPyBcIlxcblxcblwiIDogXCJcXG5cIik7XG4gIGNvbnN0IGVsZW1lbnRzID0ge1xuICAgIC4uLmZvcm1hdCA9PT0gXCJodG1sXCIgPyBzdHJpbmdpZnlDb21tZW50Qm9keUh0bWxFbGVtZW50cyA6IGZvcm1hdCA9PT0gXCJtYXJrZG93blwiID8gc3RyaW5naWZ5Q29tbWVudEJvZHlNYXJrZG93bkVsZW1lbnRzIDogc3RyaW5naWZ5Q29tbWVudEJvZHlQbGFpbkVsZW1lbnRzLFxuICAgIC4uLm9wdGlvbnM/LmVsZW1lbnRzXG4gIH07XG4gIGNvbnN0IHJlc29sdmVkVXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5KFxuICAgIGJvZHksXG4gICAgb3B0aW9ucz8ucmVzb2x2ZVVzZXJzXG4gICk7XG4gIGNvbnN0IGJsb2NrcyA9IGJvZHkuY29udGVudC5mbGF0TWFwKChibG9jaywgYmxvY2tJbmRleCkgPT4ge1xuICAgIHN3aXRjaCAoYmxvY2sudHlwZSkge1xuICAgICAgY2FzZSBcInBhcmFncmFwaFwiOiB7XG4gICAgICAgIGNvbnN0IGlubGluZXMgPSBibG9jay5jaGlsZHJlbi5mbGF0TWFwKChpbmxpbmUsIGlubGluZUluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlNZW50aW9uKGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmxpbmUuaWQgPyBbXG4gICAgICAgICAgICAgIGVsZW1lbnRzLm1lbnRpb24oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogaW5saW5lLFxuICAgICAgICAgICAgICAgICAgdXNlcjogcmVzb2x2ZWRVc2Vycy5nZXQoaW5saW5lLmlkKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSA6IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keUxpbmsoaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgZWxlbWVudHMubGluayhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBpbmxpbmUsXG4gICAgICAgICAgICAgICAgICBocmVmOiB0b0Fic29sdXRlVXJsKGlubGluZS51cmwpID8/IGlubGluZS51cmxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlubGluZUluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5VGV4dChpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VsZW1lbnRzLnRleHQoeyBlbGVtZW50OiBpbmxpbmUgfSwgaW5saW5lSW5kZXgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBlbGVtZW50cy5wYXJhZ3JhcGgoXG4gICAgICAgICAgICB7IGVsZW1lbnQ6IGJsb2NrLCBjaGlsZHJlbjogaW5saW5lcy5qb2luKFwiXCIpIH0sXG4gICAgICAgICAgICBibG9ja0luZGV4XG4gICAgICAgICAgKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBibG9ja3Muam9pbihzZXBhcmF0b3IpO1xufVxuXG4vLyBzcmMvY3JkdHMvdXRpbHMudHNcbmZ1bmN0aW9uIHRvUGxhaW5Mc29uKGxzb24pIHtcbiAgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdmVibG9ja3NUeXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIGRhdGE6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMobHNvbi50b09iamVjdCgpKS5mbGF0TWFwKFxuICAgICAgICAgIChba2V5LCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDAgPyBbW2tleSwgdG9QbGFpbkxzb24odmFsdWUpXV0gOiBbXVxuICAgICAgICApXG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZU1hcCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICBkYXRhOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIFsuLi5sc29uXS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleSwgdG9QbGFpbkxzb24odmFsdWUpXSlcbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlTGlzdCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlTGlzdFwiLFxuICAgICAgZGF0YTogWy4uLmxzb25dLm1hcCgoaXRlbSkgPT4gdG9QbGFpbkxzb24oaXRlbSkpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbHNvbjtcbiAgfVxufVxuXG4vLyBzcmMvaW1tdXRhYmxlLnRzXG5mdW5jdGlvbiBsc29uT2JqZWN0VG9Kc29uKG9iaikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgY29uc3QgdmFsID0gb2JqW2tleV07XG4gICAgaWYgKHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGxzb25Ub0pzb24odmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxpdmVPYmplY3RUb0pzb24obGl2ZU9iamVjdCkge1xuICByZXR1cm4gbHNvbk9iamVjdFRvSnNvbihsaXZlT2JqZWN0LnRvT2JqZWN0KCkpO1xufVxuZnVuY3Rpb24gbGl2ZU1hcFRvSnNvbihtYXApIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICByZXN1bHRba2V5XSA9IGxzb25Ub0pzb24odmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsc29uTGlzdFRvSnNvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUubWFwKGxzb25Ub0pzb24pO1xufVxuZnVuY3Rpb24gbGl2ZUxpc3RUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIGxzb25MaXN0VG9Kc29uKHZhbHVlLnRvQXJyYXkoKSk7XG59XG5mdW5jdGlvbiBsc29uVG9Kc29uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gbGl2ZU9iamVjdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdCkge1xuICAgIHJldHVybiBsaXZlTGlzdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwKSB7XG4gICAgcmV0dXJuIGxpdmVNYXBUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlLmRhdGE7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGxzb25MaXN0VG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBsc29uT2JqZWN0VG9Kc29uKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBkZWVwTGl2ZWlmeSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IExpdmVMaXN0KHZhbHVlLm1hcChkZWVwTGl2ZWlmeSkpO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgY29uc3QgaW5pdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICBjb25zdCB2YWwgPSB2YWx1ZVtrZXldO1xuICAgICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaW5pdFtrZXldID0gZGVlcExpdmVpZnkodmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMaXZlT2JqZWN0KGluaXQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hMaXZlTGlzdChsaXZlTGlzdCwgcHJldiwgbmV4dCkge1xuICBsZXQgaSA9IDA7XG4gIGxldCBwcmV2RW5kID0gcHJldi5sZW5ndGggLSAxO1xuICBsZXQgbmV4dEVuZCA9IG5leHQubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZOb2RlID0gcHJldlswXTtcbiAgbGV0IG5leHROb2RlID0gbmV4dFswXTtcbiAgb3V0ZXI6IHtcbiAgICB3aGlsZSAocHJldk5vZGUgPT09IG5leHROb2RlKSB7XG4gICAgICArK2k7XG4gICAgICBpZiAoaSA+IHByZXZFbmQgfHwgaSA+IG5leHRFbmQpIHtcbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBwcmV2Tm9kZSA9IHByZXZbaV07XG4gICAgICBuZXh0Tm9kZSA9IG5leHRbaV07XG4gICAgfVxuICAgIHByZXZOb2RlID0gcHJldltwcmV2RW5kXTtcbiAgICBuZXh0Tm9kZSA9IG5leHRbbmV4dEVuZF07XG4gICAgd2hpbGUgKHByZXZOb2RlID09PSBuZXh0Tm9kZSkge1xuICAgICAgcHJldkVuZC0tO1xuICAgICAgbmV4dEVuZC0tO1xuICAgICAgaWYgKGkgPiBwcmV2RW5kIHx8IGkgPiBuZXh0RW5kKSB7XG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgcHJldk5vZGUgPSBwcmV2W3ByZXZFbmRdO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W25leHRFbmRdO1xuICAgIH1cbiAgfVxuICBpZiAoaSA+IHByZXZFbmQpIHtcbiAgICBpZiAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICB3aGlsZSAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICAgIGxpdmVMaXN0Lmluc2VydChkZWVwTGl2ZWlmeShuZXh0W2ldKSwgaSk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaSA+IG5leHRFbmQpIHtcbiAgICBsZXQgbG9jYWxJID0gaTtcbiAgICB3aGlsZSAobG9jYWxJIDw9IHByZXZFbmQpIHtcbiAgICAgIGxpdmVMaXN0LmRlbGV0ZShpKTtcbiAgICAgIGxvY2FsSSsrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoaSA8PSBwcmV2RW5kICYmIGkgPD0gbmV4dEVuZCkge1xuICAgICAgcHJldk5vZGUgPSBwcmV2W2ldO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W2ldO1xuICAgICAgY29uc3QgbGl2ZUxpc3ROb2RlID0gbGl2ZUxpc3QuZ2V0KGkpO1xuICAgICAgaWYgKGlzTGl2ZU9iamVjdChsaXZlTGlzdE5vZGUpICYmIGlzUGxhaW5PYmplY3QocHJldk5vZGUpICYmIGlzUGxhaW5PYmplY3QobmV4dE5vZGUpKSB7XG4gICAgICAgIHBhdGNoTGl2ZU9iamVjdChsaXZlTGlzdE5vZGUsIHByZXZOb2RlLCBuZXh0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXZlTGlzdC5zZXQoaSwgZGVlcExpdmVpZnkobmV4dE5vZGUpKTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgd2hpbGUgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgbGl2ZUxpc3QuaW5zZXJ0KGRlZXBMaXZlaWZ5KG5leHRbaV0pLCBpKTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgbGV0IGxvY2FsSSA9IGk7XG4gICAgd2hpbGUgKGxvY2FsSSA8PSBwcmV2RW5kKSB7XG4gICAgICBsaXZlTGlzdC5kZWxldGUoaSk7XG4gICAgICBsb2NhbEkrKztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZU9iamVjdEtleShsaXZlT2JqZWN0LCBrZXksIHByZXYsIG5leHQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IG5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5leHQpO1xuICAgIGlmIChub25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgZXJyb3IyKFxuICAgICAgICBgTmV3IHN0YXRlIHBhdGg6ICcke25vblNlcmlhbGl6YWJsZVZhbHVlLnBhdGh9JyB2YWx1ZTogJyR7U3RyaW5nKFxuICAgICAgICAgIG5vblNlcmlhbGl6YWJsZVZhbHVlLnZhbHVlXG4gICAgICAgICl9JyBpcyBub3Qgc2VyaWFsaXphYmxlLlxuT25seSBzZXJpYWxpemFibGUgdmFsdWUgY2FuIGJlIHN5bmNlZCB3aXRoIExpdmVibG9ja3MuYFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBsaXZlT2JqZWN0LmdldChrZXkpO1xuICBpZiAobmV4dCA9PT0gdm9pZCAwKSB7XG4gICAgbGl2ZU9iamVjdC5kZWxldGUoa2V5KTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgbGl2ZU9iamVjdC5zZXQoa2V5LCBkZWVwTGl2ZWlmeShuZXh0KSk7XG4gIH0gZWxzZSBpZiAocHJldiA9PT0gbmV4dCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpc0xpdmVMaXN0KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHByZXYpICYmIEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICBwYXRjaExpdmVMaXN0KHZhbHVlLCBwcmV2LCBuZXh0KTtcbiAgfSBlbHNlIGlmIChpc0xpdmVPYmplY3QodmFsdWUpICYmIGlzUGxhaW5PYmplY3QocHJldikgJiYgaXNQbGFpbk9iamVjdChuZXh0KSkge1xuICAgIHBhdGNoTGl2ZU9iamVjdCh2YWx1ZSwgcHJldiwgbmV4dCk7XG4gIH0gZWxzZSB7XG4gICAgbGl2ZU9iamVjdC5zZXQoa2V5LCBkZWVwTGl2ZWlmeShuZXh0KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZU9iamVjdChyb290LCBwcmV2LCBuZXh0KSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgIHBhdGNoTGl2ZU9iamVjdEtleShyb290LCBrZXksIHByZXZba2V5XSwgbmV4dFtrZXldKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgaWYgKG5leHRba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICByb290LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuICBpZiAoT2JqZWN0LmtleXModXBkYXRlcykubGVuZ3RoID4gMCkge1xuICAgIHJvb3QudXBkYXRlKHVwZGF0ZXMpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRzUGF0aChub2RlKSB7XG4gIGNvbnN0IHBhdGggPSBbXTtcbiAgd2hpbGUgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICBpZiAoaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgcGF0aC5wdXNoKG5vZGUucGFyZW50Lm5vZGUuX2luZGV4T2ZQb3NpdGlvbihub2RlLnBhcmVudC5rZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5wdXNoKG5vZGUucGFyZW50LmtleSk7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudC5ub2RlO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0KHN0YXRlLCB1cGRhdGVzKSB7XG4gIHJldHVybiB1cGRhdGVzLnJlZHVjZShcbiAgICAoc3RhdGUyLCB1cGRhdGUpID0+IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdFdpdGhVcGRhdGUoc3RhdGUyLCB1cGRhdGUpLFxuICAgIHN0YXRlXG4gICk7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3RXaXRoVXBkYXRlKHN0YXRlLCB1cGRhdGUpIHtcbiAgY29uc3QgcGF0aCA9IGdldFBhcmVudHNQYXRoKHVwZGF0ZS5ub2RlKTtcbiAgcmV0dXJuIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUoc3RhdGUsIHBhdGgsIHVwZGF0ZSk7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKHN0YXRlLCBwYXRoLCB1cGRhdGUpIHtcbiAgY29uc3QgcGF0aEl0ZW0gPSBwYXRoLnBvcCgpO1xuICBpZiAocGF0aEl0ZW0gPT09IHZvaWQgMCkge1xuICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJMaXZlT2JqZWN0XCI6IHtcbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVPYmplY3QgYnV0IHN0YXRlIHdhcyBub3QgYW4gb2JqZWN0XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSB1cGRhdGUubm9kZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gbHNvblRvSnNvbih2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJMaXZlTGlzdFwiOiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZUxpc3QgYnV0IHN0YXRlIHdhcyBub3QgYW4gYXJyYXlcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1N0YXRlID0gc3RhdGUubWFwKCh4KSA9PiB4KTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0VXBkYXRlIG9mIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgICAgICAgbmV3U3RhdGUgPSBuZXdTdGF0ZS5tYXAoXG4gICAgICAgICAgICAgIChpdGVtLCBpbmRleCkgPT4gaW5kZXggPT09IGxpc3RVcGRhdGUuaW5kZXggPyBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSkgOiBpdGVtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcImluc2VydFwiKSB7XG4gICAgICAgICAgICBpZiAobGlzdFVwZGF0ZS5pbmRleCA9PT0gbmV3U3RhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlLnB1c2gobHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUuaW5kZXgpLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4KVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZS5zcGxpY2UobGlzdFVwZGF0ZS5pbmRleCwgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwibW92ZVwiKSB7XG4gICAgICAgICAgICBpZiAobGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ID4gbGlzdFVwZGF0ZS5pbmRleCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLmluZGV4KSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleCwgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4KSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggKyAxKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4KSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShcbiAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlLmluZGV4ICsgMVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXggKyAxKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTGl2ZU1hcFwiOiB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlTWFwIGJ1dCBzdGF0ZSB3YXMgbm90IGFuIG9iamVjdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB1cGRhdGUubm9kZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBsc29uVG9Kc29uKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnN0YXRlXTtcbiAgICBuZXdBcnJheVtwYXRoSXRlbV0gPSBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKFxuICAgICAgc3RhdGVbcGF0aEl0ZW1dLFxuICAgICAgcGF0aCxcbiAgICAgIHVwZGF0ZVxuICAgICk7XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9IGVsc2UgaWYgKGlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICBjb25zdCBub2RlID0gc3RhdGVbcGF0aEl0ZW1dO1xuICAgIGlmIChub2RlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhdGVBc09iaiA9IHN0YXRlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGVBc09iaixcbiAgICAgICAgW3BhdGhJdGVtXTogbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShub2RlLCBwYXRoLCB1cGRhdGUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9Qb2xsZXIudHNcbmZ1bmN0aW9uIG1ha2VQb2xsZXIoY2FsbGJhY2spIHtcbiAgbGV0IGNvbnRleHQgPSB7XG4gICAgc3RhdGU6IFwic3RvcHBlZFwiLFxuICAgIHRpbWVvdXRIYW5kbGU6IG51bGwsXG4gICAgaW50ZXJ2YWw6IG51bGwsXG4gICAgbGFzdFNjaGVkdWxlZEF0OiBudWxsLFxuICAgIHJlbWFpbmluZ0ludGVydmFsOiBudWxsXG4gIH07XG4gIGZ1bmN0aW9uIHBvbGwoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICBzY2hlZHVsZShjb250ZXh0LmludGVydmFsKTtcbiAgICB9XG4gICAgdm9pZCBjYWxsYmFjaygpO1xuICB9XG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGludGVydmFsKSB7XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInJ1bm5pbmdcIixcbiAgICAgIGludGVydmFsOiBjb250ZXh0LnN0YXRlICE9PSBcInN0b3BwZWRcIiA/IGNvbnRleHQuaW50ZXJ2YWwgOiBpbnRlcnZhbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICB0aW1lb3V0SGFuZGxlOiBzZXRUaW1lb3V0KHBvbGwsIGludGVydmFsKSxcbiAgICAgIHJlbWFpbmluZ0ludGVydmFsOiBudWxsXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzY2hlZHVsZVJlbWFpbmluZyhyZW1haW5pbmcpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gXCJwYXVzZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0ID0ge1xuICAgICAgc3RhdGU6IFwicnVubmluZ1wiLFxuICAgICAgaW50ZXJ2YWw6IGNvbnRleHQuaW50ZXJ2YWwsXG4gICAgICBsYXN0U2NoZWR1bGVkQXQ6IGNvbnRleHQubGFzdFNjaGVkdWxlZEF0LFxuICAgICAgdGltZW91dEhhbmRsZTogc2V0VGltZW91dChwb2xsLCByZW1haW5pbmcpLFxuICAgICAgcmVtYWluaW5nSW50ZXJ2YWw6IG51bGxcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0KGludGVydmFsKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlKGludGVydmFsKTtcbiAgfVxuICBmdW5jdGlvbiByZXN0YXJ0KGludGVydmFsKSB7XG4gICAgc3RvcCgpO1xuICAgIHN0YXJ0KGludGVydmFsKTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gXCJydW5uaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQudGltZW91dEhhbmRsZSk7XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInBhdXNlZFwiLFxuICAgICAgaW50ZXJ2YWw6IGNvbnRleHQuaW50ZXJ2YWwsXG4gICAgICBsYXN0U2NoZWR1bGVkQXQ6IGNvbnRleHQubGFzdFNjaGVkdWxlZEF0LFxuICAgICAgdGltZW91dEhhbmRsZTogbnVsbCxcbiAgICAgIHJlbWFpbmluZ0ludGVydmFsOiBjb250ZXh0LmludGVydmFsIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gY29udGV4dC5sYXN0U2NoZWR1bGVkQXQpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgIT09IFwicGF1c2VkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZWR1bGVSZW1haW5pbmcoY29udGV4dC5yZW1haW5pbmdJbnRlcnZhbCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSA9PT0gXCJzdG9wcGVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQudGltZW91dEhhbmRsZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQudGltZW91dEhhbmRsZSk7XG4gICAgfVxuICAgIGNvbnRleHQgPSB7XG4gICAgICBzdGF0ZTogXCJzdG9wcGVkXCIsXG4gICAgICBpbnRlcnZhbDogbnVsbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogbnVsbCxcbiAgICAgIHRpbWVvdXRIYW5kbGU6IG51bGwsXG4gICAgICByZW1haW5pbmdJbnRlcnZhbDogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydCxcbiAgICByZXN0YXJ0LFxuICAgIHBhdXNlLFxuICAgIHJlc3VtZSxcbiAgICBzdG9wXG4gIH07XG59XG5cbi8vIHNyYy9saWIvc2hhbGxvdy50c1xuZnVuY3Rpb24gc2hhbGxvd0FycmF5KHhzLCB5cykge1xuICBpZiAoeHMubGVuZ3RoICE9PSB5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmlzKHhzW2ldLCB5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzaGFsbG93T2JqKG9iakEsIG9iakIpIHtcbiAgaWYgKHR5cGVvZiBvYmpBICE9PSBcIm9iamVjdFwiIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09IFwib2JqZWN0XCIgfHwgb2JqQiA9PT0gbnVsbCB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqQSkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iakIpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iakIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5c0EuZXZlcnkoXG4gICAgKGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkgJiYgT2JqZWN0LmlzKG9iakFba2V5XSwgb2JqQltrZXldKVxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvdyhhLCBiKSB7XG4gIGlmIChPYmplY3QuaXMoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gIGNvbnN0IGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgaWYgKGlzQXJyYXlBIHx8IGlzQXJyYXlCKSB7XG4gICAgaWYgKCFpc0FycmF5QSB8fCAhaXNBcnJheUIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWxsb3dBcnJheShhLCBiKTtcbiAgfVxuICByZXR1cm4gc2hhbGxvd09iaihhLCBiKTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5kZXRlY3REdXBlcyhQS0dfTkFNRSwgUEtHX1ZFUlNJT04sIFBLR19GT1JNQVQpO1xuZXhwb3J0IHtcbiAgQ2xpZW50TXNnQ29kZSxcbiAgQ29tbWVudHNBcGlFcnJvcixcbiAgQ3JkdFR5cGUsXG4gIExpdmVMaXN0LFxuICBMaXZlTWFwLFxuICBMaXZlT2JqZWN0LFxuICBOb3RpZmljYXRpb25zQXBpRXJyb3IsXG4gIE9wQ29kZSxcbiAgU2VydmVyTXNnQ29kZSxcbiAgV2Vic29ja2V0Q2xvc2VDb2RlcyxcbiAgYWNrT3AsXG4gIGFkZFJlYWN0aW9uLFxuICBhcHBseU9wdGltaXN0aWNVcGRhdGVzLFxuICBhc1BvcyxcbiAgYXNzZXJ0LFxuICBhc3NlcnROZXZlcixcbiAgYjY0ZGVjb2RlLFxuICBjbG9uZUxzb24sXG4gIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyBhcyBjb25zb2xlLFxuICBjb252ZXJ0VG9Db21tZW50RGF0YSxcbiAgY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbixcbiAgY29udmVydFRvVGhyZWFkRGF0YSxcbiAgY3JlYXRlQ2xpZW50LFxuICBkZWxldGVDb21tZW50LFxuICBkZXByZWNhdGUsXG4gIGRlcHJlY2F0ZUlmLFxuICBkZXRlY3REdXBlcyxcbiAgZXJyb3JJZixcbiAgZnJlZXplLFxuICBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHksXG4gIGlzQ2hpbGRDcmR0LFxuICBpc0pzb25BcnJheSxcbiAgaXNKc29uT2JqZWN0LFxuICBpc0pzb25TY2FsYXIsXG4gIGlzTGl2ZU5vZGUsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzUm9vdENyZHQsXG4gIGtJbnRlcm5hbCxcbiAgbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0LFxuICBsc29uVG9Kc29uLFxuICBtYWtlRXZlbnRTb3VyY2UsXG4gIG1ha2VQb2xsZXIsXG4gIG1ha2VQb3NpdGlvbixcbiAgbm4sXG4gIHBhdGNoTGl2ZU9iamVjdEtleSxcbiAgcmFpc2UsXG4gIHJlbW92ZVJlYWN0aW9uLFxuICBzaGFsbG93LFxuICBzdHJpbmdpZnksXG4gIHN0cmluZ2lmeUNvbW1lbnRCb2R5LFxuICB0aHJvd1VzYWdlRXJyb3IsXG4gIHRvUGxhaW5Mc29uLFxuICB0cnlQYXJzZUpzb24sXG4gIHVwc2VydENvbW1lbnQsXG4gIHdpdGhUaW1lb3V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientSideSuspense: () => (/* binding */ ClientSideSuspense),\n/* harmony export */   createLiveblocksContext: () => (/* binding */ createLiveblocksContext),\n/* harmony export */   createRoomContext: () => (/* binding */ createRoomContext),\n/* harmony export */   shallow: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow),\n/* harmony export */   useLiveblocksContextBundle: () => (/* binding */ useLiveblocksContextBundle),\n/* harmony export */   useRoomContextBundle: () => (/* binding */ useRoomContextBundle),\n/* harmony export */   useSharedContextBundle: () => (/* binding */ useSharedContextBundle)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/client */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nanoid */ \"(ssr)/./node_modules/nanoid/index.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n/* __next_internal_client_entry_do_not_use__ ClientSideSuspense,createLiveblocksContext,createRoomContext,shallow,useLiveblocksContextBundle,useRoomContextBundle,useSharedContextBundle auto */ // src/index.ts\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/react\";\nvar PKG_VERSION = \"1.10.2\";\nvar PKG_FORMAT = \"esm\";\n// src/ClientSideSuspense.tsx\n\nfunction ClientSideSuspense(props) {\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n        fallback: props.fallback\n    }, mounted ? props.children() : props.fallback);\n}\n// src/liveblocks.tsx\n\n\n\n\n\n// src/comments/lib/selected-inbox-notifications.ts\n\nfunction selectedInboxNotifications(state) {\n    const result = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.applyOptimisticUpdates)(state);\n    return Object.values(result.inboxNotifications).sort(// Sort so that the most recent notifications are first\n    (a, b)=>b.notifiedAt.getTime() - a.notifiedAt.getTime());\n}\n// src/lib/retry-error.ts\nvar MAX_ERROR_RETRY_COUNT = 5;\nvar ERROR_RETRY_INTERVAL = 5e3;\nfunction retryError(action, retryCount) {\n    if (retryCount >= MAX_ERROR_RETRY_COUNT) return;\n    const timeout = Math.pow(2, retryCount) * ERROR_RETRY_INTERVAL;\n    setTimeout(()=>{\n        void action();\n    }, timeout);\n}\n// src/shared.ts\n\n\n\n// src/room.tsx\n\n\n\n\n\n// src/comments/errors.ts\nvar CreateThreadError = class extends Error {\n    constructor(cause, context){\n        super(\"Create thread failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"CreateThreadError\";\n    }\n};\nvar EditThreadMetadataError = class extends Error {\n    constructor(cause, context){\n        super(\"Edit thread metadata failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"EditThreadMetadataError\";\n    }\n};\nvar CreateCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Create comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"CreateCommentError\";\n    }\n};\nvar EditCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Edit comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"EditCommentError\";\n    }\n};\nvar DeleteCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Delete comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"DeleteCommentError\";\n    }\n};\nvar AddReactionError = class extends Error {\n    constructor(cause, context){\n        super(\"Add reaction failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"AddReactionError\";\n    }\n};\nvar RemoveReactionError = class extends Error {\n    constructor(cause, context){\n        super(\"Remove reaction failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"RemoveReactionError\";\n    }\n};\nvar MarkInboxNotificationAsReadError = class extends Error {\n    constructor(cause, context){\n        super(\"Mark inbox notification as read failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"MarkInboxNotificationAsReadError\";\n    }\n};\nvar UpdateNotificationSettingsError = class extends Error {\n    constructor(cause, context){\n        super(\"Update notification settings failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"UpdateNotificationSettingsError\";\n    }\n};\n// src/comments/lib/createIds.ts\n\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nfunction createOptimisticId(prefix) {\n    return `${prefix}_${(0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)()}`;\n}\nfunction createThreadId() {\n    return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n    return createOptimisticId(COMMENT_ID_PREFIX);\n}\n// src/comments/lib/select-notification-settings.ts\n\nfunction selectNotificationSettings(roomId, state) {\n    const { notificationSettings } = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.applyOptimisticUpdates)(state);\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.nn)(notificationSettings[roomId]);\n}\n// src/comments/lib/selected-threads.ts\n\nfunction selectedThreads(roomId, state, options) {\n    const result = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.applyOptimisticUpdates)(state);\n    const threads = Object.values(result.threads).filter((thread)=>{\n        if (thread.roomId !== roomId) return false;\n        if (thread.deletedAt !== void 0) {\n            return false;\n        }\n        const query = options.query;\n        if (!query) return true;\n        for(const key in query.metadata){\n            if (thread.metadata[key] !== query.metadata[key]) {\n                return false;\n            }\n        }\n        return true;\n    });\n    return threads.sort((a, b)=>a.createdAt.getTime() - b.createdAt.getTime());\n}\n// src/lib/use-initial.ts\n\nfunction useInitial(value) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(value)[0];\n}\n// src/lib/use-latest.ts\n\nfunction useLatest(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref;\n}\n// src/lib/use-rerender.ts\n\nfunction useRerender() {\n    const [, update] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(// This implementation works by incrementing a hidden counter value that is\n    // never consumed. Simply incrementing the counter changes the component's\n    // state and, thus, trigger a re-render.\n    (x)=>x + 1, 0);\n    return update;\n}\n// src/room.tsx\nvar noop = ()=>{};\nvar identity = (x)=>x;\nvar missing_unstable_batchedUpdates = (reactVersion, roomId)=>`We noticed you\\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\\u2019re ready to upgrade to React 18:\n\n    import { unstable_batchedUpdates } from \"react-dom\";  // or \"react-native\"\n\n    <RoomProvider id=${JSON.stringify(roomId)} ... unstable_batchedUpdates={unstable_batchedUpdates}>\n      ...\n    </RoomProvider>\n\nWhy? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;\nvar superfluous_unstable_batchedUpdates = \"You don’t need to pass unstable_batchedUpdates to RoomProvider anymore, since you’re on React 18+ already.\";\nfunction useSyncExternalStore(s, gs, gss) {\n    return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(s, gs, gss, identity);\n}\nvar STABLE_EMPTY_LIST = Object.freeze([]);\nvar POLLING_INTERVAL = 5 * 60 * 1e3;\nvar MENTION_SUGGESTIONS_DEBOUNCE = 500;\nfunction alwaysEmptyList() {\n    return STABLE_EMPTY_LIST;\n}\nfunction alwaysNull() {\n    return null;\n}\nfunction makeMutationContext(room) {\n    const errmsg = \"This mutation cannot be used until connected to the Liveblocks room\";\n    return {\n        get storage () {\n            const mutableRoot = room.getStorageSnapshot();\n            if (mutableRoot === null) {\n                throw new Error(errmsg);\n            }\n            return mutableRoot;\n        },\n        get self () {\n            const self = room.getSelf();\n            if (self === null) {\n                throw new Error(errmsg);\n            }\n            return self;\n        },\n        get others () {\n            const others = room.getOthers();\n            if (room.getSelf() === null) {\n                throw new Error(errmsg);\n            }\n            return others;\n        },\n        setMyPresence: room.updatePresence\n    };\n}\nvar ContextBundle = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useRoomContextBundle() {\n    const bundle = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ContextBundle);\n    if (bundle === null) {\n        throw new Error(\"RoomProvider is missing from the React tree.\");\n    }\n    return bundle;\n}\nfunction createRoomContext(client, options) {\n    if (options?.resolveUsers) {\n        throw new Error(\"The 'resolveUsers' option has moved to 'createClient' from '@liveblocks/client'. Please refer to our Upgrade Guide to learn more, see https://liveblocks.io/docs/platform/upgrading/1.10.\");\n    }\n    if (options?.resolveMentionSuggestions) {\n        throw new Error(\"The 'resolveMentionSuggestions' option has moved to 'createClient' from '@liveblocks/client'. Please refer to our Upgrade Guide to learn more, see https://liveblocks.io/docs/platform/upgrading/1.10.\");\n    }\n    const RoomContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n    const commentsErrorEventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n    const shared = createSharedContext(client);\n    function RoomProviderOuter(props) {\n        const [cache] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>/* @__PURE__ */ new Map());\n        const stableEnterRoom = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((roomId, options2)=>{\n            const cached = cache.get(roomId);\n            if (cached) return cached;\n            const rv = client.enterRoom(roomId, options2);\n            const origLeave = rv.leave;\n            rv.leave = ()=>{\n                origLeave();\n                cache.delete(roomId);\n            };\n            cache.set(roomId, rv);\n            return rv;\n        }, [\n            cache\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomProviderInner, {\n            ...props,\n            stableEnterRoom\n        });\n    }\n    function RoomProviderInner(props) {\n        const { id: roomId, stableEnterRoom } = props;\n        if (true) {\n            if (!roomId) {\n                throw new Error(\"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\");\n            }\n            if (typeof roomId !== \"string\") {\n                throw new Error(\"RoomProvider id property should be a string.\");\n            }\n            const majorReactVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version) || 1;\n            const oldReactVersion = majorReactVersion < 18;\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.errorIf)(oldReactVersion && props.unstable_batchedUpdates === void 0, missing_unstable_batchedUpdates(majorReactVersion, roomId));\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.deprecateIf)(!oldReactVersion && props.unstable_batchedUpdates !== void 0, superfluous_unstable_batchedUpdates);\n        }\n        const frozenProps = useInitial({\n            initialPresence: props.initialPresence,\n            initialStorage: props.initialStorage,\n            unstable_batchedUpdates: props.unstable_batchedUpdates,\n            autoConnect: props.autoConnect ?? props.shouldInitiallyConnect ?? \"undefined\" !== \"undefined\"\n        });\n        const [{ room }, setRoomLeavePair] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>stableEnterRoom(roomId, {\n                ...frozenProps,\n                autoConnect: false\n            }));\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            async function handleCommentEvent(message) {\n                const info = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.getThread({\n                    threadId: message.threadId\n                });\n                if (!info) {\n                    store.deleteThread(message.threadId);\n                    return;\n                }\n                const { thread, inboxNotification } = info;\n                const existingThread = store.get().threads[message.threadId];\n                switch(message.type){\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_EDITED:\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.THREAD_METADATA_UPDATED:\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_REACTION_ADDED:\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_REACTION_REMOVED:\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_DELETED:\n                        if (!existingThread) break;\n                        store.updateThreadAndNotification(thread, inboxNotification);\n                        break;\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_CREATED:\n                        store.updateThreadAndNotification(thread, inboxNotification);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            return room.events.comments.subscribe((message)=>void handleCommentEvent(message));\n        }, [\n            room\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            void getThreadsUpdates(room.id);\n        }, [\n            room.id\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            function handleIsOnline() {\n                void getThreadsUpdates(room.id);\n            }\n            window.addEventListener(\"online\", handleIsOnline);\n            return ()=>{\n                window.removeEventListener(\"online\", handleIsOnline);\n            };\n        }, [\n            room.id\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const pair = stableEnterRoom(roomId, frozenProps);\n            setRoomLeavePair(pair);\n            const { room: room2, leave } = pair;\n            if (frozenProps.autoConnect) {\n                room2.connect();\n            }\n            return ()=>{\n                leave();\n            };\n        }, [\n            roomId,\n            frozenProps,\n            stableEnterRoom\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomContext.Provider, {\n            value: room\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextBundle.Provider, {\n            value: bundle\n        }, props.children));\n    }\n    function connectionIdSelector(others) {\n        return others.map((user)=>user.connectionId);\n    }\n    function useRoom() {\n        const room = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RoomContext);\n        if (room === null) {\n            throw new Error(\"RoomProvider is missing from the React tree.\");\n        }\n        return room;\n    }\n    function useStatus() {\n        const room = useRoom();\n        const subscribe = room.events.status.subscribe;\n        const getSnapshot = room.getStatus;\n        const getServerSnapshot = room.getStatus;\n        return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    }\n    function useMyPresence() {\n        const room = useRoom();\n        const subscribe = room.events.myPresence.subscribe;\n        const getSnapshot = room.getPresence;\n        const presence = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n        const setPresence = room.updatePresence;\n        return [\n            presence,\n            setPresence\n        ];\n    }\n    function useUpdateMyPresence() {\n        return useRoom().updatePresence;\n    }\n    function useOthers(selector, isEqual) {\n        const room = useRoom();\n        const subscribe = room.events.others.subscribe;\n        const getSnapshot = room.getOthers;\n        const getServerSnapshot = alwaysEmptyList;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(subscribe, getSnapshot, getServerSnapshot, selector ?? identity, isEqual);\n    }\n    function useOthersConnectionIds() {\n        return useOthers(connectionIdSelector, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow);\n    }\n    function useOthersMapped(itemSelector, itemIsEqual) {\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((others)=>others.map((other)=>[\n                    other.connectionId,\n                    itemSelector(other)\n                ]), [\n            itemSelector\n        ]);\n        const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((a, b)=>{\n            const eq = itemIsEqual ?? Object.is;\n            return a.length === b.length && a.every((atuple, index)=>{\n                const btuple = b[index];\n                return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n            });\n        }, [\n            itemIsEqual\n        ]);\n        return useOthers(wrappedSelector, wrappedIsEqual);\n    }\n    const NOT_FOUND = Symbol();\n    function useOther(connectionId, selector, isEqual) {\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((others)=>{\n            const other2 = others.find((other3)=>other3.connectionId === connectionId);\n            return other2 !== void 0 ? selector(other2) : NOT_FOUND;\n        }, [\n            connectionId,\n            selector\n        ]);\n        const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((prev, curr)=>{\n            if (prev === NOT_FOUND || curr === NOT_FOUND) {\n                return prev === curr;\n            }\n            const eq = isEqual ?? Object.is;\n            return eq(prev, curr);\n        }, [\n            isEqual\n        ]);\n        const other = useOthers(wrappedSelector, wrappedIsEqual);\n        if (other === NOT_FOUND) {\n            throw new Error(`No such other user with connection id ${connectionId} exists`);\n        }\n        return other;\n    }\n    function useBroadcastEvent() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event, options2 = {\n            shouldQueueEventIfNotReady: false\n        })=>{\n            room.broadcastEvent(event, options2);\n        }, [\n            room\n        ]);\n    }\n    function useOthersListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.others.subscribe((event)=>savedCallback.current(event)), [\n            room,\n            savedCallback\n        ]);\n    }\n    function useLostConnectionListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.lostConnection.subscribe((event)=>savedCallback.current(event)), [\n            room,\n            savedCallback\n        ]);\n    }\n    function useErrorListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.error.subscribe((e)=>savedCallback.current(e)), [\n            room,\n            savedCallback\n        ]);\n    }\n    function useEventListener(callback) {\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const listener = (eventData)=>{\n                savedCallback.current(eventData);\n            };\n            return room.events.customEvent.subscribe(listener);\n        }, [\n            room,\n            savedCallback\n        ]);\n    }\n    function useSelf(maybeSelector, isEqual) {\n        const room = useRoom();\n        const subscribe = room.events.self.subscribe;\n        const getSnapshot = room.getSelf;\n        const selector = maybeSelector ?? identity;\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((me)=>me !== null ? selector(me) : null, [\n            selector\n        ]);\n        const getServerSnapshot = alwaysNull;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(subscribe, getSnapshot, getServerSnapshot, wrappedSelector, isEqual);\n    }\n    function useMutableStorageRoot() {\n        const room = useRoom();\n        const subscribe = room.events.storageDidLoad.subscribeOnce;\n        const getSnapshot = room.getStorageSnapshot;\n        const getServerSnapshot = alwaysNull;\n        return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    }\n    function useStorageRoot() {\n        return [\n            useMutableStorageRoot()\n        ];\n    }\n    function useHistory() {\n        return useRoom().history;\n    }\n    function useUndo() {\n        return useHistory().undo;\n    }\n    function useRedo() {\n        return useHistory().redo;\n    }\n    function useCanUndo() {\n        const room = useRoom();\n        const subscribe = room.events.history.subscribe;\n        const canUndo = room.history.canUndo;\n        return useSyncExternalStore(subscribe, canUndo, canUndo);\n    }\n    function useCanRedo() {\n        const room = useRoom();\n        const subscribe = room.events.history.subscribe;\n        const canRedo = room.history.canRedo;\n        return useSyncExternalStore(subscribe, canRedo, canRedo);\n    }\n    function useBatch() {\n        return useRoom().batch;\n    }\n    function useLegacyKey(key) {\n        const room = useRoom();\n        const rootOrNull = useMutableStorageRoot();\n        const rerender = useRerender();\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            if (rootOrNull === null) {\n                return;\n            }\n            const root = rootOrNull;\n            let unsubCurr;\n            let curr = root.get(key);\n            function subscribeToCurr() {\n                unsubCurr = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.isLiveNode)(curr) ? room.subscribe(curr, rerender) : void 0;\n            }\n            function onRootChange() {\n                const newValue = root.get(key);\n                if (newValue !== curr) {\n                    unsubCurr?.();\n                    curr = newValue;\n                    subscribeToCurr();\n                    rerender();\n                }\n            }\n            subscribeToCurr();\n            rerender();\n            const unsubscribeRoot = room.subscribe(root, onRootChange);\n            return ()=>{\n                unsubscribeRoot();\n                unsubCurr?.();\n            };\n        }, [\n            rootOrNull,\n            room,\n            key,\n            rerender\n        ]);\n        if (rootOrNull === null) {\n            return null;\n        } else {\n            return rootOrNull.get(key);\n        }\n    }\n    function useStorage(selector, isEqual) {\n        const room = useRoom();\n        const rootOrNull = useMutableStorageRoot();\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootOrNull2)=>rootOrNull2 !== null ? selector(rootOrNull2) : null, [\n            selector\n        ]);\n        const subscribe = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((onStoreChange)=>rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, {\n                isDeep: true\n            }) : noop, [\n            room,\n            rootOrNull\n        ]);\n        const getSnapshot = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n            if (rootOrNull === null) {\n                return null;\n            } else {\n                const root = rootOrNull;\n                const imm = root.toImmutable();\n                return imm;\n            }\n        }, [\n            rootOrNull\n        ]);\n        const getServerSnapshot = alwaysNull;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(subscribe, getSnapshot, getServerSnapshot, wrappedSelector, isEqual);\n    }\n    function ensureNotServerSide() {\n        if (true) {\n            throw new Error(\"You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr\");\n        }\n    }\n    function useSuspendUntilStorageLoaded() {\n        const room = useRoom();\n        if (room.getStorageSnapshot() !== null) {\n            return;\n        }\n        ensureNotServerSide();\n        throw new Promise((res)=>{\n            room.events.storageDidLoad.subscribeOnce(()=>res());\n        });\n    }\n    function useSuspendUntilPresenceLoaded() {\n        const room = useRoom();\n        if (room.getSelf() !== null) {\n            return;\n        }\n        ensureNotServerSide();\n        throw new Promise((res)=>{\n            room.events.self.subscribeOnce(()=>res());\n            room.events.status.subscribeOnce(()=>res());\n        });\n    }\n    function useMutation(callback, deps) {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n            return (...args)=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                room.batch(()=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    callback(makeMutationContext(room), ...args));\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            room,\n            ...deps\n        ]);\n    }\n    function useStorageSuspense(selector, isEqual) {\n        useSuspendUntilStorageLoaded();\n        return useStorage(selector, isEqual);\n    }\n    function useSelfSuspense(selector, isEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useSelf(selector, isEqual);\n    }\n    function useOthersSuspense(selector, isEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useOthers(selector, isEqual);\n    }\n    function useOthersConnectionIdsSuspense() {\n        useSuspendUntilPresenceLoaded();\n        return useOthersConnectionIds();\n    }\n    function useOthersMappedSuspense(itemSelector, itemIsEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useOthersMapped(itemSelector, itemIsEqual);\n    }\n    function useOtherSuspense(connectionId, selector, isEqual) {\n        useSuspendUntilPresenceLoaded();\n        return useOther(connectionId, selector, isEqual);\n    }\n    function useLegacyKeySuspense(key) {\n        useSuspendUntilStorageLoaded();\n        return useLegacyKey(key);\n    }\n    const store = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].cacheStore;\n    function onMutationFailure(innerError, optimisticUpdateId, createPublicError) {\n        store.set((state)=>({\n                ...state,\n                optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n            }));\n        if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError) {\n            const error = handleApiError(innerError);\n            commentsErrorEventSource.notify(createPublicError(error));\n            return;\n        }\n        if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.NotificationsApiError) {\n            handleApiError(innerError);\n            return;\n        }\n        throw innerError;\n    }\n    const subscribersByQuery = /* @__PURE__ */ new Map();\n    const requestsByQuery = /* @__PURE__ */ new Map();\n    const poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(refreshThreadsAndNotifications);\n    async function refreshThreadsAndNotifications() {\n        const requests = [];\n        client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].getRoomIds().map((roomId)=>{\n            const room = client.getRoom(roomId);\n            if (room === null) return;\n            requests.push(getThreadsUpdates(room.id));\n        });\n        await Promise.allSettled(requests);\n    }\n    function incrementQuerySubscribers(queryKey) {\n        const subscribers = subscribersByQuery.get(queryKey) ?? 0;\n        subscribersByQuery.set(queryKey, subscribers + 1);\n        poller.start(POLLING_INTERVAL);\n    }\n    function decrementQuerySubscribers(queryKey) {\n        const subscribers = subscribersByQuery.get(queryKey);\n        if (subscribers === void 0 || subscribers <= 0) {\n            _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(`Internal unexpected behavior. Cannot decrease subscriber count for query \"${queryKey}\"`);\n            return;\n        }\n        subscribersByQuery.set(queryKey, subscribers - 1);\n        let totalSubscribers = 0;\n        for (const subscribers2 of subscribersByQuery.values()){\n            totalSubscribers += subscribers2;\n        }\n        if (totalSubscribers <= 0) {\n            poller.stop();\n        }\n    }\n    async function getThreadsAndInboxNotifications(room, queryKey, options2, { retryCount } = {\n        retryCount: 0\n    }) {\n        const existingRequest = requestsByQuery.get(queryKey);\n        if (existingRequest !== void 0) return existingRequest;\n        const request = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.getThreads(options2);\n        requestsByQuery.set(queryKey, request);\n        store.setQueryState(queryKey, {\n            isLoading: true\n        });\n        try {\n            const result = await request;\n            store.updateThreadsAndNotifications(result.threads, result.inboxNotifications, result.deletedThreads, result.deletedInboxNotifications, queryKey);\n            const lastRequestedAt = lastRequestedAtByRoom.get(room.id);\n            if (lastRequestedAt === void 0 || lastRequestedAt > result.meta.requestedAt) {\n                lastRequestedAtByRoom.set(room.id, result.meta.requestedAt);\n            }\n            poller.start(POLLING_INTERVAL);\n        } catch (err) {\n            requestsByQuery.delete(queryKey);\n            retryError(()=>{\n                void getThreadsAndInboxNotifications(room, queryKey, options2, {\n                    retryCount: retryCount + 1\n                });\n            }, retryCount);\n            store.setQueryState(queryKey, {\n                isLoading: false,\n                error: err\n            });\n            return;\n        }\n    }\n    const DEFAULT_DEDUPING_INTERVAL = 2e3;\n    const lastRequestedAtByRoom = /* @__PURE__ */ new Map();\n    const requestStatusByRoom = /* @__PURE__ */ new Map();\n    async function getThreadsUpdates(roomId) {\n        const room = client.getRoom(roomId);\n        if (room === null) return;\n        const since = lastRequestedAtByRoom.get(room.id);\n        if (since === void 0) return;\n        const isFetchingThreadsUpdates = requestStatusByRoom.get(room.id) ?? false;\n        if (isFetchingThreadsUpdates === true) return;\n        try {\n            requestStatusByRoom.set(room.id, true);\n            const updates = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.getThreads({\n                since\n            });\n            setTimeout(()=>{\n                requestStatusByRoom.set(room.id, false);\n            }, DEFAULT_DEDUPING_INTERVAL);\n            store.updateThreadsAndNotifications(updates.threads, updates.inboxNotifications, updates.deletedThreads, updates.deletedInboxNotifications);\n            lastRequestedAtByRoom.set(room.id, updates.meta.requestedAt);\n        } catch (err) {\n            requestStatusByRoom.set(room.id, false);\n            return;\n        }\n    }\n    function useThreads(options2 = {\n        query: {\n            metadata: {}\n        }\n    }) {\n        const room = useRoom();\n        const queryKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>generateQueryKey(room.id, options2.query), [\n            room,\n            options2\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            void getThreadsAndInboxNotifications(room, queryKey, options2);\n            incrementQuerySubscribers(queryKey);\n            return ()=>decrementQuerySubscribers(queryKey);\n        }, [\n            room,\n            queryKey\n        ]);\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state)=>{\n            const query = state.queries[queryKey];\n            if (query === void 0 || query.isLoading) {\n                return {\n                    isLoading: true\n                };\n            }\n            return {\n                threads: selectedThreads(room.id, state, options2),\n                isLoading: false,\n                error: query.error\n            };\n        }, [\n            room,\n            queryKey\n        ]);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n    }\n    function useThreadsSuspense(options2 = {\n        query: {\n            metadata: {}\n        }\n    }) {\n        const room = useRoom();\n        const queryKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>generateQueryKey(room.id, options2?.query), [\n            room,\n            options2\n        ]);\n        const query = store.get().queries[queryKey];\n        if (query === void 0 || query.isLoading) {\n            throw getThreadsAndInboxNotifications(room, queryKey, options2);\n        }\n        if (query.error) {\n            throw query.error;\n        }\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state)=>{\n            return {\n                threads: selectedThreads(room.id, state, options2),\n                isLoading: false\n            };\n        }, [\n            room,\n            queryKey\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            incrementQuerySubscribers(queryKey);\n            return ()=>{\n                decrementQuerySubscribers(queryKey);\n            };\n        }, [\n            queryKey\n        ]);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n    }\n    function useCreateThread() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((options2)=>{\n            const body = options2.body;\n            const metadata = \"metadata\" in options2 ? options2.metadata : {};\n            const threadId = createThreadId();\n            const commentId = createCommentId();\n            const createdAt = /* @__PURE__ */ new Date();\n            const newComment = {\n                id: commentId,\n                threadId,\n                roomId: room.id,\n                createdAt,\n                type: \"comment\",\n                userId: getCurrentUserId(room),\n                body,\n                reactions: []\n            };\n            const newThread = {\n                id: threadId,\n                type: \"thread\",\n                createdAt,\n                updatedAt: createdAt,\n                roomId: room.id,\n                metadata,\n                comments: [\n                    newComment\n                ]\n            };\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"create-thread\",\n                thread: newThread,\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.createThread({\n                threadId,\n                commentId,\n                body,\n                metadata\n            }).then((thread)=>{\n                store.set((state)=>({\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: thread\n                        },\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (err2)=>new CreateThreadError(err2, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        body,\n                        metadata\n                    })));\n            return newThread;\n        }, [\n            room\n        ]);\n    }\n    function useEditThreadMetadata() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((options2)=>{\n            if (!(\"metadata\" in options2)) {\n                return;\n            }\n            const threadId = options2.threadId;\n            const metadata = options2.metadata;\n            const updatedAt = /* @__PURE__ */ new Date();\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"edit-thread-metadata\",\n                metadata,\n                id: optimisticUpdateId,\n                threadId,\n                updatedAt\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.editThreadMetadata({\n                metadata,\n                threadId\n            }).then((metadata2)=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    if (existingThread.deletedAt !== void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    if (existingThread.updatedAt && existingThread.updatedAt > updatedAt) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: {\n                                ...existingThread,\n                                metadata: {\n                                    ...existingThread.metadata,\n                                    ...metadata2\n                                }\n                            }\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new EditThreadMetadataError(error, {\n                        roomId: room.id,\n                        threadId,\n                        metadata\n                    })));\n        }, [\n            room\n        ]);\n    }\n    function useAddReaction() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(({ threadId, commentId, emoji })=>{\n            const createdAt = /* @__PURE__ */ new Date();\n            const userId = getCurrentUserId(room);\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"add-reaction\",\n                threadId,\n                commentId,\n                reaction: {\n                    emoji,\n                    userId,\n                    createdAt\n                },\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.addReaction({\n                threadId,\n                commentId,\n                emoji\n            }).then((addedReaction)=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.addReaction)(existingThread, commentId, addedReaction)\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new AddReactionError(error, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        emoji\n                    })));\n        }, [\n            room\n        ]);\n    }\n    function useRemoveReaction() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(({ threadId, commentId, emoji })=>{\n            const userId = getCurrentUserId(room);\n            const removedAt = /* @__PURE__ */ new Date();\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"remove-reaction\",\n                threadId,\n                commentId,\n                emoji,\n                userId,\n                removedAt,\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.removeReaction({\n                threadId,\n                commentId,\n                emoji\n            }).then(()=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.removeReaction)(existingThread, commentId, emoji, userId, removedAt)\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new RemoveReactionError(error, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        emoji\n                    })));\n        }, [\n            room\n        ]);\n    }\n    function useCreateComment() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(({ threadId, body })=>{\n            const commentId = createCommentId();\n            const createdAt = /* @__PURE__ */ new Date();\n            const comment = {\n                id: commentId,\n                threadId,\n                roomId: room.id,\n                type: \"comment\",\n                createdAt,\n                userId: getCurrentUserId(room),\n                body,\n                reactions: []\n            };\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"create-comment\",\n                comment,\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.createComment({\n                threadId,\n                commentId,\n                body\n            }).then((newComment)=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    const inboxNotification = Object.values(state.inboxNotifications).find((notification)=>notification.threadId === threadId);\n                    const updatedInboxNotifications = inboxNotification !== void 0 ? {\n                        ...state.inboxNotifications,\n                        [inboxNotification.id]: {\n                            ...inboxNotification,\n                            notifiedAt: newComment.createdAt,\n                            readAt: newComment.createdAt\n                        }\n                    } : state.inboxNotifications;\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.upsertComment)(existingThread, newComment)\n                        },\n                        inboxNotifications: updatedInboxNotifications,\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (err2)=>new CreateCommentError(err2, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        body\n                    })));\n            return comment;\n        }, [\n            room\n        ]);\n    }\n    function useEditComment() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(({ threadId, commentId, body })=>{\n            const editedAt = /* @__PURE__ */ new Date();\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            const thread = store.get().threads[threadId];\n            if (thread === void 0) {\n                _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(`Internal unexpected behavior. Cannot edit comment in thread \"${threadId}\" because the thread does not exist in the cache.`);\n                return;\n            }\n            const comment = thread.comments.find((comment2)=>comment2.id === commentId);\n            if (comment === void 0 || comment.deletedAt !== void 0) {\n                _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(`Internal unexpected behavior. Cannot edit comment \"${commentId}\" in thread \"${threadId}\" because the comment does not exist in the cache.`);\n                return;\n            }\n            store.pushOptimisticUpdate({\n                type: \"edit-comment\",\n                comment: {\n                    ...comment,\n                    editedAt,\n                    body\n                },\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.editComment({\n                threadId,\n                commentId,\n                body\n            }).then((editedComment)=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.upsertComment)(existingThread, editedComment)\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new EditCommentError(error, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        body\n                    })));\n        }, [\n            room\n        ]);\n    }\n    function useDeleteComment() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(({ threadId, commentId })=>{\n            const deletedAt = /* @__PURE__ */ new Date();\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"delete-comment\",\n                threadId,\n                commentId,\n                deletedAt,\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.deleteComment({\n                threadId,\n                commentId\n            }).then(()=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.deleteComment)(existingThread, commentId, deletedAt)\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new DeleteCommentError(error, {\n                        roomId: room.id,\n                        threadId,\n                        commentId\n                    })));\n        }, [\n            room\n        ]);\n    }\n    const resolveMentionSuggestions = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].resolveMentionSuggestions;\n    const mentionSuggestionsCache = /* @__PURE__ */ new Map();\n    function useMentionSuggestions(search) {\n        const room = useRoom();\n        const [mentionSuggestions, setMentionSuggestions] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n        const lastInvokedAt = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            if (search === void 0 || !resolveMentionSuggestions) {\n                return;\n            }\n            const resolveMentionSuggestionsArgs = {\n                text: search,\n                roomId: room.id\n            };\n            const mentionSuggestionsCacheKey = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(resolveMentionSuggestionsArgs);\n            let debounceTimeout;\n            let isCanceled = false;\n            const getMentionSuggestions = async ()=>{\n                try {\n                    lastInvokedAt.current = performance.now();\n                    const mentionSuggestions2 = await resolveMentionSuggestions(resolveMentionSuggestionsArgs);\n                    if (!isCanceled) {\n                        setMentionSuggestions(mentionSuggestions2);\n                        mentionSuggestionsCache.set(mentionSuggestionsCacheKey, mentionSuggestions2);\n                    }\n                } catch (error) {\n                    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.error(error?.message);\n                }\n            };\n            if (mentionSuggestionsCache.has(mentionSuggestionsCacheKey)) {\n                setMentionSuggestions(mentionSuggestionsCache.get(mentionSuggestionsCacheKey));\n            } else if (!lastInvokedAt.current || Math.abs(performance.now() - lastInvokedAt.current) > MENTION_SUGGESTIONS_DEBOUNCE) {\n                void getMentionSuggestions();\n            } else {\n                debounceTimeout = window.setTimeout(()=>{\n                    void getMentionSuggestions();\n                }, MENTION_SUGGESTIONS_DEBOUNCE);\n            }\n            return ()=>{\n                isCanceled = true;\n                window.clearTimeout(debounceTimeout);\n            };\n        }, [\n            room.id,\n            search\n        ]);\n        return mentionSuggestions;\n    }\n    function useThreadSubscription(threadId) {\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state)=>{\n            const inboxNotification = selectedInboxNotifications(state).find((inboxNotification2)=>inboxNotification2.threadId === threadId);\n            const thread = state.threads[threadId];\n            if (inboxNotification === void 0 || thread === void 0) {\n                return {\n                    status: \"not-subscribed\"\n                };\n            }\n            return {\n                status: \"subscribed\",\n                unreadSince: inboxNotification.readAt\n            };\n        }, [\n            threadId\n        ]);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n    }\n    function useMarkThreadAsRead() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((threadId)=>{\n            const inboxNotification = Object.values(store.get().inboxNotifications).find((inboxNotification2)=>inboxNotification2.threadId === threadId);\n            if (!inboxNotification) return;\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            const now = /* @__PURE__ */ new Date();\n            store.pushOptimisticUpdate({\n                type: \"mark-inbox-notification-as-read\",\n                id: optimisticUpdateId,\n                inboxNotificationId: inboxNotification.id,\n                readAt: now\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications.markInboxNotificationAsRead(inboxNotification.id).then(()=>{\n                store.set((state)=>({\n                        ...state,\n                        inboxNotifications: {\n                            ...state.inboxNotifications,\n                            [inboxNotification.id]: {\n                                ...inboxNotification,\n                                readAt: now\n                            }\n                        },\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            }, (err)=>{\n                onMutationFailure(err, optimisticUpdateId, (error)=>new MarkInboxNotificationAsReadError(error, {\n                        inboxNotificationId: inboxNotification.id\n                    }));\n                return;\n            });\n        }, [\n            room\n        ]);\n    }\n    function makeNotificationSettingsQueryKey(roomId) {\n        return `${roomId}:NOTIFICATION_SETTINGS`;\n    }\n    async function getInboxNotificationSettings(room, queryKey, { retryCount } = {\n        retryCount: 0\n    }) {\n        const existingRequest = requestsByQuery.get(queryKey);\n        if (existingRequest !== void 0) return existingRequest;\n        try {\n            const request = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications.getRoomNotificationSettings();\n            requestsByQuery.set(queryKey, request);\n            store.setQueryState(queryKey, {\n                isLoading: true\n            });\n            const settings = await request;\n            store.updateRoomInboxNotificationSettings(room.id, settings, queryKey);\n        } catch (err) {\n            requestsByQuery.delete(queryKey);\n            retryError(()=>{\n                void getInboxNotificationSettings(room, queryKey, {\n                    retryCount: retryCount + 1\n                });\n            }, retryCount);\n            store.setQueryState(queryKey, {\n                isLoading: false,\n                error: err\n            });\n            return;\n        }\n    }\n    function useRoomNotificationSettings() {\n        const room = useRoom();\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const queryKey = makeNotificationSettingsQueryKey(room.id);\n            void getInboxNotificationSettings(room, queryKey);\n        }, [\n            room\n        ]);\n        const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state)=>{\n            const query = state.queries[makeNotificationSettingsQueryKey(room.id)];\n            if (query === void 0 || query.isLoading) {\n                return {\n                    isLoading: true\n                };\n            }\n            if (query.error !== void 0) {\n                return {\n                    isLoading: false,\n                    error: query.error\n                };\n            }\n            return {\n                isLoading: false,\n                settings: selectNotificationSettings(room.id, state)\n            };\n        }, [\n            room\n        ]);\n        const settings = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n        return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n            return [\n                settings,\n                updateRoomNotificationSettings\n            ];\n        }, [\n            settings,\n            updateRoomNotificationSettings\n        ]);\n    }\n    function useRoomNotificationSettingsSuspense() {\n        const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n        const room = useRoom();\n        const queryKey = makeNotificationSettingsQueryKey(room.id);\n        const query = store.get().queries[queryKey];\n        if (query === void 0 || query.isLoading) {\n            throw getInboxNotificationSettings(room, queryKey);\n        }\n        if (query.error) {\n            throw query.error;\n        }\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state)=>{\n            return {\n                isLoading: false,\n                settings: selectNotificationSettings(room.id, state)\n            };\n        }, [\n            room\n        ]);\n        const settings = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n        return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n            return [\n                settings,\n                updateRoomNotificationSettings\n            ];\n        }, [\n            settings,\n            updateRoomNotificationSettings\n        ]);\n    }\n    function useUpdateRoomNotificationSettings() {\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((settings)=>{\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                id: optimisticUpdateId,\n                type: \"update-notification-settings\",\n                roomId: room.id,\n                settings\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications.updateRoomNotificationSettings(settings).then((settings2)=>{\n                store.set((state)=>({\n                        ...state,\n                        notificationSettings: {\n                            [room.id]: settings2\n                        },\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new UpdateNotificationSettingsError(error, {\n                        roomId: room.id\n                    })));\n        }, [\n            room\n        ]);\n    }\n    function useCurrentUserId() {\n        return useSelf((user)=>typeof user.id === \"string\" ? user.id : null);\n    }\n    const bundle = {\n        RoomContext,\n        RoomProvider: RoomProviderOuter,\n        useRoom,\n        useStatus,\n        useBatch,\n        useBroadcastEvent,\n        useOthersListener,\n        useLostConnectionListener,\n        useErrorListener,\n        useEventListener,\n        useHistory,\n        useUndo,\n        useRedo,\n        useCanRedo,\n        useCanUndo,\n        // These are just aliases. The passed-in key will define their return values.\n        useList: useLegacyKey,\n        useMap: useLegacyKey,\n        useObject: useLegacyKey,\n        useStorageRoot,\n        useStorage,\n        useSelf,\n        useMyPresence,\n        useUpdateMyPresence,\n        useOthers,\n        useOthersMapped,\n        useOthersConnectionIds,\n        useOther,\n        useMutation,\n        useThreads,\n        useCreateThread,\n        useEditThreadMetadata,\n        useCreateComment,\n        useEditComment,\n        useDeleteComment,\n        useAddReaction,\n        useRemoveReaction,\n        useMarkThreadAsRead,\n        useThreadSubscription,\n        useRoomNotificationSettings,\n        useUpdateRoomNotificationSettings,\n        ...shared,\n        suspense: {\n            RoomContext,\n            RoomProvider: RoomProviderOuter,\n            useRoom,\n            useStatus,\n            useBatch,\n            useBroadcastEvent,\n            useOthersListener,\n            useLostConnectionListener,\n            useErrorListener,\n            useEventListener,\n            useHistory,\n            useUndo,\n            useRedo,\n            useCanRedo,\n            useCanUndo,\n            // Legacy hooks\n            useList: useLegacyKeySuspense,\n            useMap: useLegacyKeySuspense,\n            useObject: useLegacyKeySuspense,\n            useStorageRoot,\n            useStorage: useStorageSuspense,\n            useSelf: useSelfSuspense,\n            useMyPresence,\n            useUpdateMyPresence,\n            useOthers: useOthersSuspense,\n            useOthersMapped: useOthersMappedSuspense,\n            useOthersConnectionIds: useOthersConnectionIdsSuspense,\n            useOther: useOtherSuspense,\n            useMutation,\n            useThreads: useThreadsSuspense,\n            useCreateThread,\n            useEditThreadMetadata,\n            useCreateComment,\n            useEditComment,\n            useDeleteComment,\n            useAddReaction,\n            useRemoveReaction,\n            useMarkThreadAsRead,\n            useThreadSubscription,\n            useRoomNotificationSettings: useRoomNotificationSettingsSuspense,\n            useUpdateRoomNotificationSettings,\n            ...shared.suspense\n        },\n        [_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal]: {\n            useCurrentUserId,\n            hasResolveMentionSuggestions: resolveMentionSuggestions !== void 0,\n            useMentionSuggestions\n        }\n    };\n    return Object.defineProperty(bundle, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal, {\n        enumerable: false\n    });\n}\nfunction getCurrentUserId(room) {\n    const self = room.getSelf();\n    if (self === null || self.id === void 0) {\n        return \"anonymous\";\n    } else {\n        return self.id;\n    }\n}\nfunction handleApiError(err) {\n    const message = `Request failed with status ${err.status}: ${err.message}`;\n    if (err.details?.error === \"FORBIDDEN\") {\n        const detailedMessage = [\n            message,\n            err.details.suggestion,\n            err.details.docs\n        ].filter(Boolean).join(\"\\n\");\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.error(detailedMessage);\n    }\n    return new Error(message);\n}\nfunction generateQueryKey(roomId, options) {\n    return `${roomId}-${(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(options ?? {})}`;\n}\n// src/shared.ts\nfunction useSharedContextBundle() {\n    const roomContextBundle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ContextBundle);\n    const liveblocksContextBundle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ContextBundle2);\n    if (roomContextBundle !== null) {\n        return roomContextBundle;\n    } else if (liveblocksContextBundle !== null) {\n        return liveblocksContextBundle;\n    } else {\n        throw new Error(\"LiveblocksProvider or RoomProvider are missing from the React tree.\");\n    }\n}\nfunction createSharedContext(client) {\n    const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].usersStore;\n    const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].roomsInfoStore;\n    function useUser(userId) {\n        const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>usersStore.getState(userId), [\n            userId\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void usersStore.get(userId);\n        }, [\n            userId\n        ]);\n        const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(usersStore.subscribe, getUserState, getUserState);\n        return state ? {\n            ...state,\n            user: state.data\n        } : {\n            isLoading: true\n        };\n    }\n    function useUserSuspense(userId) {\n        const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>usersStore.getState(userId), [\n            userId\n        ]);\n        const userState = getUserState();\n        if (!userState || userState.isLoading) {\n            throw usersStore.get(userId);\n        }\n        if (userState.error) {\n            throw userState.error;\n        }\n        const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(usersStore.subscribe, getUserState, getUserState);\n        return {\n            ...state,\n            user: state?.data\n        };\n    }\n    function useRoomInfo(roomId) {\n        const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>roomsInfoStore.getState(roomId), [\n            roomId\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void roomsInfoStore.get(roomId);\n        }, [\n            roomId\n        ]);\n        const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(roomsInfoStore.subscribe, getRoomInfoState, getRoomInfoState);\n        return state ? {\n            ...state,\n            info: state.data\n        } : {\n            isLoading: true\n        };\n    }\n    function useRoomInfoSuspense(roomId) {\n        const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>roomsInfoStore.getState(roomId), [\n            roomId\n        ]);\n        const roomInfoState = getRoomInfoState();\n        if (!roomInfoState || roomInfoState.isLoading) {\n            throw roomsInfoStore.get(roomId);\n        }\n        if (roomInfoState.error) {\n            throw roomInfoState.error;\n        }\n        const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(roomsInfoStore.subscribe, getRoomInfoState, getRoomInfoState);\n        return {\n            ...state,\n            info: state?.data\n        };\n    }\n    const bundle = {\n        useUser,\n        useRoomInfo,\n        suspense: {\n            useUser: useUserSuspense,\n            useRoomInfo: useRoomInfoSuspense\n        }\n    };\n    return bundle;\n}\n// src/liveblocks.tsx\nvar ContextBundle2 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction useLiveblocksContextBundle() {\n    const bundle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ContextBundle2);\n    if (bundle === null) {\n        throw new Error(\"LiveblocksProvider is missing from the React tree.\");\n    }\n    return bundle;\n}\nvar POLLING_INTERVAL2 = 60 * 1e3;\nvar INBOX_NOTIFICATIONS_QUERY = \"INBOX_NOTIFICATIONS\";\nfunction createLiveblocksContext(client) {\n    const shared = createSharedContext(client);\n    const store = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].cacheStore;\n    const notifications = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications;\n    function LiveblocksProvider(props) {\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextBundle2.Provider, {\n            value: bundle\n        }, props.children);\n    }\n    let fetchInboxNotificationsRequest = null;\n    let inboxNotificationsSubscribers = 0;\n    let lastRequestedAt;\n    const poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(refreshThreadsAndNotifications);\n    function refreshThreadsAndNotifications() {\n        return notifications.getInboxNotifications({\n            since: lastRequestedAt\n        }).then((result)=>{\n            lastRequestedAt = result.meta.requestedAt;\n            store.updateThreadsAndNotifications(result.threads, result.inboxNotifications, result.deletedThreads, result.deletedInboxNotifications, INBOX_NOTIFICATIONS_QUERY);\n        }, ()=>{});\n    }\n    function incrementInboxNotificationsSubscribers() {\n        inboxNotificationsSubscribers++;\n        poller.start(POLLING_INTERVAL2);\n    }\n    function decrementInboxNotificationsSubscribers() {\n        if (inboxNotificationsSubscribers <= 0) {\n            console.warn(`Internal unexpected behavior. Cannot decrease subscriber count for query \"${INBOX_NOTIFICATIONS_QUERY}\"`);\n            return;\n        }\n        inboxNotificationsSubscribers--;\n        if (inboxNotificationsSubscribers <= 0) {\n            poller.stop();\n        }\n    }\n    async function fetchInboxNotifications({ retryCount } = {\n        retryCount: 0\n    }) {\n        if (fetchInboxNotificationsRequest !== null) {\n            return fetchInboxNotificationsRequest;\n        }\n        store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {\n            isLoading: true\n        });\n        try {\n            fetchInboxNotificationsRequest = notifications.getInboxNotifications();\n            const result = await fetchInboxNotificationsRequest;\n            store.updateThreadsAndNotifications(result.threads, result.inboxNotifications, result.deletedThreads, result.deletedInboxNotifications, INBOX_NOTIFICATIONS_QUERY);\n            if (lastRequestedAt === void 0 || lastRequestedAt > result.meta.requestedAt) {\n                lastRequestedAt = result.meta.requestedAt;\n            }\n            poller.start(POLLING_INTERVAL2);\n        } catch (er) {\n            fetchInboxNotificationsRequest = null;\n            retryError(()=>{\n                void fetchInboxNotifications({\n                    retryCount: retryCount + 1\n                });\n            }, retryCount);\n            store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {\n                isLoading: false,\n                error: er\n            });\n        }\n        return;\n    }\n    function useInboxNotificationsSelectorCallback(state) {\n        const query = state.queries[INBOX_NOTIFICATIONS_QUERY];\n        if (query === void 0 || query.isLoading) {\n            return {\n                isLoading: true\n            };\n        }\n        if (query.error !== void 0) {\n            return {\n                error: query.error,\n                isLoading: false\n            };\n        }\n        return {\n            inboxNotifications: selectedInboxNotifications(state),\n            isLoading: false\n        };\n    }\n    function useInboxNotifications() {\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void fetchInboxNotifications();\n            incrementInboxNotificationsSubscribers();\n            return ()=>decrementInboxNotificationsSubscribers();\n        }, []);\n        const result = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, useInboxNotificationsSelectorCallback);\n        return result;\n    }\n    function useInboxNotificationsSuspenseSelector(state) {\n        return {\n            inboxNotifications: selectedInboxNotifications(state),\n            isLoading: false\n        };\n    }\n    function useInboxNotificationsSuspense() {\n        const query = store.get().queries[INBOX_NOTIFICATIONS_QUERY];\n        if (query === void 0 || query.isLoading) {\n            throw fetchInboxNotifications();\n        }\n        if (query.error !== void 0) {\n            throw query.error;\n        }\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            incrementInboxNotificationsSubscribers();\n            return ()=>{\n                decrementInboxNotificationsSubscribers();\n            };\n        }, []);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, useInboxNotificationsSuspenseSelector);\n    }\n    function selectUnreadInboxNotificationsCount(state) {\n        let count = 0;\n        for (const notification of selectedInboxNotifications(state)){\n            if (notification.readAt === null || notification.readAt < notification.notifiedAt) {\n                count++;\n            }\n        }\n        return count;\n    }\n    function useUnreadInboxNotificationsCountSelector(state) {\n        const query = state.queries[INBOX_NOTIFICATIONS_QUERY];\n        if (query === void 0 || query.isLoading) {\n            return {\n                isLoading: true\n            };\n        }\n        if (query.error !== void 0) {\n            return {\n                error: query.error,\n                isLoading: false\n            };\n        }\n        return {\n            isLoading: false,\n            count: selectUnreadInboxNotificationsCount(state)\n        };\n    }\n    function useUnreadInboxNotificationsCount() {\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void fetchInboxNotifications();\n            incrementInboxNotificationsSubscribers();\n            return ()=>decrementInboxNotificationsSubscribers();\n        }, []);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, useUnreadInboxNotificationsCountSelector);\n    }\n    function useUnreadInboxNotificationsCountSuspenseSelector(state) {\n        return {\n            isLoading: false,\n            count: selectUnreadInboxNotificationsCount(state)\n        };\n    }\n    function useUnreadInboxNotificationsCountSuspense() {\n        const query = store.get().queries[INBOX_NOTIFICATIONS_QUERY];\n        if (query === void 0 || query.isLoading) {\n            throw fetchInboxNotifications();\n        }\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            incrementInboxNotificationsSubscribers();\n            return ()=>{\n                decrementInboxNotificationsSubscribers();\n            };\n        }, []);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, useUnreadInboxNotificationsCountSuspenseSelector);\n    }\n    function useMarkInboxNotificationAsRead() {\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((inboxNotificationId)=>{\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            const readAt = /* @__PURE__ */ new Date();\n            store.pushOptimisticUpdate({\n                type: \"mark-inbox-notification-as-read\",\n                id: optimisticUpdateId,\n                inboxNotificationId,\n                readAt\n            });\n            notifications.markInboxNotificationAsRead(inboxNotificationId).then(()=>{\n                store.set((state)=>{\n                    const existingNotification = state.inboxNotifications[inboxNotificationId];\n                    if (existingNotification === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                        };\n                    }\n                    return {\n                        ...state,\n                        inboxNotifications: {\n                            ...state.inboxNotifications,\n                            [inboxNotificationId]: {\n                                ...existingNotification,\n                                readAt\n                            }\n                        },\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    };\n                });\n            }, ()=>{\n                store.set((state)=>({\n                        ...state,\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            });\n        }, []);\n    }\n    function useMarkAllInboxNotificationsAsRead() {\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            const readAt = /* @__PURE__ */ new Date();\n            store.pushOptimisticUpdate({\n                type: \"mark-inbox-notifications-as-read\",\n                id: optimisticUpdateId,\n                readAt\n            });\n            notifications.markAllInboxNotificationsAsRead().then(()=>{\n                store.set((state)=>({\n                        ...state,\n                        inboxNotifications: Object.fromEntries(Array.from(Object.entries(state.inboxNotifications)).map(([id, inboxNotification])=>[\n                                id,\n                                {\n                                    ...inboxNotification,\n                                    readAt\n                                }\n                            ])),\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            }, ()=>{\n                store.set((state)=>({\n                        ...state,\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            });\n        }, []);\n    }\n    function useThreadFromCache(threadId) {\n        const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((state)=>{\n            const thread = state.threads[threadId];\n            if (thread === void 0) {\n                throw new Error(`Internal error: thread with id \"${threadId}\" not found in cache`);\n            }\n            return thread;\n        }, [\n            threadId\n        ]);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n    }\n    const currentUserIdStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].currentUserIdStore;\n    function useCurrentUserId() {\n        return (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(currentUserIdStore.subscribe, currentUserIdStore.get, currentUserIdStore.get);\n    }\n    const bundle = {\n        LiveblocksProvider,\n        useInboxNotifications,\n        useUnreadInboxNotificationsCount,\n        useMarkInboxNotificationAsRead,\n        useMarkAllInboxNotificationsAsRead,\n        ...shared,\n        suspense: {\n            LiveblocksProvider,\n            useInboxNotifications: useInboxNotificationsSuspense,\n            useUnreadInboxNotificationsCount: useUnreadInboxNotificationsCountSuspense,\n            useMarkInboxNotificationAsRead,\n            useMarkAllInboxNotificationsAsRead,\n            ...shared.suspense\n        },\n        [_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal]: {\n            useThreadFromCache,\n            useCurrentUserId\n        }\n    };\n    return Object.defineProperty(bundle, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal, {\n        enumerable: false\n    });\n}\n// src/index.ts\n\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O2lNQUVBLGVBQWU7QUFDZ0M7QUFFL0MsaUJBQWlCO0FBQ2pCLElBQUlDLFdBQVc7QUFDZixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLGFBQWE7QUFFakIsNkJBQTZCO0FBQ0U7QUFDL0IsU0FBU0UsbUJBQW1CQyxLQUFLO0lBQy9CLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHSiwyQ0FBYyxDQUFDO0lBQzdDQSw0Q0FBZSxDQUFDO1FBQ2RJLFdBQVc7SUFDYixHQUFHLEVBQUU7SUFDTCxPQUFPLGFBQWEsaUJBQUdKLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFO1FBQUVTLFVBQVVQLE1BQU1PLFFBQVE7SUFBQyxHQUFHTixVQUFVRCxNQUFNUSxRQUFRLEtBQUtSLE1BQU1PLFFBQVE7QUFDdEk7QUFFQSxxQkFBcUI7QUFDaUU7QUFDM0M7QUFNNUI7QUFDdUY7QUFDZ0M7QUFFdEksbURBQW1EO0FBQ087QUFDMUQsU0FBU3FCLDJCQUEyQkMsS0FBSztJQUN2QyxNQUFNQyxTQUFTSCx3RUFBc0JBLENBQUNFO0lBQ3RDLE9BQU9FLE9BQU9DLE1BQU0sQ0FBQ0YsT0FBT0csa0JBQWtCLEVBQUVDLElBQUksQ0FDbEQsdURBQXVEO0lBQ3ZELENBQUNDLEdBQUdDLElBQU1BLEVBQUVDLFVBQVUsQ0FBQ0MsT0FBTyxLQUFLSCxFQUFFRSxVQUFVLENBQUNDLE9BQU87QUFFM0Q7QUFFQSx5QkFBeUI7QUFDekIsSUFBSUMsd0JBQXdCO0FBQzVCLElBQUlDLHVCQUF1QjtBQUMzQixTQUFTQyxXQUFXQyxNQUFNLEVBQUVDLFVBQVU7SUFDcEMsSUFBSUEsY0FBY0osdUJBQ2hCO0lBQ0YsTUFBTUssVUFBVUMsS0FBS0MsR0FBRyxDQUFDLEdBQUdILGNBQWNIO0lBQzFDTyxXQUFXO1FBQ1QsS0FBS0w7SUFDUCxHQUFHRTtBQUNMO0FBRUEsZ0JB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Q3JCLE1BQU0sSUFBSTdCLE1BQ1IsQ0FBQyxnQ0FBZ0MsRUFBRXFILFNBQVMsb0JBQW9CLENBQUM7WUFFckU7WUFDQSxPQUFPeEY7UUFDVCxHQUNBO1lBQUN3RjtTQUFTO1FBRVosT0FBT2xLLCtHQUFpQ0EsQ0FDdENtSyxNQUFNYSxTQUFTLEVBQ2ZiLE1BQU0zQixHQUFHLEVBQ1QyQixNQUFNM0IsR0FBRyxFQUNUbUU7SUFFSjtJQUNBLE1BQU1nUixxQkFBcUJoVyxNQUFNLENBQUMzSSx1REFBVUEsQ0FBQyxDQUFDMmUsa0JBQWtCO0lBQ2hFLFNBQVM5RDtRQUNQLE9BQU8vWiwyRkFBcUJBLENBQzFCNmQsbUJBQW1CM1MsU0FBUyxFQUM1QjJTLG1CQUFtQm5WLEdBQUcsRUFDdEJtVixtQkFBbUJuVixHQUFHO0lBRTFCO0lBQ0EsTUFBTWYsU0FBUztRQUNidVU7UUFDQVM7UUFDQU07UUFDQUc7UUFDQUU7UUFDQSxHQUFHcFYsTUFBTTtRQUNUa1MsVUFBVTtZQUNSOEI7WUFDQVMsdUJBQXVCRTtZQUN2Qkksa0NBQWtDRTtZQUNsQ0M7WUFDQUU7WUFDQSxHQUFHcFYsT0FBT2tTLFFBQVE7UUFDcEI7UUFDQSxDQUFDbGIsdURBQVVBLENBQUMsRUFBRTtZQUNaMGU7WUFDQTdEO1FBQ0Y7SUFDRjtJQUNBLE9BQU94WixPQUFPK1osY0FBYyxDQUFDM1MsUUFBUXpJLHVEQUFVQSxFQUFFO1FBQy9DcWIsWUFBWTtJQUNkO0FBQ0Y7QUFFQSxlQUFlO0FBQzBDO0FBQ3pEcmMsNkRBQVdBLENBQUNDLFVBQVVDLGFBQWFDO0FBU2pDLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmlncHJvLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0L2Rpc3QvaW5kZXgubWpzP2NkMzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgZGV0ZWN0RHVwZXMgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuXG4vLyBzcmMvdmVyc2lvbi50c1xudmFyIFBLR19OQU1FID0gXCJAbGl2ZWJsb2Nrcy9yZWFjdFwiO1xudmFyIFBLR19WRVJTSU9OID0gXCIxLjEwLjJcIjtcbnZhciBQS0dfRk9STUFUID0gXCJlc21cIjtcblxuLy8gc3JjL0NsaWVudFNpZGVTdXNwZW5zZS50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gQ2xpZW50U2lkZVN1c3BlbnNlKHByb3BzKSB7XG4gIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRNb3VudGVkKHRydWUpO1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5TdXNwZW5zZSwgeyBmYWxsYmFjazogcHJvcHMuZmFsbGJhY2sgfSwgbW91bnRlZCA/IHByb3BzLmNoaWxkcmVuKCkgOiBwcm9wcy5mYWxsYmFjayk7XG59XG5cbi8vIHNyYy9saXZlYmxvY2tzLnRzeFxuaW1wb3J0IHsga0ludGVybmFsIGFzIGtJbnRlcm5hbDMsIG1ha2VQb2xsZXIgYXMgbWFrZVBvbGxlcjIgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuaW1wb3J0IHsgbmFub2lkIGFzIG5hbm9pZDMgfSBmcm9tIFwibmFub2lkXCI7XG5pbXBvcnQgUmVhY3QzLCB7XG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDIsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMyxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MyxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDVcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgYXMgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvci5qc1wiO1xuXG4vLyBzcmMvY29tbWVudHMvbGliL3NlbGVjdGVkLWluYm94LW5vdGlmaWNhdGlvbnMudHNcbmltcG9ydCB7IGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuZnVuY3Rpb24gc2VsZWN0ZWRJbmJveE5vdGlmaWNhdGlvbnMoc3RhdGUpIHtcbiAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHRpbWlzdGljVXBkYXRlcyhzdGF0ZSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMpLnNvcnQoXG4gICAgLy8gU29ydCBzbyB0aGF0IHRoZSBtb3N0IHJlY2VudCBub3RpZmljYXRpb25zIGFyZSBmaXJzdFxuICAgIChhLCBiKSA9PiBiLm5vdGlmaWVkQXQuZ2V0VGltZSgpIC0gYS5ub3RpZmllZEF0LmdldFRpbWUoKVxuICApO1xufVxuXG4vLyBzcmMvbGliL3JldHJ5LWVycm9yLnRzXG52YXIgTUFYX0VSUk9SX1JFVFJZX0NPVU5UID0gNTtcbnZhciBFUlJPUl9SRVRSWV9JTlRFUlZBTCA9IDVlMztcbmZ1bmN0aW9uIHJldHJ5RXJyb3IoYWN0aW9uLCByZXRyeUNvdW50KSB7XG4gIGlmIChyZXRyeUNvdW50ID49IE1BWF9FUlJPUl9SRVRSWV9DT1VOVClcbiAgICByZXR1cm47XG4gIGNvbnN0IHRpbWVvdXQgPSBNYXRoLnBvdygyLCByZXRyeUNvdW50KSAqIEVSUk9SX1JFVFJZX0lOVEVSVkFMO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB2b2lkIGFjdGlvbigpO1xuICB9LCB0aW1lb3V0KTtcbn1cblxuLy8gc3JjL3NoYXJlZC50c1xuaW1wb3J0IHsga0ludGVybmFsIGFzIGtJbnRlcm5hbDIgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2syLCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgYXMgdXNlU3luY0V4dGVybmFsU3RvcmUyIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanNcIjtcblxuLy8gc3JjL3Jvb20udHN4XG5pbXBvcnQgeyBzaGFsbG93IH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NsaWVudFwiO1xuaW1wb3J0IHtcbiAgYWRkUmVhY3Rpb24sXG4gIENvbW1lbnRzQXBpRXJyb3IsXG4gIGNvbnNvbGUgYXMgY29uc29sZTIsXG4gIGRlbGV0ZUNvbW1lbnQsXG4gIGRlcHJlY2F0ZUlmLFxuICBlcnJvcklmLFxuICBpc0xpdmVOb2RlLFxuICBrSW50ZXJuYWwsXG4gIG1ha2VFdmVudFNvdXJjZSxcbiAgbWFrZVBvbGxlcixcbiAgTm90aWZpY2F0aW9uc0FwaUVycm9yLFxuICByZW1vdmVSZWFjdGlvbixcbiAgU2VydmVyTXNnQ29kZSxcbiAgc3RyaW5naWZ5LFxuICB1cHNlcnRDb21tZW50XG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgeyBuYW5vaWQgYXMgbmFub2lkMiB9IGZyb20gXCJuYW5vaWRcIjtcbmltcG9ydCAqIGFzIFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvci5qc1wiO1xuXG4vLyBzcmMvY29tbWVudHMvZXJyb3JzLnRzXG52YXIgQ3JlYXRlVGhyZWFkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkNyZWF0ZSB0aHJlYWQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkNyZWF0ZVRocmVhZEVycm9yXCI7XG4gIH1cbn07XG52YXIgRWRpdFRocmVhZE1ldGFkYXRhRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkVkaXQgdGhyZWFkIG1ldGFkYXRhIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJFZGl0VGhyZWFkTWV0YWRhdGFFcnJvclwiO1xuICB9XG59O1xudmFyIENyZWF0ZUNvbW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiQ3JlYXRlIGNvbW1lbnQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkNyZWF0ZUNvbW1lbnRFcnJvclwiO1xuICB9XG59O1xudmFyIEVkaXRDb21tZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkVkaXQgY29tbWVudCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiRWRpdENvbW1lbnRFcnJvclwiO1xuICB9XG59O1xudmFyIERlbGV0ZUNvbW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiRGVsZXRlIGNvbW1lbnQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkRlbGV0ZUNvbW1lbnRFcnJvclwiO1xuICB9XG59O1xudmFyIEFkZFJlYWN0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIkFkZCByZWFjdGlvbiBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiQWRkUmVhY3Rpb25FcnJvclwiO1xuICB9XG59O1xudmFyIFJlbW92ZVJlYWN0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIlJlbW92ZSByZWFjdGlvbiBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiUmVtb3ZlUmVhY3Rpb25FcnJvclwiO1xuICB9XG59O1xudmFyIE1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJNYXJrIGluYm94IG5vdGlmaWNhdGlvbiBhcyByZWFkIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRFcnJvclwiO1xuICB9XG59O1xudmFyIFVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIlVwZGF0ZSBub3RpZmljYXRpb24gc2V0dGluZ3MgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIlVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzRXJyb3JcIjtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1lbnRzL2xpYi9jcmVhdGVJZHMudHNcbmltcG9ydCB7IG5hbm9pZCB9IGZyb20gXCJuYW5vaWRcIjtcbnZhciBUSFJFQURfSURfUFJFRklYID0gXCJ0aFwiO1xudmFyIENPTU1FTlRfSURfUFJFRklYID0gXCJjbVwiO1xuZnVuY3Rpb24gY3JlYXRlT3B0aW1pc3RpY0lkKHByZWZpeCkge1xuICByZXR1cm4gYCR7cHJlZml4fV8ke25hbm9pZCgpfWA7XG59XG5mdW5jdGlvbiBjcmVhdGVUaHJlYWRJZCgpIHtcbiAgcmV0dXJuIGNyZWF0ZU9wdGltaXN0aWNJZChUSFJFQURfSURfUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRJZCgpIHtcbiAgcmV0dXJuIGNyZWF0ZU9wdGltaXN0aWNJZChDT01NRU5UX0lEX1BSRUZJWCk7XG59XG5cbi8vIHNyYy9jb21tZW50cy9saWIvc2VsZWN0LW5vdGlmaWNhdGlvbi1zZXR0aW5ncy50c1xuaW1wb3J0IHtcbiAgYXBwbHlPcHRpbWlzdGljVXBkYXRlcyBhcyBhcHBseU9wdGltaXN0aWNVcGRhdGVzMixcbiAgbm5cbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmZ1bmN0aW9uIHNlbGVjdE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb21JZCwgc3RhdGUpIHtcbiAgY29uc3QgeyBub3RpZmljYXRpb25TZXR0aW5ncyB9ID0gYXBwbHlPcHRpbWlzdGljVXBkYXRlczIoc3RhdGUpO1xuICByZXR1cm4gbm4obm90aWZpY2F0aW9uU2V0dGluZ3Nbcm9vbUlkXSk7XG59XG5cbi8vIHNyYy9jb21tZW50cy9saWIvc2VsZWN0ZWQtdGhyZWFkcy50c1xuaW1wb3J0IHtcbiAgYXBwbHlPcHRpbWlzdGljVXBkYXRlcyBhcyBhcHBseU9wdGltaXN0aWNVcGRhdGVzM1xufSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuZnVuY3Rpb24gc2VsZWN0ZWRUaHJlYWRzKHJvb21JZCwgc3RhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHRpbWlzdGljVXBkYXRlczMoc3RhdGUpO1xuICBjb25zdCB0aHJlYWRzID0gT2JqZWN0LnZhbHVlcyhyZXN1bHQudGhyZWFkcykuZmlsdGVyKCh0aHJlYWQpID0+IHtcbiAgICBpZiAodGhyZWFkLnJvb21JZCAhPT0gcm9vbUlkKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnkgPSBvcHRpb25zLnF1ZXJ5O1xuICAgIGlmICghcXVlcnkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeS5tZXRhZGF0YSkge1xuICAgICAgaWYgKHRocmVhZC5tZXRhZGF0YVtrZXldICE9PSBxdWVyeS5tZXRhZGF0YVtrZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICByZXR1cm4gdGhyZWFkcy5zb3J0KChhLCBiKSA9PiBhLmNyZWF0ZWRBdC5nZXRUaW1lKCkgLSBiLmNyZWF0ZWRBdC5nZXRUaW1lKCkpO1xufVxuXG4vLyBzcmMvbGliL3VzZS1pbml0aWFsLnRzXG5pbXBvcnQgeyB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUluaXRpYWwodmFsdWUpIHtcbiAgcmV0dXJuIHVzZVN0YXRlMih2YWx1ZSlbMF07XG59XG5cbi8vIHNyYy9saWIvdXNlLWxhdGVzdC50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlTGF0ZXN0KHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZih2YWx1ZSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0sIFt2YWx1ZV0pO1xuICByZXR1cm4gcmVmO1xufVxuXG4vLyBzcmMvbGliL3VzZS1yZXJlbmRlci50c1xuaW1wb3J0IHsgdXNlUmVkdWNlciB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlUmVyZW5kZXIoKSB7XG4gIGNvbnN0IFssIHVwZGF0ZV0gPSB1c2VSZWR1Y2VyKFxuICAgIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gd29ya3MgYnkgaW5jcmVtZW50aW5nIGEgaGlkZGVuIGNvdW50ZXIgdmFsdWUgdGhhdCBpc1xuICAgIC8vIG5ldmVyIGNvbnN1bWVkLiBTaW1wbHkgaW5jcmVtZW50aW5nIHRoZSBjb3VudGVyIGNoYW5nZXMgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gc3RhdGUgYW5kLCB0aHVzLCB0cmlnZ2VyIGEgcmUtcmVuZGVyLlxuICAgICh4KSA9PiB4ICsgMSxcbiAgICAwXG4gICk7XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbi8vIHNyYy9yb29tLnRzeFxudmFyIG5vb3AgPSAoKSA9PiB7XG59O1xudmFyIGlkZW50aXR5ID0gKHgpID0+IHg7XG52YXIgbWlzc2luZ191bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IChyZWFjdFZlcnNpb24sIHJvb21JZCkgPT4gYFdlIG5vdGljZWQgeW91XFx1MjAxOXJlIHVzaW5nIFJlYWN0ICR7cmVhY3RWZXJzaW9ufS4gUGxlYXNlIHBhc3MgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgYXQgdGhlIFJvb21Qcm92aWRlciBsZXZlbCB1bnRpbCB5b3VcXHUyMDE5cmUgcmVhZHkgdG8gdXBncmFkZSB0byBSZWFjdCAxODpcblxuICAgIGltcG9ydCB7IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIH0gZnJvbSBcInJlYWN0LWRvbVwiOyAgLy8gb3IgXCJyZWFjdC1uYXRpdmVcIlxuXG4gICAgPFJvb21Qcm92aWRlciBpZD0ke0pTT04uc3RyaW5naWZ5KFxuICByb29tSWRcbil9IC4uLiB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcz17dW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXN9PlxuICAgICAgLi4uXG4gICAgPC9Sb29tUHJvdmlkZXI+XG5cbldoeT8gUGxlYXNlIHNlZSBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9wbGF0Zm9ybS90cm91Ymxlc2hvb3Rpbmcjc3RhbGUtcHJvcHMtem9tYmllLWNoaWxkIGZvciBtb3JlIGluZm9ybWF0aW9uYDtcbnZhciBzdXBlcmZsdW91c191bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IFwiWW91IGRvblxcdTIwMTl0IG5lZWQgdG8gcGFzcyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyB0byBSb29tUHJvdmlkZXIgYW55bW9yZSwgc2luY2UgeW91XFx1MjAxOXJlIG9uIFJlYWN0IDE4KyBhbHJlYWR5LlwiO1xuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUocywgZ3MsIGdzcykge1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IocywgZ3MsIGdzcywgaWRlbnRpdHkpO1xufVxudmFyIFNUQUJMRV9FTVBUWV9MSVNUID0gT2JqZWN0LmZyZWV6ZShbXSk7XG52YXIgUE9MTElOR19JTlRFUlZBTCA9IDUgKiA2MCAqIDFlMztcbnZhciBNRU5USU9OX1NVR0dFU1RJT05TX0RFQk9VTkNFID0gNTAwO1xuZnVuY3Rpb24gYWx3YXlzRW1wdHlMaXN0KCkge1xuICByZXR1cm4gU1RBQkxFX0VNUFRZX0xJU1Q7XG59XG5mdW5jdGlvbiBhbHdheXNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG1ha2VNdXRhdGlvbkNvbnRleHQocm9vbSkge1xuICBjb25zdCBlcnJtc2cgPSBcIlRoaXMgbXV0YXRpb24gY2Fubm90IGJlIHVzZWQgdW50aWwgY29ubmVjdGVkIHRvIHRoZSBMaXZlYmxvY2tzIHJvb21cIjtcbiAgcmV0dXJuIHtcbiAgICBnZXQgc3RvcmFnZSgpIHtcbiAgICAgIGNvbnN0IG11dGFibGVSb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgICAgIGlmIChtdXRhYmxlUm9vdCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJybXNnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtdXRhYmxlUm9vdDtcbiAgICB9LFxuICAgIGdldCBzZWxmKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHJvb20uZ2V0U2VsZigpO1xuICAgICAgaWYgKHNlbGYgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuICAgIGdldCBvdGhlcnMoKSB7XG4gICAgICBjb25zdCBvdGhlcnMgPSByb29tLmdldE90aGVycygpO1xuICAgICAgaWYgKHJvb20uZ2V0U2VsZigpID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG90aGVycztcbiAgICB9LFxuICAgIHNldE15UHJlc2VuY2U6IHJvb20udXBkYXRlUHJlc2VuY2VcbiAgfTtcbn1cbnZhciBDb250ZXh0QnVuZGxlID0gUmVhY3QyLmNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiB1c2VSb29tQ29udGV4dEJ1bmRsZSgpIHtcbiAgY29uc3QgYnVuZGxlID0gUmVhY3QyLnVzZUNvbnRleHQoQ29udGV4dEJ1bmRsZSk7XG4gIGlmIChidW5kbGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tUHJvdmlkZXIgaXMgbWlzc2luZyBmcm9tIHRoZSBSZWFjdCB0cmVlLlwiKTtcbiAgfVxuICByZXR1cm4gYnVuZGxlO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbUNvbnRleHQoY2xpZW50LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zPy5yZXNvbHZlVXNlcnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSAncmVzb2x2ZVVzZXJzJyBvcHRpb24gaGFzIG1vdmVkIHRvICdjcmVhdGVDbGllbnQnIGZyb20gJ0BsaXZlYmxvY2tzL2NsaWVudCcuIFBsZWFzZSByZWZlciB0byBvdXIgVXBncmFkZSBHdWlkZSB0byBsZWFybiBtb3JlLCBzZWUgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvcGxhdGZvcm0vdXBncmFkaW5nLzEuMTAuXCJcbiAgICApO1xuICB9XG4gIGlmIChvcHRpb25zPy5yZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgJ3Jlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMnIG9wdGlvbiBoYXMgbW92ZWQgdG8gJ2NyZWF0ZUNsaWVudCcgZnJvbSAnQGxpdmVibG9ja3MvY2xpZW50Jy4gUGxlYXNlIHJlZmVyIHRvIG91ciBVcGdyYWRlIEd1aWRlIHRvIGxlYXJuIG1vcmUsIHNlZSBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9wbGF0Zm9ybS91cGdyYWRpbmcvMS4xMC5cIlxuICAgICk7XG4gIH1cbiAgY29uc3QgUm9vbUNvbnRleHQgPSBSZWFjdDIuY3JlYXRlQ29udGV4dChudWxsKTtcbiAgY29uc3QgY29tbWVudHNFcnJvckV2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGNvbnN0IHNoYXJlZCA9IGNyZWF0ZVNoYXJlZENvbnRleHQoY2xpZW50KTtcbiAgZnVuY3Rpb24gUm9vbVByb3ZpZGVyT3V0ZXIocHJvcHMpIHtcbiAgICBjb25zdCBbY2FjaGVdID0gUmVhY3QyLnVzZVN0YXRlKFxuICAgICAgKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICAgICk7XG4gICAgY29uc3Qgc3RhYmxlRW50ZXJSb29tID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHJvb21JZCwgb3B0aW9uczIpID0+IHtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KHJvb21JZCk7XG4gICAgICAgIGlmIChjYWNoZWQpXG4gICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgY29uc3QgcnYgPSBjbGllbnQuZW50ZXJSb29tKFxuICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICBvcHRpb25zMlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBvcmlnTGVhdmUgPSBydi5sZWF2ZTtcbiAgICAgICAgcnYubGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgb3JpZ0xlYXZlKCk7XG4gICAgICAgICAgY2FjaGUuZGVsZXRlKHJvb21JZCk7XG4gICAgICAgIH07XG4gICAgICAgIGNhY2hlLnNldChyb29tSWQsIHJ2KTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSxcbiAgICAgIFtjYWNoZV1cbiAgICApO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUm9vbVByb3ZpZGVySW5uZXIsIHsgLi4ucHJvcHMsIHN0YWJsZUVudGVyUm9vbSB9KTtcbiAgfVxuICBmdW5jdGlvbiBSb29tUHJvdmlkZXJJbm5lcihwcm9wcykge1xuICAgIGNvbnN0IHsgaWQ6IHJvb21JZCwgc3RhYmxlRW50ZXJSb29tIH0gPSBwcm9wcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIXJvb21JZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJSb29tUHJvdmlkZXIgaWQgcHJvcGVydHkgaXMgcmVxdWlyZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvbGl2ZWJsb2Nrcy1yZWFjdC9Sb29tUHJvdmlkZXItaWQtcHJvcGVydHktaXMtcmVxdWlyZWRcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByb29tSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbVByb3ZpZGVyIGlkIHByb3BlcnR5IHNob3VsZCBiZSBhIHN0cmluZy5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtYWpvclJlYWN0VmVyc2lvbiA9IHBhcnNlSW50KFJlYWN0Mi52ZXJzaW9uKSB8fCAxO1xuICAgICAgY29uc3Qgb2xkUmVhY3RWZXJzaW9uID0gbWFqb3JSZWFjdFZlcnNpb24gPCAxODtcbiAgICAgIGVycm9ySWYoXG4gICAgICAgIG9sZFJlYWN0VmVyc2lvbiAmJiBwcm9wcy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9PT0gdm9pZCAwLFxuICAgICAgICBtaXNzaW5nX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKG1ham9yUmVhY3RWZXJzaW9uLCByb29tSWQpXG4gICAgICApO1xuICAgICAgZGVwcmVjYXRlSWYoXG4gICAgICAgICFvbGRSZWFjdFZlcnNpb24gJiYgcHJvcHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgIT09IHZvaWQgMCxcbiAgICAgICAgc3VwZXJmbHVvdXNfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGZyb3plblByb3BzID0gdXNlSW5pdGlhbCh7XG4gICAgICBpbml0aWFsUHJlc2VuY2U6IHByb3BzLmluaXRpYWxQcmVzZW5jZSxcbiAgICAgIGluaXRpYWxTdG9yYWdlOiBwcm9wcy5pbml0aWFsU3RvcmFnZSxcbiAgICAgIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBwcm9wcy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxcbiAgICAgIGF1dG9Db25uZWN0OiBwcm9wcy5hdXRvQ29ubmVjdCA/PyBwcm9wcy5zaG91bGRJbml0aWFsbHlDb25uZWN0ID8/IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcbiAgICB9KTtcbiAgICBjb25zdCBbeyByb29tIH0sIHNldFJvb21MZWF2ZVBhaXJdID0gUmVhY3QyLnVzZVN0YXRlKFxuICAgICAgKCkgPT4gc3RhYmxlRW50ZXJSb29tKHJvb21JZCwge1xuICAgICAgICAuLi5mcm96ZW5Qcm9wcyxcbiAgICAgICAgYXV0b0Nvbm5lY3Q6IGZhbHNlXG4gICAgICAgIC8vIERlbGliZXJhdGVseSB1c2luZyBmYWxzZSBoZXJlIG9uIHRoZSBmaXJzdCByZW5kZXIsIHNlZSBiZWxvd1xuICAgICAgfSlcbiAgICApO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQ29tbWVudEV2ZW50KG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IHJvb21ba0ludGVybmFsXS5jb21tZW50cy5nZXRUaHJlYWQoe1xuICAgICAgICAgIHRocmVhZElkOiBtZXNzYWdlLnRocmVhZElkXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgICBzdG9yZS5kZWxldGVUaHJlYWQobWVzc2FnZS50aHJlYWRJZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdGhyZWFkLCBpbmJveE5vdGlmaWNhdGlvbiB9ID0gaW5mbztcbiAgICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSBzdG9yZS5nZXQoKS50aHJlYWRzW21lc3NhZ2UudGhyZWFkSWRdO1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX0VESVRFRDpcbiAgICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuVEhSRUFEX01FVEFEQVRBX1VQREFURUQ6XG4gICAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfUkVBQ1RJT05fQURERUQ6XG4gICAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRDpcbiAgICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9ERUxFVEVEOlxuICAgICAgICAgICAgaWYgKCFleGlzdGluZ1RocmVhZClcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdG9yZS51cGRhdGVUaHJlYWRBbmROb3RpZmljYXRpb24odGhyZWFkLCBpbmJveE5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9DUkVBVEVEOlxuICAgICAgICAgICAgc3RvcmUudXBkYXRlVGhyZWFkQW5kTm90aWZpY2F0aW9uKHRocmVhZCwgaW5ib3hOb3RpZmljYXRpb24pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcm9vbS5ldmVudHMuY29tbWVudHMuc3Vic2NyaWJlKFxuICAgICAgICAobWVzc2FnZSkgPT4gdm9pZCBoYW5kbGVDb21tZW50RXZlbnQobWVzc2FnZSlcbiAgICAgICk7XG4gICAgfSwgW3Jvb21dKTtcbiAgICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHZvaWQgZ2V0VGhyZWFkc1VwZGF0ZXMocm9vbS5pZCk7XG4gICAgfSwgW3Jvb20uaWRdKTtcbiAgICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUlzT25saW5lKCkge1xuICAgICAgICB2b2lkIGdldFRocmVhZHNVcGRhdGVzKHJvb20uaWQpO1xuICAgICAgfVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgaGFuZGxlSXNPbmxpbmUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgaGFuZGxlSXNPbmxpbmUpO1xuICAgICAgfTtcbiAgICB9LCBbcm9vbS5pZF0pO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgcGFpciA9IHN0YWJsZUVudGVyUm9vbShyb29tSWQsIGZyb3plblByb3BzKTtcbiAgICAgIHNldFJvb21MZWF2ZVBhaXIocGFpcik7XG4gICAgICBjb25zdCB7IHJvb206IHJvb20yLCBsZWF2ZSB9ID0gcGFpcjtcbiAgICAgIGlmIChmcm96ZW5Qcm9wcy5hdXRvQ29ubmVjdCkge1xuICAgICAgICByb29tMi5jb25uZWN0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsZWF2ZSgpO1xuICAgICAgfTtcbiAgICB9LCBbcm9vbUlkLCBmcm96ZW5Qcm9wcywgc3RhYmxlRW50ZXJSb29tXSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSb29tQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcm9vbSB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBDb250ZXh0QnVuZGxlLlByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICB2YWx1ZTogYnVuZGxlXG4gICAgICB9LFxuICAgICAgcHJvcHMuY2hpbGRyZW5cbiAgICApKTtcbiAgfVxuICBmdW5jdGlvbiBjb25uZWN0aW9uSWRTZWxlY3RvcihvdGhlcnMpIHtcbiAgICByZXR1cm4gb3RoZXJzLm1hcCgodXNlcikgPT4gdXNlci5jb25uZWN0aW9uSWQpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJvb20oKSB7XG4gICAgY29uc3Qgcm9vbSA9IFJlYWN0Mi51c2VDb250ZXh0KFJvb21Db250ZXh0KTtcbiAgICBpZiAocm9vbSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbVByb3ZpZGVyIGlzIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIik7XG4gICAgfVxuICAgIHJldHVybiByb29tO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVN0YXR1cygpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmU7XG4gICAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFN0YXR1cztcbiAgICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IHJvb20uZ2V0U3RhdHVzO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlTXlQcmVzZW5jZSgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLm15UHJlc2VuY2Uuc3Vic2NyaWJlO1xuICAgIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRQcmVzZW5jZTtcbiAgICBjb25zdCBwcmVzZW5jZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNuYXBzaG90KTtcbiAgICBjb25zdCBzZXRQcmVzZW5jZSA9IHJvb20udXBkYXRlUHJlc2VuY2U7XG4gICAgcmV0dXJuIFtwcmVzZW5jZSwgc2V0UHJlc2VuY2VdO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVVwZGF0ZU15UHJlc2VuY2UoKSB7XG4gICAgcmV0dXJuIHVzZVJvb20oKS51cGRhdGVQcmVzZW5jZTtcbiAgfVxuICBmdW5jdGlvbiB1c2VPdGhlcnMoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmU7XG4gICAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldE90aGVycztcbiAgICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c0VtcHR5TGlzdDtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBnZXRTbmFwc2hvdCxcbiAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgc2VsZWN0b3IgPz8gaWRlbnRpdHksXG4gICAgICBpc0VxdWFsXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzKCkge1xuICAgIHJldHVybiB1c2VPdGhlcnMoY29ubmVjdGlvbklkU2VsZWN0b3IsIHNoYWxsb3cpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyc01hcHBlZChpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKSB7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKG90aGVycykgPT4gb3RoZXJzLm1hcChcbiAgICAgICAgKG90aGVyKSA9PiBbb3RoZXIuY29ubmVjdGlvbklkLCBpdGVtU2VsZWN0b3Iob3RoZXIpXVxuICAgICAgKSxcbiAgICAgIFtpdGVtU2VsZWN0b3JdXG4gICAgKTtcbiAgICBjb25zdCB3cmFwcGVkSXNFcXVhbCA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgIChhLCBiKSA9PiB7XG4gICAgICAgIGNvbnN0IGVxID0gaXRlbUlzRXF1YWwgPz8gT2JqZWN0LmlzO1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGF0dXBsZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBidHVwbGUgPSBiW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gYXR1cGxlWzBdID09PSBidHVwbGVbMF0gJiYgZXEoYXR1cGxlWzFdLCBidHVwbGVbMV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBbaXRlbUlzRXF1YWxdXG4gICAgKTtcbiAgICByZXR1cm4gdXNlT3RoZXJzKHdyYXBwZWRTZWxlY3Rvciwgd3JhcHBlZElzRXF1YWwpO1xuICB9XG4gIGNvbnN0IE5PVF9GT1VORCA9IFN5bWJvbCgpO1xuICBmdW5jdGlvbiB1c2VPdGhlcihjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKG90aGVycykgPT4ge1xuICAgICAgICBjb25zdCBvdGhlcjIgPSBvdGhlcnMuZmluZChcbiAgICAgICAgICAob3RoZXIzKSA9PiBvdGhlcjMuY29ubmVjdGlvbklkID09PSBjb25uZWN0aW9uSWRcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG90aGVyMiAhPT0gdm9pZCAwID8gc2VsZWN0b3Iob3RoZXIyKSA6IE5PVF9GT1VORDtcbiAgICAgIH0sXG4gICAgICBbY29ubmVjdGlvbklkLCBzZWxlY3Rvcl1cbiAgICApO1xuICAgIGNvbnN0IHdyYXBwZWRJc0VxdWFsID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHByZXYsIGN1cnIpID0+IHtcbiAgICAgICAgaWYgKHByZXYgPT09IE5PVF9GT1VORCB8fCBjdXJyID09PSBOT1RfRk9VTkQpIHtcbiAgICAgICAgICByZXR1cm4gcHJldiA9PT0gY3VycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcSA9IGlzRXF1YWwgPz8gT2JqZWN0LmlzO1xuICAgICAgICByZXR1cm4gZXEocHJldiwgY3Vycik7XG4gICAgICB9LFxuICAgICAgW2lzRXF1YWxdXG4gICAgKTtcbiAgICBjb25zdCBvdGhlciA9IHVzZU90aGVycyh3cmFwcGVkU2VsZWN0b3IsIHdyYXBwZWRJc0VxdWFsKTtcbiAgICBpZiAob3RoZXIgPT09IE5PVF9GT1VORCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTm8gc3VjaCBvdGhlciB1c2VyIHdpdGggY29ubmVjdGlvbiBpZCAke2Nvbm5lY3Rpb25JZH0gZXhpc3RzYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG90aGVyO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUJyb2FkY2FzdEV2ZW50KCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgIChldmVudCwgb3B0aW9uczIgPSB7IHNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5OiBmYWxzZSB9KSA9PiB7XG4gICAgICAgIHJvb20uYnJvYWRjYXN0RXZlbnQoZXZlbnQsIG9wdGlvbnMyKTtcbiAgICAgIH0sXG4gICAgICBbcm9vbV1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyc0xpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgICBSZWFjdDIudXNlRWZmZWN0KFxuICAgICAgKCkgPT4gcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZSgoZXZlbnQpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudCkpLFxuICAgICAgW3Jvb20sIHNhdmVkQ2FsbGJhY2tdXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgICBSZWFjdDIudXNlRWZmZWN0KFxuICAgICAgKCkgPT4gcm9vbS5ldmVudHMubG9zdENvbm5lY3Rpb24uc3Vic2NyaWJlKFxuICAgICAgICAoZXZlbnQpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudClcbiAgICAgICksXG4gICAgICBbcm9vbSwgc2F2ZWRDYWxsYmFja11cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUVycm9yTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoXG4gICAgICAoKSA9PiByb29tLmV2ZW50cy5lcnJvci5zdWJzY3JpYmUoKGUpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChlKSksXG4gICAgICBbcm9vbSwgc2F2ZWRDYWxsYmFja11cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUV2ZW50TGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnREYXRhKSA9PiB7XG4gICAgICAgIHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudERhdGEpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByb29tLmV2ZW50cy5jdXN0b21FdmVudC5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICAgIH0sIFtyb29tLCBzYXZlZENhbGxiYWNrXSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlU2VsZihtYXliZVNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5zZWxmLnN1YnNjcmliZTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0U2VsZjtcbiAgICBjb25zdCBzZWxlY3RvciA9IG1heWJlU2VsZWN0b3IgPz8gaWRlbnRpdHk7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKG1lKSA9PiBtZSAhPT0gbnVsbCA/IHNlbGVjdG9yKG1lKSA6IG51bGwsXG4gICAgICBbc2VsZWN0b3JdXG4gICAgKTtcbiAgICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c051bGw7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgICAgc3Vic2NyaWJlLFxuICAgICAgZ2V0U25hcHNob3QsXG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU11dGFibGVTdG9yYWdlUm9vdCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2U7XG4gICAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdDtcbiAgICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c051bGw7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgfVxuICBmdW5jdGlvbiB1c2VTdG9yYWdlUm9vdCgpIHtcbiAgICByZXR1cm4gW3VzZU11dGFibGVTdG9yYWdlUm9vdCgpXTtcbiAgfVxuICBmdW5jdGlvbiB1c2VIaXN0b3J5KCkge1xuICAgIHJldHVybiB1c2VSb29tKCkuaGlzdG9yeTtcbiAgfVxuICBmdW5jdGlvbiB1c2VVbmRvKCkge1xuICAgIHJldHVybiB1c2VIaXN0b3J5KCkudW5kbztcbiAgfVxuICBmdW5jdGlvbiB1c2VSZWRvKCkge1xuICAgIHJldHVybiB1c2VIaXN0b3J5KCkucmVkbztcbiAgfVxuICBmdW5jdGlvbiB1c2VDYW5VbmRvKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuaGlzdG9yeS5zdWJzY3JpYmU7XG4gICAgY29uc3QgY2FuVW5kbyA9IHJvb20uaGlzdG9yeS5jYW5VbmRvO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGNhblVuZG8sIGNhblVuZG8pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUNhblJlZG8oKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZTtcbiAgICBjb25zdCBjYW5SZWRvID0gcm9vbS5oaXN0b3J5LmNhblJlZG87XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgY2FuUmVkbywgY2FuUmVkbyk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQmF0Y2goKSB7XG4gICAgcmV0dXJuIHVzZVJvb20oKS5iYXRjaDtcbiAgfVxuICBmdW5jdGlvbiB1c2VMZWdhY3lLZXkoa2V5KSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCByb290T3JOdWxsID0gdXNlTXV0YWJsZVN0b3JhZ2VSb290KCk7XG4gICAgY29uc3QgcmVyZW5kZXIgPSB1c2VSZXJlbmRlcigpO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKHJvb3RPck51bGwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm9vdCA9IHJvb3RPck51bGw7XG4gICAgICBsZXQgdW5zdWJDdXJyO1xuICAgICAgbGV0IGN1cnIgPSByb290LmdldChrZXkpO1xuICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlVG9DdXJyKCkge1xuICAgICAgICB1bnN1YkN1cnIgPSBpc0xpdmVOb2RlKGN1cnIpID8gcm9vbS5zdWJzY3JpYmUoY3VyciwgcmVyZW5kZXIpIDogdm9pZCAwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25Sb290Q2hhbmdlKCkge1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHJvb3QuZ2V0KGtleSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gY3Vycikge1xuICAgICAgICAgIHVuc3ViQ3Vycj8uKCk7XG4gICAgICAgICAgY3VyciA9IG5ld1ZhbHVlO1xuICAgICAgICAgIHN1YnNjcmliZVRvQ3VycigpO1xuICAgICAgICAgIHJlcmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN1YnNjcmliZVRvQ3VycigpO1xuICAgICAgcmVyZW5kZXIoKTtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlUm9vdCA9IHJvb20uc3Vic2NyaWJlKHJvb3QsIG9uUm9vdENoYW5nZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB1bnN1YnNjcmliZVJvb3QoKTtcbiAgICAgICAgdW5zdWJDdXJyPy4oKTtcbiAgICAgIH07XG4gICAgfSwgW3Jvb3RPck51bGwsIHJvb20sIGtleSwgcmVyZW5kZXJdKTtcbiAgICBpZiAocm9vdE9yTnVsbCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb290T3JOdWxsLmdldChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1c2VTdG9yYWdlKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCByb290T3JOdWxsID0gdXNlTXV0YWJsZVN0b3JhZ2VSb290KCk7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHJvb3RPck51bGwyKSA9PiByb290T3JOdWxsMiAhPT0gbnVsbCA/IHNlbGVjdG9yKHJvb3RPck51bGwyKSA6IG51bGwsXG4gICAgICBbc2VsZWN0b3JdXG4gICAgKTtcbiAgICBjb25zdCBzdWJzY3JpYmUgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAob25TdG9yZUNoYW5nZSkgPT4gcm9vdE9yTnVsbCAhPT0gbnVsbCA/IHJvb20uc3Vic2NyaWJlKHJvb3RPck51bGwsIG9uU3RvcmVDaGFuZ2UsIHsgaXNEZWVwOiB0cnVlIH0pIDogbm9vcCxcbiAgICAgIFtyb29tLCByb290T3JOdWxsXVxuICAgICk7XG4gICAgY29uc3QgZ2V0U25hcHNob3QgPSBSZWFjdDIudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgaWYgKHJvb3RPck51bGwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByb290ID0gcm9vdE9yTnVsbDtcbiAgICAgICAgY29uc3QgaW1tID0gcm9vdC50b0ltbXV0YWJsZSgpO1xuICAgICAgICByZXR1cm4gaW1tO1xuICAgICAgfVxuICAgIH0sIFtyb290T3JOdWxsXSk7XG4gICAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNOdWxsO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIGdldFNuYXBzaG90LFxuICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICB3cmFwcGVkU2VsZWN0b3IsXG4gICAgICBpc0VxdWFsXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiWW91IGNhbm5vdCB1c2UgdGhlIFN1c3BlbnNlIHZlcnNpb24gb2YgdGhpcyBob29rIG9uIHRoZSBzZXJ2ZXIgc2lkZS4gTWFrZSBzdXJlIHRvIG9ubHkgY2FsbCB0aGVtIG9uIHRoZSBjbGllbnQgc2lkZS5cXG5Gb3IgdGlwcywgc2VlIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1yZWFjdCNzdXNwZW5zZS1hdm9pZC1zc3JcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXNlU3VzcGVuZFVudGlsU3RvcmFnZUxvYWRlZCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGlmIChyb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgICB0aHJvdyBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICByb29tLmV2ZW50cy5zdG9yYWdlRGlkTG9hZC5zdWJzY3JpYmVPbmNlKCgpID0+IHJlcygpKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGlmIChyb29tLmdldFNlbGYoKSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gICAgdGhyb3cgbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgcm9vbS5ldmVudHMuc2VsZi5zdWJzY3JpYmVPbmNlKCgpID0+IHJlcygpKTtcbiAgICAgIHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmVPbmNlKCgpID0+IHJlcygpKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB1c2VNdXRhdGlvbihjYWxsYmFjaywgZGVwcykge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKFxuICAgICAgKCkgPT4ge1xuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICByb29tLmJhdGNoKFxuICAgICAgICAgICAgKCkgPT4gKFxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgbWFrZU11dGF0aW9uQ29udGV4dChyb29tKSxcbiAgICAgICAgICAgICAgICAuLi5hcmdzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgW3Jvb20sIC4uLmRlcHNdXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VTdG9yYWdlU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxTdG9yYWdlTG9hZGVkKCk7XG4gICAgcmV0dXJuIHVzZVN0b3JhZ2UoXG4gICAgICBzZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVNlbGZTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICAgIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlTG9hZGVkKCk7XG4gICAgcmV0dXJuIHVzZVNlbGYoXG4gICAgICBzZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyc1N1c3BlbnNlKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VMb2FkZWQoKTtcbiAgICByZXR1cm4gdXNlT3RoZXJzKFxuICAgICAgc2VsZWN0b3IsXG4gICAgICBpc0VxdWFsXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzU3VzcGVuc2UoKSB7XG4gICAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VMb2FkZWQoKTtcbiAgICByZXR1cm4gdXNlT3RoZXJzQ29ubmVjdGlvbklkcygpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyc01hcHBlZFN1c3BlbnNlKGl0ZW1TZWxlY3RvciwgaXRlbUlzRXF1YWwpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VPdGhlcnNNYXBwZWQoaXRlbVNlbGVjdG9yLCBpdGVtSXNFcXVhbCk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJTdXNwZW5zZShjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VMb2FkZWQoKTtcbiAgICByZXR1cm4gdXNlT3RoZXIoY29ubmVjdGlvbklkLCBzZWxlY3RvciwgaXNFcXVhbCk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlTGVnYWN5S2V5U3VzcGVuc2Uoa2V5KSB7XG4gICAgdXNlU3VzcGVuZFVudGlsU3RvcmFnZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VMZWdhY3lLZXkoa2V5KTtcbiAgfVxuICBjb25zdCBzdG9yZSA9IGNsaWVudFtrSW50ZXJuYWxdLmNhY2hlU3RvcmU7XG4gIGZ1bmN0aW9uIG9uTXV0YXRpb25GYWlsdXJlKGlubmVyRXJyb3IsIG9wdGltaXN0aWNVcGRhdGVJZCwgY3JlYXRlUHVibGljRXJyb3IpIHtcbiAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgKVxuICAgIH0pKTtcbiAgICBpZiAoaW5uZXJFcnJvciBpbnN0YW5jZW9mIENvbW1lbnRzQXBpRXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gaGFuZGxlQXBpRXJyb3IoaW5uZXJFcnJvcik7XG4gICAgICBjb21tZW50c0Vycm9yRXZlbnRTb3VyY2Uubm90aWZ5KGNyZWF0ZVB1YmxpY0Vycm9yKGVycm9yKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbm5lckVycm9yIGluc3RhbmNlb2YgTm90aWZpY2F0aW9uc0FwaUVycm9yKSB7XG4gICAgICBoYW5kbGVBcGlFcnJvcihpbm5lckVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgaW5uZXJFcnJvcjtcbiAgfVxuICBjb25zdCBzdWJzY3JpYmVyc0J5UXVlcnkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCByZXF1ZXN0c0J5UXVlcnkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBwb2xsZXIgPSBtYWtlUG9sbGVyKHJlZnJlc2hUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyk7XG4gIGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hUaHJlYWRzQW5kTm90aWZpY2F0aW9ucygpIHtcbiAgICBjb25zdCByZXF1ZXN0cyA9IFtdO1xuICAgIGNsaWVudFtrSW50ZXJuYWxdLmdldFJvb21JZHMoKS5tYXAoKHJvb21JZCkgPT4ge1xuICAgICAgY29uc3Qgcm9vbSA9IGNsaWVudC5nZXRSb29tKHJvb21JZCk7XG4gICAgICBpZiAocm9vbSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcmVxdWVzdHMucHVzaChnZXRUaHJlYWRzVXBkYXRlcyhyb29tLmlkKSk7XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHJlcXVlc3RzKTtcbiAgfVxuICBmdW5jdGlvbiBpbmNyZW1lbnRRdWVyeVN1YnNjcmliZXJzKHF1ZXJ5S2V5KSB7XG4gICAgY29uc3Qgc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVyc0J5UXVlcnkuZ2V0KHF1ZXJ5S2V5KSA/PyAwO1xuICAgIHN1YnNjcmliZXJzQnlRdWVyeS5zZXQocXVlcnlLZXksIHN1YnNjcmliZXJzICsgMSk7XG4gICAgcG9sbGVyLnN0YXJ0KFBPTExJTkdfSU5URVJWQUwpO1xuICB9XG4gIGZ1bmN0aW9uIGRlY3JlbWVudFF1ZXJ5U3Vic2NyaWJlcnMocXVlcnlLZXkpIHtcbiAgICBjb25zdCBzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzQnlRdWVyeS5nZXQocXVlcnlLZXkpO1xuICAgIGlmIChzdWJzY3JpYmVycyA9PT0gdm9pZCAwIHx8IHN1YnNjcmliZXJzIDw9IDApIHtcbiAgICAgIGNvbnNvbGUyLndhcm4oXG4gICAgICAgIGBJbnRlcm5hbCB1bmV4cGVjdGVkIGJlaGF2aW9yLiBDYW5ub3QgZGVjcmVhc2Ugc3Vic2NyaWJlciBjb3VudCBmb3IgcXVlcnkgXCIke3F1ZXJ5S2V5fVwiYFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3Vic2NyaWJlcnNCeVF1ZXJ5LnNldChxdWVyeUtleSwgc3Vic2NyaWJlcnMgLSAxKTtcbiAgICBsZXQgdG90YWxTdWJzY3JpYmVycyA9IDA7XG4gICAgZm9yIChjb25zdCBzdWJzY3JpYmVyczIgb2Ygc3Vic2NyaWJlcnNCeVF1ZXJ5LnZhbHVlcygpKSB7XG4gICAgICB0b3RhbFN1YnNjcmliZXJzICs9IHN1YnNjcmliZXJzMjtcbiAgICB9XG4gICAgaWYgKHRvdGFsU3Vic2NyaWJlcnMgPD0gMCkge1xuICAgICAgcG9sbGVyLnN0b3AoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkc0FuZEluYm94Tm90aWZpY2F0aW9ucyhyb29tLCBxdWVyeUtleSwgb3B0aW9uczIsIHsgcmV0cnlDb3VudCB9ID0geyByZXRyeUNvdW50OiAwIH0pIHtcbiAgICBjb25zdCBleGlzdGluZ1JlcXVlc3QgPSByZXF1ZXN0c0J5UXVlcnkuZ2V0KHF1ZXJ5S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdSZXF1ZXN0ICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gZXhpc3RpbmdSZXF1ZXN0O1xuICAgIGNvbnN0IHJlcXVlc3QgPSByb29tW2tJbnRlcm5hbF0uY29tbWVudHMuZ2V0VGhyZWFkcyhvcHRpb25zMik7XG4gICAgcmVxdWVzdHNCeVF1ZXJ5LnNldChxdWVyeUtleSwgcmVxdWVzdCk7XG4gICAgc3RvcmUuc2V0UXVlcnlTdGF0ZShxdWVyeUtleSwge1xuICAgICAgaXNMb2FkaW5nOiB0cnVlXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Q7XG4gICAgICBzdG9yZS51cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyhcbiAgICAgICAgcmVzdWx0LnRocmVhZHMsXG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgIHJlc3VsdC5kZWxldGVkVGhyZWFkcyxcbiAgICAgICAgcmVzdWx0LmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgIHF1ZXJ5S2V5XG4gICAgICApO1xuICAgICAgY29uc3QgbGFzdFJlcXVlc3RlZEF0ID0gbGFzdFJlcXVlc3RlZEF0QnlSb29tLmdldChyb29tLmlkKTtcbiAgICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPT09IHZvaWQgMCB8fCBsYXN0UmVxdWVzdGVkQXQgPiByZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdCkge1xuICAgICAgICBsYXN0UmVxdWVzdGVkQXRCeVJvb20uc2V0KHJvb20uaWQsIHJlc3VsdC5tZXRhLnJlcXVlc3RlZEF0KTtcbiAgICAgIH1cbiAgICAgIHBvbGxlci5zdGFydChQT0xMSU5HX0lOVEVSVkFMKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlcXVlc3RzQnlRdWVyeS5kZWxldGUocXVlcnlLZXkpO1xuICAgICAgcmV0cnlFcnJvcigoKSA9PiB7XG4gICAgICAgIHZvaWQgZ2V0VGhyZWFkc0FuZEluYm94Tm90aWZpY2F0aW9ucyhyb29tLCBxdWVyeUtleSwgb3B0aW9uczIsIHtcbiAgICAgICAgICByZXRyeUNvdW50OiByZXRyeUNvdW50ICsgMVxuICAgICAgICB9KTtcbiAgICAgIH0sIHJldHJ5Q291bnQpO1xuICAgICAgc3RvcmUuc2V0UXVlcnlTdGF0ZShxdWVyeUtleSwge1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3QgREVGQVVMVF9ERURVUElOR19JTlRFUlZBTCA9IDJlMztcbiAgY29uc3QgbGFzdFJlcXVlc3RlZEF0QnlSb29tID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgcmVxdWVzdFN0YXR1c0J5Um9vbSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRocmVhZHNVcGRhdGVzKHJvb21JZCkge1xuICAgIGNvbnN0IHJvb20gPSBjbGllbnQuZ2V0Um9vbShyb29tSWQpO1xuICAgIGlmIChyb29tID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHNpbmNlID0gbGFzdFJlcXVlc3RlZEF0QnlSb29tLmdldChyb29tLmlkKTtcbiAgICBpZiAoc2luY2UgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpc0ZldGNoaW5nVGhyZWFkc1VwZGF0ZXMgPSByZXF1ZXN0U3RhdHVzQnlSb29tLmdldChyb29tLmlkKSA/PyBmYWxzZTtcbiAgICBpZiAoaXNGZXRjaGluZ1RocmVhZHNVcGRhdGVzID09PSB0cnVlKVxuICAgICAgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICByZXF1ZXN0U3RhdHVzQnlSb29tLnNldChyb29tLmlkLCB0cnVlKTtcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSBhd2FpdCByb29tW2tJbnRlcm5hbF0uY29tbWVudHMuZ2V0VGhyZWFkcyh7IHNpbmNlIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlcXVlc3RTdGF0dXNCeVJvb20uc2V0KHJvb20uaWQsIGZhbHNlKTtcbiAgICAgIH0sIERFRkFVTFRfREVEVVBJTkdfSU5URVJWQUwpO1xuICAgICAgc3RvcmUudXBkYXRlVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnMoXG4gICAgICAgIHVwZGF0ZXMudGhyZWFkcyxcbiAgICAgICAgdXBkYXRlcy5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgIHVwZGF0ZXMuZGVsZXRlZFRocmVhZHMsXG4gICAgICAgIHVwZGF0ZXMuZGVsZXRlZEluYm94Tm90aWZpY2F0aW9uc1xuICAgICAgKTtcbiAgICAgIGxhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5zZXQocm9vbS5pZCwgdXBkYXRlcy5tZXRhLnJlcXVlc3RlZEF0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlcXVlc3RTdGF0dXNCeVJvb20uc2V0KHJvb20uaWQsIGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXNlVGhyZWFkcyhvcHRpb25zMiA9IHsgcXVlcnk6IHsgbWV0YWRhdGE6IHt9IH0gfSkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBSZWFjdDIudXNlTWVtbyhcbiAgICAgICgpID0+IGdlbmVyYXRlUXVlcnlLZXkocm9vbS5pZCwgb3B0aW9uczIucXVlcnkpLFxuICAgICAgW3Jvb20sIG9wdGlvbnMyXVxuICAgICk7XG4gICAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICB2b2lkIGdldFRocmVhZHNBbmRJbmJveE5vdGlmaWNhdGlvbnMocm9vbSwgcXVlcnlLZXksIG9wdGlvbnMyKTtcbiAgICAgIGluY3JlbWVudFF1ZXJ5U3Vic2NyaWJlcnMocXVlcnlLZXkpO1xuICAgICAgcmV0dXJuICgpID0+IGRlY3JlbWVudFF1ZXJ5U3Vic2NyaWJlcnMocXVlcnlLZXkpO1xuICAgIH0sIFtyb29tLCBxdWVyeUtleV0pO1xuICAgIGNvbnN0IHNlbGVjdG9yID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gc3RhdGUucXVlcmllc1txdWVyeUtleV07XG4gICAgICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwIHx8IHF1ZXJ5LmlzTG9hZGluZykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0xvYWRpbmc6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGhyZWFkczogc2VsZWN0ZWRUaHJlYWRzKHJvb20uaWQsIHN0YXRlLCBvcHRpb25zMiksXG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogcXVlcnkuZXJyb3JcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBbcm9vbSwgcXVlcnlLZXldXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICk7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc2VsZWN0b3JcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVRocmVhZHNTdXNwZW5zZShvcHRpb25zMiA9IHsgcXVlcnk6IHsgbWV0YWRhdGE6IHt9IH0gfSkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBSZWFjdDIudXNlTWVtbyhcbiAgICAgICgpID0+IGdlbmVyYXRlUXVlcnlLZXkocm9vbS5pZCwgb3B0aW9uczI/LnF1ZXJ5KSxcbiAgICAgIFtyb29tLCBvcHRpb25zMl1cbiAgICApO1xuICAgIGNvbnN0IHF1ZXJ5ID0gc3RvcmUuZ2V0KCkucXVlcmllc1txdWVyeUtleV07XG4gICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDAgfHwgcXVlcnkuaXNMb2FkaW5nKSB7XG4gICAgICB0aHJvdyBnZXRUaHJlYWRzQW5kSW5ib3hOb3RpZmljYXRpb25zKHJvb20sIHF1ZXJ5S2V5LCBvcHRpb25zMik7XG4gICAgfVxuICAgIGlmIChxdWVyeS5lcnJvcikge1xuICAgICAgdGhyb3cgcXVlcnkuZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdG9yID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHN0YXRlKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGhyZWFkczogc2VsZWN0ZWRUaHJlYWRzKHJvb20uaWQsIHN0YXRlLCBvcHRpb25zMiksXG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIFtyb29tLCBxdWVyeUtleV1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgKTtcbiAgICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGluY3JlbWVudFF1ZXJ5U3Vic2NyaWJlcnMocXVlcnlLZXkpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZGVjcmVtZW50UXVlcnlTdWJzY3JpYmVycyhxdWVyeUtleSk7XG4gICAgICB9O1xuICAgIH0sIFtxdWVyeUtleV0pO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHNlbGVjdG9yXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VDcmVhdGVUaHJlYWQoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKG9wdGlvbnMyKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zMi5ib2R5O1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IFwibWV0YWRhdGFcIiBpbiBvcHRpb25zMiA/IG9wdGlvbnMyLm1ldGFkYXRhIDoge307XG4gICAgICAgIGNvbnN0IHRocmVhZElkID0gY3JlYXRlVGhyZWFkSWQoKTtcbiAgICAgICAgY29uc3QgY29tbWVudElkID0gY3JlYXRlQ29tbWVudElkKCk7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBuZXdDb21tZW50ID0ge1xuICAgICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgICB0eXBlOiBcImNvbW1lbnRcIixcbiAgICAgICAgICB1c2VySWQ6IGdldEN1cnJlbnRVc2VySWQocm9vbSksXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICByZWFjdGlvbnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5ld1RocmVhZCA9IHtcbiAgICAgICAgICBpZDogdGhyZWFkSWQsXG4gICAgICAgICAgdHlwZTogXCJ0aHJlYWRcIixcbiAgICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgICAgdXBkYXRlZEF0OiBjcmVhdGVkQXQsXG4gICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgIGNvbW1lbnRzOiBbbmV3Q29tbWVudF1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMigpO1xuICAgICAgICBzdG9yZS5wdXNoT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgICAgdHlwZTogXCJjcmVhdGUtdGhyZWFkXCIsXG4gICAgICAgICAgdGhyZWFkOiBuZXdUaHJlYWQsXG4gICAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICB9KTtcbiAgICAgICAgcm9vbVtrSW50ZXJuYWxdLmNvbW1lbnRzLmNyZWF0ZVRocmVhZCh7IHRocmVhZElkLCBjb21tZW50SWQsIGJvZHksIG1ldGFkYXRhIH0pLnRoZW4oXG4gICAgICAgICAgKHRocmVhZCkgPT4ge1xuICAgICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZS50aHJlYWRzLFxuICAgICAgICAgICAgICAgIFt0aHJlYWRJZF06IHRocmVhZFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgKGVycjIpID0+IG5ldyBDcmVhdGVUaHJlYWRFcnJvcihlcnIyLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbmV3VGhyZWFkO1xuICAgICAgfSxcbiAgICAgIFtyb29tXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRWRpdFRocmVhZE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgIChvcHRpb25zMikgPT4ge1xuICAgICAgICBpZiAoIShcIm1ldGFkYXRhXCIgaW4gb3B0aW9uczIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRocmVhZElkID0gb3B0aW9uczIudGhyZWFkSWQ7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gb3B0aW9uczIubWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQyKCk7XG4gICAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgICB0eXBlOiBcImVkaXQtdGhyZWFkLW1ldGFkYXRhXCIsXG4gICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICB1cGRhdGVkQXRcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb21ba0ludGVybmFsXS5jb21tZW50cy5lZGl0VGhyZWFkTWV0YWRhdGEoeyBtZXRhZGF0YSwgdGhyZWFkSWQgfSkudGhlbihcbiAgICAgICAgICAobWV0YWRhdGEyKSA9PiB7XG4gICAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gc3RhdGUudGhyZWFkc1t0aHJlYWRJZF07XG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlcyA9IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUaHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChleGlzdGluZ1RocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChleGlzdGluZ1RocmVhZC51cGRhdGVkQXQgJiYgZXhpc3RpbmdUaHJlYWQudXBkYXRlZEF0ID4gdXBkYXRlZEF0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICB0aHJlYWRzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZS50aHJlYWRzLFxuICAgICAgICAgICAgICAgICAgW3RocmVhZElkXToge1xuICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ1RocmVhZCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ1RocmVhZC5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAuLi5tZXRhZGF0YTJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIChlcnJvcikgPT4gbmV3IEVkaXRUaHJlYWRNZXRhZGF0YUVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBbcm9vbV1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUFkZFJlYWN0aW9uKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgICh7IHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pID0+IHtcbiAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IGdldEN1cnJlbnRVc2VySWQocm9vbSk7XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDIoKTtcbiAgICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICAgIHR5cGU6IFwiYWRkLXJlYWN0aW9uXCIsXG4gICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgIHJlYWN0aW9uOiB7XG4gICAgICAgICAgICBlbW9qaSxcbiAgICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICB9KTtcbiAgICAgICAgcm9vbVtrSW50ZXJuYWxdLmNvbW1lbnRzLmFkZFJlYWN0aW9uKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkudGhlbihcbiAgICAgICAgICAoYWRkZWRSZWFjdGlvbikgPT4ge1xuICAgICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXMgPSBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLnRocmVhZHMsXG4gICAgICAgICAgICAgICAgICBbdGhyZWFkSWRdOiBhZGRSZWFjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdUaHJlYWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRSZWFjdGlvblxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIChlcnJvcikgPT4gbmV3IEFkZFJlYWN0aW9uRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgICBlbW9qaVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgW3Jvb21dXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VSZW1vdmVSZWFjdGlvbigpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IGdldEN1cnJlbnRVc2VySWQocm9vbSk7XG4gICAgICAgIGNvbnN0IHJlbW92ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQyKCk7XG4gICAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgICB0eXBlOiBcInJlbW92ZS1yZWFjdGlvblwiLFxuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICBlbW9qaSxcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgcmVtb3ZlZEF0LFxuICAgICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb21ba0ludGVybmFsXS5jb21tZW50cy5yZW1vdmVSZWFjdGlvbih7IHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pLnRoZW4oXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXMgPSBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLnRocmVhZHMsXG4gICAgICAgICAgICAgICAgICBbdGhyZWFkSWRdOiByZW1vdmVSZWFjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdUaHJlYWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgZW1vamksXG4gICAgICAgICAgICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEF0XG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgKGVycm9yKSA9PiBuZXcgUmVtb3ZlUmVhY3Rpb25FcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgIGVtb2ppXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBbcm9vbV1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUNyZWF0ZUNvbW1lbnQoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHsgdGhyZWFkSWQsIGJvZHkgfSkgPT4ge1xuICAgICAgICBjb25zdCBjb21tZW50SWQgPSBjcmVhdGVDb21tZW50SWQoKTtcbiAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IGNvbW1lbnQgPSB7XG4gICAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICAgIHVzZXJJZDogZ2V0Q3VycmVudFVzZXJJZChyb29tKSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIHJlYWN0aW9uczogW11cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMigpO1xuICAgICAgICBzdG9yZS5wdXNoT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgICAgdHlwZTogXCJjcmVhdGUtY29tbWVudFwiLFxuICAgICAgICAgIGNvbW1lbnQsXG4gICAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICB9KTtcbiAgICAgICAgcm9vbVtrSW50ZXJuYWxdLmNvbW1lbnRzLmNyZWF0ZUNvbW1lbnQoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5IH0pLnRoZW4oXG4gICAgICAgICAgKG5ld0NvbW1lbnQpID0+IHtcbiAgICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSBzdGF0ZS50aHJlYWRzW3RocmVhZElkXTtcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzID0gc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBPYmplY3QudmFsdWVzKFxuICAgICAgICAgICAgICAgIHN0YXRlLmluYm94Tm90aWZpY2F0aW9uc1xuICAgICAgICAgICAgICApLmZpbmQoKG5vdGlmaWNhdGlvbikgPT4gbm90aWZpY2F0aW9uLnRocmVhZElkID09PSB0aHJlYWRJZCk7XG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnMgPSBpbmJveE5vdGlmaWNhdGlvbiAhPT0gdm9pZCAwID8ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLmluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICAgICAgICBbaW5ib3hOb3RpZmljYXRpb24uaWRdOiB7XG4gICAgICAgICAgICAgICAgICAuLi5pbmJveE5vdGlmaWNhdGlvbixcbiAgICAgICAgICAgICAgICAgIG5vdGlmaWVkQXQ6IG5ld0NvbW1lbnQuY3JlYXRlZEF0LFxuICAgICAgICAgICAgICAgICAgcmVhZEF0OiBuZXdDb21tZW50LmNyZWF0ZWRBdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSA6IHN0YXRlLmluYm94Tm90aWZpY2F0aW9ucztcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICB0aHJlYWRzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZS50aHJlYWRzLFxuICAgICAgICAgICAgICAgICAgW3RocmVhZElkXTogdXBzZXJ0Q29tbWVudChleGlzdGluZ1RocmVhZCwgbmV3Q29tbWVudClcbiAgICAgICAgICAgICAgICAgIC8vIFVwc2VydCB0aGUgbmV3IGNvbW1lbnQgaW50byB0aGUgdGhyZWFkIGNvbW1lbnRzIGxpc3QgKGlmIGFwcGxpY2FibGUpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIChlcnIyKSA9PiBuZXcgQ3JlYXRlQ29tbWVudEVycm9yKGVycjIsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgICBib2R5XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgICB9LFxuICAgICAgW3Jvb21dXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VFZGl0Q29tbWVudCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5IH0pID0+IHtcbiAgICAgICAgY29uc3QgZWRpdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMigpO1xuICAgICAgICBjb25zdCB0aHJlYWQgPSBzdG9yZS5nZXQoKS50aHJlYWRzW3RocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uc29sZTIud2FybihcbiAgICAgICAgICAgIGBJbnRlcm5hbCB1bmV4cGVjdGVkIGJlaGF2aW9yLiBDYW5ub3QgZWRpdCBjb21tZW50IGluIHRocmVhZCBcIiR7dGhyZWFkSWR9XCIgYmVjYXVzZSB0aGUgdGhyZWFkIGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tbWVudCA9IHRocmVhZC5jb21tZW50cy5maW5kKFxuICAgICAgICAgIChjb21tZW50MikgPT4gY29tbWVudDIuaWQgPT09IGNvbW1lbnRJZFxuICAgICAgICApO1xuICAgICAgICBpZiAoY29tbWVudCA9PT0gdm9pZCAwIHx8IGNvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zb2xlMi53YXJuKFxuICAgICAgICAgICAgYEludGVybmFsIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIENhbm5vdCBlZGl0IGNvbW1lbnQgXCIke2NvbW1lbnRJZH1cIiBpbiB0aHJlYWQgXCIke3RocmVhZElkfVwiIGJlY2F1c2UgdGhlIGNvbW1lbnQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdG9yZS5wdXNoT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgICAgdHlwZTogXCJlZGl0LWNvbW1lbnRcIixcbiAgICAgICAgICBjb21tZW50OiB7XG4gICAgICAgICAgICAuLi5jb21tZW50LFxuICAgICAgICAgICAgZWRpdGVkQXQsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgIH0pO1xuICAgICAgICByb29tW2tJbnRlcm5hbF0uY29tbWVudHMuZWRpdENvbW1lbnQoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5IH0pLnRoZW4oXG4gICAgICAgICAgKGVkaXRlZENvbW1lbnQpID0+IHtcbiAgICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSBzdGF0ZS50aHJlYWRzW3RocmVhZElkXTtcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzID0gc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICB0aHJlYWRzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZS50aHJlYWRzLFxuICAgICAgICAgICAgICAgICAgW3RocmVhZElkXTogdXBzZXJ0Q29tbWVudChleGlzdGluZ1RocmVhZCwgZWRpdGVkQ29tbWVudClcbiAgICAgICAgICAgICAgICAgIC8vIFVwc2VydCB0aGUgZWRpdGVkIGNvbW1lbnQgaW50byB0aGUgdGhyZWFkIGNvbW1lbnRzIGxpc3QgKGlmIGFwcGxpY2FibGUpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgKGVycm9yKSA9PiBuZXcgRWRpdENvbW1lbnRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIFtyb29tXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRGVsZXRlQ29tbWVudCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkIH0pID0+IHtcbiAgICAgICAgY29uc3QgZGVsZXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDIoKTtcbiAgICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICAgIHR5cGU6IFwiZGVsZXRlLWNvbW1lbnRcIixcbiAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgZGVsZXRlZEF0LFxuICAgICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb21ba0ludGVybmFsXS5jb21tZW50cy5kZWxldGVDb21tZW50KHsgdGhyZWFkSWQsIGNvbW1lbnRJZCB9KS50aGVuKFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSBzdGF0ZS50aHJlYWRzW3RocmVhZElkXTtcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzID0gc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICB0aHJlYWRzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZS50aHJlYWRzLFxuICAgICAgICAgICAgICAgICAgW3RocmVhZElkXTogZGVsZXRlQ29tbWVudChcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdUaHJlYWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEF0XG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgKGVycm9yKSA9PiBuZXcgRGVsZXRlQ29tbWVudEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICAgIGNvbW1lbnRJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgW3Jvb21dXG4gICAgKTtcbiAgfVxuICBjb25zdCByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zID0gY2xpZW50W2tJbnRlcm5hbF0ucmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucztcbiAgY29uc3QgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiB1c2VNZW50aW9uU3VnZ2VzdGlvbnMoc2VhcmNoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBbbWVudGlvblN1Z2dlc3Rpb25zLCBzZXRNZW50aW9uU3VnZ2VzdGlvbnNdID0gUmVhY3QyLnVzZVN0YXRlKCk7XG4gICAgY29uc3QgbGFzdEludm9rZWRBdCA9IFJlYWN0Mi51c2VSZWYoKTtcbiAgICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChzZWFyY2ggPT09IHZvaWQgMCB8fCAhcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zQXJncyA9IHsgdGV4dDogc2VhcmNoLCByb29tSWQ6IHJvb20uaWQgfTtcbiAgICAgIGNvbnN0IG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlS2V5ID0gc3RyaW5naWZ5KFxuICAgICAgICByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zQXJnc1xuICAgICAgKTtcbiAgICAgIGxldCBkZWJvdW5jZVRpbWVvdXQ7XG4gICAgICBsZXQgaXNDYW5jZWxlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgZ2V0TWVudGlvblN1Z2dlc3Rpb25zID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxhc3RJbnZva2VkQXQuY3VycmVudCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGNvbnN0IG1lbnRpb25TdWdnZXN0aW9uczIgPSBhd2FpdCByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zKFxuICAgICAgICAgICAgcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uc0FyZ3NcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghaXNDYW5jZWxlZCkge1xuICAgICAgICAgICAgc2V0TWVudGlvblN1Z2dlc3Rpb25zKG1lbnRpb25TdWdnZXN0aW9uczIpO1xuICAgICAgICAgICAgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUuc2V0KFxuICAgICAgICAgICAgICBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZUtleSxcbiAgICAgICAgICAgICAgbWVudGlvblN1Z2dlc3Rpb25zMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZTIuZXJyb3IoZXJyb3I/Lm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlLmhhcyhtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZUtleSkpIHtcbiAgICAgICAgc2V0TWVudGlvblN1Z2dlc3Rpb25zKFxuICAgICAgICAgIG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlLmdldChtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZUtleSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoIWxhc3RJbnZva2VkQXQuY3VycmVudCB8fCBNYXRoLmFicyhwZXJmb3JtYW5jZS5ub3coKSAtIGxhc3RJbnZva2VkQXQuY3VycmVudCkgPiBNRU5USU9OX1NVR0dFU1RJT05TX0RFQk9VTkNFKSB7XG4gICAgICAgIHZvaWQgZ2V0TWVudGlvblN1Z2dlc3Rpb25zKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJvdW5jZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdm9pZCBnZXRNZW50aW9uU3VnZ2VzdGlvbnMoKTtcbiAgICAgICAgfSwgTUVOVElPTl9TVUdHRVNUSU9OU19ERUJPVU5DRSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpc0NhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVvdXQpO1xuICAgICAgfTtcbiAgICB9LCBbcm9vbS5pZCwgc2VhcmNoXSk7XG4gICAgcmV0dXJuIG1lbnRpb25TdWdnZXN0aW9ucztcbiAgfVxuICBmdW5jdGlvbiB1c2VUaHJlYWRTdWJzY3JpcHRpb24odGhyZWFkSWQpIHtcbiAgICBjb25zdCBzZWxlY3RvciA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgIChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbiA9IHNlbGVjdGVkSW5ib3hOb3RpZmljYXRpb25zKHN0YXRlKS5maW5kKFxuICAgICAgICAgIChpbmJveE5vdGlmaWNhdGlvbjIpID0+IGluYm94Tm90aWZpY2F0aW9uMi50aHJlYWRJZCA9PT0gdGhyZWFkSWRcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gc3RhdGUudGhyZWFkc1t0aHJlYWRJZF07XG4gICAgICAgIGlmIChpbmJveE5vdGlmaWNhdGlvbiA9PT0gdm9pZCAwIHx8IHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogXCJub3Qtc3Vic2NyaWJlZFwiXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogXCJzdWJzY3JpYmVkXCIsXG4gICAgICAgICAgdW5yZWFkU2luY2U6IGluYm94Tm90aWZpY2F0aW9uLnJlYWRBdFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIFt0aHJlYWRJZF1cbiAgICApO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHNlbGVjdG9yXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VNYXJrVGhyZWFkQXNSZWFkKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgICh0aHJlYWRJZCkgPT4ge1xuICAgICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbiA9IE9iamVjdC52YWx1ZXMoXG4gICAgICAgICAgc3RvcmUuZ2V0KCkuaW5ib3hOb3RpZmljYXRpb25zXG4gICAgICAgICkuZmluZCgoaW5ib3hOb3RpZmljYXRpb24yKSA9PiBpbmJveE5vdGlmaWNhdGlvbjIudGhyZWFkSWQgPT09IHRocmVhZElkKTtcbiAgICAgICAgaWYgKCFpbmJveE5vdGlmaWNhdGlvbilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDIoKTtcbiAgICAgICAgY29uc3Qgbm93ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgICB0eXBlOiBcIm1hcmstaW5ib3gtbm90aWZpY2F0aW9uLWFzLXJlYWRcIixcbiAgICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWQ6IGluYm94Tm90aWZpY2F0aW9uLmlkLFxuICAgICAgICAgIHJlYWRBdDogbm93XG4gICAgICAgIH0pO1xuICAgICAgICByb29tW2tJbnRlcm5hbF0ubm90aWZpY2F0aW9ucy5tYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoaW5ib3hOb3RpZmljYXRpb24uaWQpLnRoZW4oXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLmluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICAgICAgICBbaW5ib3hOb3RpZmljYXRpb24uaWRdOiB7XG4gICAgICAgICAgICAgICAgICAuLi5pbmJveE5vdGlmaWNhdGlvbixcbiAgICAgICAgICAgICAgICAgIHJlYWRBdDogbm93XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgIG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgICAgKGVycm9yKSA9PiBuZXcgTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkOiBpbmJveE5vdGlmaWNhdGlvbi5pZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgW3Jvb21dXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBtYWtlTm90aWZpY2F0aW9uU2V0dGluZ3NRdWVyeUtleShyb29tSWQpIHtcbiAgICByZXR1cm4gYCR7cm9vbUlkfTpOT1RJRklDQVRJT05fU0VUVElOR1NgO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbSwgcXVlcnlLZXksIHsgcmV0cnlDb3VudCB9ID0geyByZXRyeUNvdW50OiAwIH0pIHtcbiAgICBjb25zdCBleGlzdGluZ1JlcXVlc3QgPSByZXF1ZXN0c0J5UXVlcnkuZ2V0KHF1ZXJ5S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdSZXF1ZXN0ICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gZXhpc3RpbmdSZXF1ZXN0O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gcm9vbVtrSW50ZXJuYWxdLm5vdGlmaWNhdGlvbnMuZ2V0Um9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCk7XG4gICAgICByZXF1ZXN0c0J5UXVlcnkuc2V0KHF1ZXJ5S2V5LCByZXF1ZXN0KTtcbiAgICAgIHN0b3JlLnNldFF1ZXJ5U3RhdGUocXVlcnlLZXksIHtcbiAgICAgICAgaXNMb2FkaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgcmVxdWVzdDtcbiAgICAgIHN0b3JlLnVwZGF0ZVJvb21JbmJveE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb20uaWQsIHNldHRpbmdzLCBxdWVyeUtleSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXF1ZXN0c0J5UXVlcnkuZGVsZXRlKHF1ZXJ5S2V5KTtcbiAgICAgIHJldHJ5RXJyb3IoKCkgPT4ge1xuICAgICAgICB2b2lkIGdldEluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbSwgcXVlcnlLZXksIHtcbiAgICAgICAgICByZXRyeUNvdW50OiByZXRyeUNvdW50ICsgMVxuICAgICAgICB9KTtcbiAgICAgIH0sIHJldHJ5Q291bnQpO1xuICAgICAgc3RvcmUuc2V0UXVlcnlTdGF0ZShxdWVyeUtleSwge1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBxdWVyeUtleSA9IG1ha2VOb3RpZmljYXRpb25TZXR0aW5nc1F1ZXJ5S2V5KHJvb20uaWQpO1xuICAgICAgdm9pZCBnZXRJbmJveE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb20sIHF1ZXJ5S2V5KTtcbiAgICB9LCBbcm9vbV0pO1xuICAgIGNvbnN0IHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyA9IHVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpO1xuICAgIGNvbnN0IHNlbGVjdG9yID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gc3RhdGUucXVlcmllc1ttYWtlTm90aWZpY2F0aW9uU2V0dGluZ3NRdWVyeUtleShyb29tLmlkKV07XG4gICAgICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwIHx8IHF1ZXJ5LmlzTG9hZGluZykge1xuICAgICAgICAgIHJldHVybiB7IGlzTG9hZGluZzogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeS5lcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgaXNMb2FkaW5nOiBmYWxzZSwgZXJyb3I6IHF1ZXJ5LmVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgIHNldHRpbmdzOiBzZWxlY3ROb3RpZmljYXRpb25TZXR0aW5ncyhyb29tLmlkLCBzdGF0ZSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBbcm9vbV1cbiAgICApO1xuICAgIGNvbnN0IHNldHRpbmdzID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzZWxlY3RvclxuICAgICk7XG4gICAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKCgpID0+IHtcbiAgICAgIHJldHVybiBbc2V0dGluZ3MsIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc107XG4gICAgfSwgW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZSgpIHtcbiAgICBjb25zdCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MgPSB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MoKTtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZU5vdGlmaWNhdGlvblNldHRpbmdzUXVlcnlLZXkocm9vbS5pZCk7XG4gICAgY29uc3QgcXVlcnkgPSBzdG9yZS5nZXQoKS5xdWVyaWVzW3F1ZXJ5S2V5XTtcbiAgICBpZiAocXVlcnkgPT09IHZvaWQgMCB8fCBxdWVyeS5pc0xvYWRpbmcpIHtcbiAgICAgIHRocm93IGdldEluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbSwgcXVlcnlLZXkpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZXJyb3IpIHtcbiAgICAgIHRocm93IHF1ZXJ5LmVycm9yO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RvciA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgIChzdGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgc2V0dGluZ3M6IHNlbGVjdE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb20uaWQsIHN0YXRlKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIFtyb29tXVxuICAgICk7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHNlbGVjdG9yXG4gICAgKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZU1lbW8oKCkgPT4ge1xuICAgICAgcmV0dXJuIFtzZXR0aW5ncywgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzXTtcbiAgICB9LCBbc2V0dGluZ3MsIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc10pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMigpO1xuICAgICAgICBzdG9yZS5wdXNoT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICB0eXBlOiBcInVwZGF0ZS1ub3RpZmljYXRpb24tc2V0dGluZ3NcIixcbiAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgc2V0dGluZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb21ba0ludGVybmFsXS5ub3RpZmljYXRpb25zLnVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykudGhlbihcbiAgICAgICAgICAoc2V0dGluZ3MyKSA9PiB7XG4gICAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgbm90aWZpY2F0aW9uU2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgICBbcm9vbS5pZF06IHNldHRpbmdzMlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgKGVycm9yKSA9PiBuZXcgVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIFtyb29tXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQ3VycmVudFVzZXJJZCgpIHtcbiAgICByZXR1cm4gdXNlU2VsZigodXNlcikgPT4gdHlwZW9mIHVzZXIuaWQgPT09IFwic3RyaW5nXCIgPyB1c2VyLmlkIDogbnVsbCk7XG4gIH1cbiAgY29uc3QgYnVuZGxlID0ge1xuICAgIFJvb21Db250ZXh0LFxuICAgIFJvb21Qcm92aWRlcjogUm9vbVByb3ZpZGVyT3V0ZXIsXG4gICAgdXNlUm9vbSxcbiAgICB1c2VTdGF0dXMsXG4gICAgdXNlQmF0Y2gsXG4gICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgdXNlT3RoZXJzTGlzdGVuZXIsXG4gICAgdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcixcbiAgICB1c2VFcnJvckxpc3RlbmVyLFxuICAgIHVzZUV2ZW50TGlzdGVuZXIsXG4gICAgdXNlSGlzdG9yeSxcbiAgICB1c2VVbmRvLFxuICAgIHVzZVJlZG8sXG4gICAgdXNlQ2FuUmVkbyxcbiAgICB1c2VDYW5VbmRvLFxuICAgIC8vIFRoZXNlIGFyZSBqdXN0IGFsaWFzZXMuIFRoZSBwYXNzZWQtaW4ga2V5IHdpbGwgZGVmaW5lIHRoZWlyIHJldHVybiB2YWx1ZXMuXG4gICAgdXNlTGlzdDogdXNlTGVnYWN5S2V5LFxuICAgIHVzZU1hcDogdXNlTGVnYWN5S2V5LFxuICAgIHVzZU9iamVjdDogdXNlTGVnYWN5S2V5LFxuICAgIHVzZVN0b3JhZ2VSb290LFxuICAgIHVzZVN0b3JhZ2UsXG4gICAgdXNlU2VsZixcbiAgICB1c2VNeVByZXNlbmNlLFxuICAgIHVzZVVwZGF0ZU15UHJlc2VuY2UsXG4gICAgdXNlT3RoZXJzLFxuICAgIHVzZU90aGVyc01hcHBlZCxcbiAgICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzLFxuICAgIHVzZU90aGVyLFxuICAgIHVzZU11dGF0aW9uLFxuICAgIHVzZVRocmVhZHMsXG4gICAgdXNlQ3JlYXRlVGhyZWFkLFxuICAgIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICB1c2VDcmVhdGVDb21tZW50LFxuICAgIHVzZUVkaXRDb21tZW50LFxuICAgIHVzZURlbGV0ZUNvbW1lbnQsXG4gICAgdXNlQWRkUmVhY3Rpb24sXG4gICAgdXNlUmVtb3ZlUmVhY3Rpb24sXG4gICAgdXNlTWFya1RocmVhZEFzUmVhZCxcbiAgICB1c2VUaHJlYWRTdWJzY3JpcHRpb24sXG4gICAgdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgIHVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAuLi5zaGFyZWQsXG4gICAgc3VzcGVuc2U6IHtcbiAgICAgIFJvb21Db250ZXh0LFxuICAgICAgUm9vbVByb3ZpZGVyOiBSb29tUHJvdmlkZXJPdXRlcixcbiAgICAgIHVzZVJvb20sXG4gICAgICB1c2VTdGF0dXMsXG4gICAgICB1c2VCYXRjaCxcbiAgICAgIHVzZUJyb2FkY2FzdEV2ZW50LFxuICAgICAgdXNlT3RoZXJzTGlzdGVuZXIsXG4gICAgICB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyLFxuICAgICAgdXNlRXJyb3JMaXN0ZW5lcixcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIsXG4gICAgICB1c2VIaXN0b3J5LFxuICAgICAgdXNlVW5kbyxcbiAgICAgIHVzZVJlZG8sXG4gICAgICB1c2VDYW5SZWRvLFxuICAgICAgdXNlQ2FuVW5kbyxcbiAgICAgIC8vIExlZ2FjeSBob29rc1xuICAgICAgdXNlTGlzdDogdXNlTGVnYWN5S2V5U3VzcGVuc2UsXG4gICAgICB1c2VNYXA6IHVzZUxlZ2FjeUtleVN1c3BlbnNlLFxuICAgICAgdXNlT2JqZWN0OiB1c2VMZWdhY3lLZXlTdXNwZW5zZSxcbiAgICAgIHVzZVN0b3JhZ2VSb290LFxuICAgICAgdXNlU3RvcmFnZTogdXNlU3RvcmFnZVN1c3BlbnNlLFxuICAgICAgdXNlU2VsZjogdXNlU2VsZlN1c3BlbnNlLFxuICAgICAgdXNlTXlQcmVzZW5jZSxcbiAgICAgIHVzZVVwZGF0ZU15UHJlc2VuY2UsXG4gICAgICB1c2VPdGhlcnM6IHVzZU90aGVyc1N1c3BlbnNlLFxuICAgICAgdXNlT3RoZXJzTWFwcGVkOiB1c2VPdGhlcnNNYXBwZWRTdXNwZW5zZSxcbiAgICAgIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHM6IHVzZU90aGVyc0Nvbm5lY3Rpb25JZHNTdXNwZW5zZSxcbiAgICAgIHVzZU90aGVyOiB1c2VPdGhlclN1c3BlbnNlLFxuICAgICAgdXNlTXV0YXRpb24sXG4gICAgICB1c2VUaHJlYWRzOiB1c2VUaHJlYWRzU3VzcGVuc2UsXG4gICAgICB1c2VDcmVhdGVUaHJlYWQsXG4gICAgICB1c2VFZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgICB1c2VDcmVhdGVDb21tZW50LFxuICAgICAgdXNlRWRpdENvbW1lbnQsXG4gICAgICB1c2VEZWxldGVDb21tZW50LFxuICAgICAgdXNlQWRkUmVhY3Rpb24sXG4gICAgICB1c2VSZW1vdmVSZWFjdGlvbixcbiAgICAgIHVzZU1hcmtUaHJlYWRBc1JlYWQsXG4gICAgICB1c2VUaHJlYWRTdWJzY3JpcHRpb24sXG4gICAgICB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3M6IHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc1N1c3BlbnNlLFxuICAgICAgdXNlVXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgLi4uc2hhcmVkLnN1c3BlbnNlXG4gICAgfSxcbiAgICBba0ludGVybmFsXToge1xuICAgICAgdXNlQ3VycmVudFVzZXJJZCxcbiAgICAgIGhhc1Jlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnM6IHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMgIT09IHZvaWQgMCxcbiAgICAgIHVzZU1lbnRpb25TdWdnZXN0aW9uc1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShidW5kbGUsIGtJbnRlcm5hbCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXJJZChyb29tKSB7XG4gIGNvbnN0IHNlbGYgPSByb29tLmdldFNlbGYoKTtcbiAgaWYgKHNlbGYgPT09IG51bGwgfHwgc2VsZi5pZCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIFwiYW5vbnltb3VzXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNlbGYuaWQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUFwaUVycm9yKGVycikge1xuICBjb25zdCBtZXNzYWdlID0gYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzICR7ZXJyLnN0YXR1c306ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgaWYgKGVyci5kZXRhaWxzPy5lcnJvciA9PT0gXCJGT1JCSURERU5cIikge1xuICAgIGNvbnN0IGRldGFpbGVkTWVzc2FnZSA9IFttZXNzYWdlLCBlcnIuZGV0YWlscy5zdWdnZXN0aW9uLCBlcnIuZGV0YWlscy5kb2NzXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtcbiAgICBjb25zb2xlMi5lcnJvcihkZXRhaWxlZE1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVF1ZXJ5S2V5KHJvb21JZCwgb3B0aW9ucykge1xuICByZXR1cm4gYCR7cm9vbUlkfS0ke3N0cmluZ2lmeShvcHRpb25zID8/IHt9KX1gO1xufVxuXG4vLyBzcmMvc2hhcmVkLnRzXG5mdW5jdGlvbiB1c2VTaGFyZWRDb250ZXh0QnVuZGxlKCkge1xuICBjb25zdCByb29tQ29udGV4dEJ1bmRsZSA9IHVzZUNvbnRleHQyKENvbnRleHRCdW5kbGUpO1xuICBjb25zdCBsaXZlYmxvY2tzQ29udGV4dEJ1bmRsZSA9IHVzZUNvbnRleHQyKENvbnRleHRCdW5kbGUyKTtcbiAgaWYgKHJvb21Db250ZXh0QnVuZGxlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHJvb21Db250ZXh0QnVuZGxlO1xuICB9IGVsc2UgaWYgKGxpdmVibG9ja3NDb250ZXh0QnVuZGxlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGxpdmVibG9ja3NDb250ZXh0QnVuZGxlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiTGl2ZWJsb2Nrc1Byb3ZpZGVyIG9yIFJvb21Qcm92aWRlciBhcmUgbWlzc2luZyBmcm9tIHRoZSBSZWFjdCB0cmVlLlwiXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU2hhcmVkQ29udGV4dChjbGllbnQpIHtcbiAgY29uc3QgdXNlcnNTdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwyXS51c2Vyc1N0b3JlO1xuICBjb25zdCByb29tc0luZm9TdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwyXS5yb29tc0luZm9TdG9yZTtcbiAgZnVuY3Rpb24gdXNlVXNlcih1c2VySWQpIHtcbiAgICBjb25zdCBnZXRVc2VyU3RhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgICAoKSA9PiB1c2Vyc1N0b3JlLmdldFN0YXRlKHVzZXJJZCksXG4gICAgICBbdXNlcklkXVxuICAgICk7XG4gICAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgICB2b2lkIHVzZXJzU3RvcmUuZ2V0KHVzZXJJZCk7XG4gICAgfSwgW3VzZXJJZF0pO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUyKFxuICAgICAgdXNlcnNTdG9yZS5zdWJzY3JpYmUsXG4gICAgICBnZXRVc2VyU3RhdGUsXG4gICAgICBnZXRVc2VyU3RhdGVcbiAgICApO1xuICAgIHJldHVybiBzdGF0ZSA/IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgdXNlcjogc3RhdGUuZGF0YVxuICAgIH0gOiB7IGlzTG9hZGluZzogdHJ1ZSB9O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVVzZXJTdXNwZW5zZSh1c2VySWQpIHtcbiAgICBjb25zdCBnZXRVc2VyU3RhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgICAoKSA9PiB1c2Vyc1N0b3JlLmdldFN0YXRlKHVzZXJJZCksXG4gICAgICBbdXNlcklkXVxuICAgICk7XG4gICAgY29uc3QgdXNlclN0YXRlID0gZ2V0VXNlclN0YXRlKCk7XG4gICAgaWYgKCF1c2VyU3RhdGUgfHwgdXNlclN0YXRlLmlzTG9hZGluZykge1xuICAgICAgdGhyb3cgdXNlcnNTdG9yZS5nZXQodXNlcklkKTtcbiAgICB9XG4gICAgaWYgKHVzZXJTdGF0ZS5lcnJvcikge1xuICAgICAgdGhyb3cgdXNlclN0YXRlLmVycm9yO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlMihcbiAgICAgIHVzZXJzU3RvcmUuc3Vic2NyaWJlLFxuICAgICAgZ2V0VXNlclN0YXRlLFxuICAgICAgZ2V0VXNlclN0YXRlXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICB1c2VyOiBzdGF0ZT8uZGF0YVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdXNlUm9vbUluZm8ocm9vbUlkKSB7XG4gICAgY29uc3QgZ2V0Um9vbUluZm9TdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAgICgpID0+IHJvb21zSW5mb1N0b3JlLmdldFN0YXRlKHJvb21JZCksXG4gICAgICBbcm9vbUlkXVxuICAgICk7XG4gICAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgICB2b2lkIHJvb21zSW5mb1N0b3JlLmdldChyb29tSWQpO1xuICAgIH0sIFtyb29tSWRdKTtcbiAgICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlMihcbiAgICAgIHJvb21zSW5mb1N0b3JlLnN1YnNjcmliZSxcbiAgICAgIGdldFJvb21JbmZvU3RhdGUsXG4gICAgICBnZXRSb29tSW5mb1N0YXRlXG4gICAgKTtcbiAgICByZXR1cm4gc3RhdGUgPyB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGluZm86IHN0YXRlLmRhdGFcbiAgICB9IDogeyBpc0xvYWRpbmc6IHRydWUgfTtcbiAgfVxuICBmdW5jdGlvbiB1c2VSb29tSW5mb1N1c3BlbnNlKHJvb21JZCkge1xuICAgIGNvbnN0IGdldFJvb21JbmZvU3RhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgICAoKSA9PiByb29tc0luZm9TdG9yZS5nZXRTdGF0ZShyb29tSWQpLFxuICAgICAgW3Jvb21JZF1cbiAgICApO1xuICAgIGNvbnN0IHJvb21JbmZvU3RhdGUgPSBnZXRSb29tSW5mb1N0YXRlKCk7XG4gICAgaWYgKCFyb29tSW5mb1N0YXRlIHx8IHJvb21JbmZvU3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgICB0aHJvdyByb29tc0luZm9TdG9yZS5nZXQocm9vbUlkKTtcbiAgICB9XG4gICAgaWYgKHJvb21JbmZvU3RhdGUuZXJyb3IpIHtcbiAgICAgIHRocm93IHJvb21JbmZvU3RhdGUuZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUyKFxuICAgICAgcm9vbXNJbmZvU3RvcmUuc3Vic2NyaWJlLFxuICAgICAgZ2V0Um9vbUluZm9TdGF0ZSxcbiAgICAgIGdldFJvb21JbmZvU3RhdGVcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGluZm86IHN0YXRlPy5kYXRhXG4gICAgfTtcbiAgfVxuICBjb25zdCBidW5kbGUgPSB7XG4gICAgdXNlVXNlcixcbiAgICB1c2VSb29tSW5mbyxcbiAgICBzdXNwZW5zZToge1xuICAgICAgdXNlVXNlcjogdXNlVXNlclN1c3BlbnNlLFxuICAgICAgdXNlUm9vbUluZm86IHVzZVJvb21JbmZvU3VzcGVuc2VcbiAgICB9XG4gIH07XG4gIHJldHVybiBidW5kbGU7XG59XG5cbi8vIHNyYy9saXZlYmxvY2tzLnRzeFxudmFyIENvbnRleHRCdW5kbGUyID0gY3JlYXRlQ29udGV4dDIobnVsbCk7XG5mdW5jdGlvbiB1c2VMaXZlYmxvY2tzQ29udGV4dEJ1bmRsZSgpIHtcbiAgY29uc3QgYnVuZGxlID0gdXNlQ29udGV4dDMoQ29udGV4dEJ1bmRsZTIpO1xuICBpZiAoYnVuZGxlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTGl2ZWJsb2Nrc1Byb3ZpZGVyIGlzIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIik7XG4gIH1cbiAgcmV0dXJuIGJ1bmRsZTtcbn1cbnZhciBQT0xMSU5HX0lOVEVSVkFMMiA9IDYwICogMWUzO1xudmFyIElOQk9YX05PVElGSUNBVElPTlNfUVVFUlkgPSBcIklOQk9YX05PVElGSUNBVElPTlNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUxpdmVibG9ja3NDb250ZXh0KGNsaWVudCkge1xuICBjb25zdCBzaGFyZWQgPSBjcmVhdGVTaGFyZWRDb250ZXh0KGNsaWVudCk7XG4gIGNvbnN0IHN0b3JlID0gY2xpZW50W2tJbnRlcm5hbDNdLmNhY2hlU3RvcmU7XG4gIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSBjbGllbnRba0ludGVybmFsM10ubm90aWZpY2F0aW9ucztcbiAgZnVuY3Rpb24gTGl2ZWJsb2Nrc1Byb3ZpZGVyKHByb3BzKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChcbiAgICAgIENvbnRleHRCdW5kbGUyLlByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICB2YWx1ZTogYnVuZGxlXG4gICAgICB9LFxuICAgICAgcHJvcHMuY2hpbGRyZW5cbiAgICApO1xuICB9XG4gIGxldCBmZXRjaEluYm94Tm90aWZpY2F0aW9uc1JlcXVlc3QgPSBudWxsO1xuICBsZXQgaW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMgPSAwO1xuICBsZXQgbGFzdFJlcXVlc3RlZEF0O1xuICBjb25zdCBwb2xsZXIgPSBtYWtlUG9sbGVyMihyZWZyZXNoVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnMpO1xuICBmdW5jdGlvbiByZWZyZXNoVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnMoKSB7XG4gICAgcmV0dXJuIG5vdGlmaWNhdGlvbnMuZ2V0SW5ib3hOb3RpZmljYXRpb25zKHsgc2luY2U6IGxhc3RSZXF1ZXN0ZWRBdCB9KS50aGVuKFxuICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICBsYXN0UmVxdWVzdGVkQXQgPSByZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdDtcbiAgICAgICAgc3RvcmUudXBkYXRlVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnMoXG4gICAgICAgICAgcmVzdWx0LnRocmVhZHMsXG4gICAgICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICByZXN1bHQuZGVsZXRlZFRocmVhZHMsXG4gICAgICAgICAgcmVzdWx0LmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgSU5CT1hfTk9USUZJQ0FUSU9OU19RVUVSWVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgICgpID0+IHtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGluY3JlbWVudEluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzKCkge1xuICAgIGluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzKys7XG4gICAgcG9sbGVyLnN0YXJ0KFBPTExJTkdfSU5URVJWQUwyKTtcbiAgfVxuICBmdW5jdGlvbiBkZWNyZW1lbnRJbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycygpIHtcbiAgICBpZiAoaW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMgPD0gMCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgSW50ZXJuYWwgdW5leHBlY3RlZCBiZWhhdmlvci4gQ2Fubm90IGRlY3JlYXNlIHN1YnNjcmliZXIgY291bnQgZm9yIHF1ZXJ5IFwiJHtJTkJPWF9OT1RJRklDQVRJT05TX1FVRVJZfVwiYFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMtLTtcbiAgICBpZiAoaW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMgPD0gMCkge1xuICAgICAgcG9sbGVyLnN0b3AoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnMoeyByZXRyeUNvdW50IH0gPSB7IHJldHJ5Q291bnQ6IDAgfSkge1xuICAgIGlmIChmZXRjaEluYm94Tm90aWZpY2F0aW9uc1JlcXVlc3QgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmZXRjaEluYm94Tm90aWZpY2F0aW9uc1JlcXVlc3Q7XG4gICAgfVxuICAgIHN0b3JlLnNldFF1ZXJ5U3RhdGUoSU5CT1hfTk9USUZJQ0FUSU9OU19RVUVSWSwge1xuICAgICAgaXNMb2FkaW5nOiB0cnVlXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGZldGNoSW5ib3hOb3RpZmljYXRpb25zUmVxdWVzdCA9IG5vdGlmaWNhdGlvbnMuZ2V0SW5ib3hOb3RpZmljYXRpb25zKCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaEluYm94Tm90aWZpY2F0aW9uc1JlcXVlc3Q7XG4gICAgICBzdG9yZS51cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyhcbiAgICAgICAgcmVzdWx0LnRocmVhZHMsXG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgIHJlc3VsdC5kZWxldGVkVGhyZWFkcyxcbiAgICAgICAgcmVzdWx0LmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgIElOQk9YX05PVElGSUNBVElPTlNfUVVFUllcbiAgICAgICk7XG4gICAgICBpZiAobGFzdFJlcXVlc3RlZEF0ID09PSB2b2lkIDAgfHwgbGFzdFJlcXVlc3RlZEF0ID4gcmVzdWx0Lm1ldGEucmVxdWVzdGVkQXQpIHtcbiAgICAgICAgbGFzdFJlcXVlc3RlZEF0ID0gcmVzdWx0Lm1ldGEucmVxdWVzdGVkQXQ7XG4gICAgICB9XG4gICAgICBwb2xsZXIuc3RhcnQoUE9MTElOR19JTlRFUlZBTDIpO1xuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBmZXRjaEluYm94Tm90aWZpY2F0aW9uc1JlcXVlc3QgPSBudWxsO1xuICAgICAgcmV0cnlFcnJvcigoKSA9PiB7XG4gICAgICAgIHZvaWQgZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnMoe1xuICAgICAgICAgIHJldHJ5Q291bnQ6IHJldHJ5Q291bnQgKyAxXG4gICAgICAgIH0pO1xuICAgICAgfSwgcmV0cnlDb3VudCk7XG4gICAgICBzdG9yZS5zZXRRdWVyeVN0YXRlKElOQk9YX05PVElGSUNBVElPTlNfUVVFUlksIHtcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVyXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9uc1NlbGVjdG9yQ2FsbGJhY2soc3RhdGUpIHtcbiAgICBjb25zdCBxdWVyeSA9IHN0YXRlLnF1ZXJpZXNbSU5CT1hfTk9USUZJQ0FUSU9OU19RVUVSWV07XG4gICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDAgfHwgcXVlcnkuaXNMb2FkaW5nKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0xvYWRpbmc6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChxdWVyeS5lcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogcXVlcnkuZXJyb3IsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHNlbGVjdGVkSW5ib3hOb3RpZmljYXRpb25zKHN0YXRlKSxcbiAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9ucygpIHtcbiAgICB1c2VFZmZlY3Q1KCgpID0+IHtcbiAgICAgIHZvaWQgZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnMoKTtcbiAgICAgIGluY3JlbWVudEluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzKCk7XG4gICAgICByZXR1cm4gKCkgPT4gZGVjcmVtZW50SW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMoKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgcmVzdWx0ID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgdXNlSW5ib3hOb3RpZmljYXRpb25zU2VsZWN0b3JDYWxsYmFja1xuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZVNlbGVjdG9yKHN0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczogc2VsZWN0ZWRJbmJveE5vdGlmaWNhdGlvbnMoc3RhdGUpLFxuICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2UoKSB7XG4gICAgY29uc3QgcXVlcnkgPSBzdG9yZS5nZXQoKS5xdWVyaWVzW0lOQk9YX05PVElGSUNBVElPTlNfUVVFUlldO1xuICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwIHx8IHF1ZXJ5LmlzTG9hZGluZykge1xuICAgICAgdGhyb3cgZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnMoKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmVycm9yICE9PSB2b2lkIDApIHtcbiAgICAgIHRocm93IHF1ZXJ5LmVycm9yO1xuICAgIH1cbiAgICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGluY3JlbWVudEluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzKCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkZWNyZW1lbnRJbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycygpO1xuICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlU2VsZWN0b3JcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50KHN0YXRlKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vdGlmaWNhdGlvbiBvZiBzZWxlY3RlZEluYm94Tm90aWZpY2F0aW9ucyhzdGF0ZSkpIHtcbiAgICAgIGlmIChub3RpZmljYXRpb24ucmVhZEF0ID09PSBudWxsIHx8IG5vdGlmaWNhdGlvbi5yZWFkQXQgPCBub3RpZmljYXRpb24ubm90aWZpZWRBdCkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTZWxlY3RvcihzdGF0ZSkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gc3RhdGUucXVlcmllc1tJTkJPWF9OT1RJRklDQVRJT05TX1FVRVJZXTtcbiAgICBpZiAocXVlcnkgPT09IHZvaWQgMCB8fCBxdWVyeS5pc0xvYWRpbmcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzTG9hZGluZzogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmVycm9yICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBxdWVyeS5lcnJvcixcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBjb3VudDogc2VsZWN0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoc3RhdGUpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCgpIHtcbiAgICB1c2VFZmZlY3Q1KCgpID0+IHtcbiAgICAgIHZvaWQgZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnMoKTtcbiAgICAgIGluY3JlbWVudEluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzKCk7XG4gICAgICByZXR1cm4gKCkgPT4gZGVjcmVtZW50SW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMoKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U2VsZWN0b3JcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2VTZWxlY3RvcihzdGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgY291bnQ6IHNlbGVjdFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50KHN0YXRlKVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZSgpIHtcbiAgICBjb25zdCBxdWVyeSA9IHN0b3JlLmdldCgpLnF1ZXJpZXNbSU5CT1hfTk9USUZJQ0FUSU9OU19RVUVSWV07XG4gICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDAgfHwgcXVlcnkuaXNMb2FkaW5nKSB7XG4gICAgICB0aHJvdyBmZXRjaEluYm94Tm90aWZpY2F0aW9ucygpO1xuICAgIH1cbiAgICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGluY3JlbWVudEluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzKCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkZWNyZW1lbnRJbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycygpO1xuICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2VTZWxlY3RvclxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKCkge1xuICAgIHJldHVybiB1c2VDYWxsYmFjazMoKGluYm94Tm90aWZpY2F0aW9uSWQpID0+IHtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDMoKTtcbiAgICAgIGNvbnN0IHJlYWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcIm1hcmstaW5ib3gtbm90aWZpY2F0aW9uLWFzLXJlYWRcIixcbiAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZCxcbiAgICAgICAgcmVhZEF0XG4gICAgICB9KTtcbiAgICAgIG5vdGlmaWNhdGlvbnMubWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ05vdGlmaWNhdGlvbiA9IHN0YXRlLmluYm94Tm90aWZpY2F0aW9uc1tpbmJveE5vdGlmaWNhdGlvbklkXTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ05vdGlmaWNhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uczoge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLmluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICAgICAgICBbaW5ib3hOb3RpZmljYXRpb25JZF06IHtcbiAgICAgICAgICAgICAgICAgIC4uLmV4aXN0aW5nTm90aWZpY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgcmVhZEF0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCgpIHtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2szKCgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDMoKTtcbiAgICAgIGNvbnN0IHJlYWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcIm1hcmstaW5ib3gtbm90aWZpY2F0aW9ucy1hcy1yZWFkXCIsXG4gICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgIHJlYWRBdFxuICAgICAgfSk7XG4gICAgICBub3RpZmljYXRpb25zLm1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgIEFycmF5LmZyb20oT2JqZWN0LmVudHJpZXMoc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zKSkubWFwKFxuICAgICAgICAgICAgICAgIChbaWQsIGluYm94Tm90aWZpY2F0aW9uXSkgPT4gW1xuICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICB7IC4uLmluYm94Tm90aWZpY2F0aW9uLCByZWFkQXQgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSwgW10pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVRocmVhZEZyb21DYWNoZSh0aHJlYWRJZCkge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gdXNlQ2FsbGJhY2szKFxuICAgICAgKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW50ZXJuYWwgZXJyb3I6IHRocmVhZCB3aXRoIGlkIFwiJHt0aHJlYWRJZH1cIiBub3QgZm91bmQgaW4gY2FjaGVgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhyZWFkO1xuICAgICAgfSxcbiAgICAgIFt0aHJlYWRJZF1cbiAgICApO1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzZWxlY3RvclxuICAgICk7XG4gIH1cbiAgY29uc3QgY3VycmVudFVzZXJJZFN0b3JlID0gY2xpZW50W2tJbnRlcm5hbDNdLmN1cnJlbnRVc2VySWRTdG9yZTtcbiAgZnVuY3Rpb24gdXNlQ3VycmVudFVzZXJJZCgpIHtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUzKFxuICAgICAgY3VycmVudFVzZXJJZFN0b3JlLnN1YnNjcmliZSxcbiAgICAgIGN1cnJlbnRVc2VySWRTdG9yZS5nZXQsXG4gICAgICBjdXJyZW50VXNlcklkU3RvcmUuZ2V0XG4gICAgKTtcbiAgfVxuICBjb25zdCBidW5kbGUgPSB7XG4gICAgTGl2ZWJsb2Nrc1Byb3ZpZGVyLFxuICAgIHVzZUluYm94Tm90aWZpY2F0aW9ucyxcbiAgICB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gICAgdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICAuLi5zaGFyZWQsXG4gICAgc3VzcGVuc2U6IHtcbiAgICAgIExpdmVibG9ja3NQcm92aWRlcixcbiAgICAgIHVzZUluYm94Tm90aWZpY2F0aW9uczogdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2UsXG4gICAgICB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudDogdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZSxcbiAgICAgIHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgICAgIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQsXG4gICAgICAuLi5zaGFyZWQuc3VzcGVuc2VcbiAgICB9LFxuICAgIFtrSW50ZXJuYWwzXToge1xuICAgICAgdXNlVGhyZWFkRnJvbUNhY2hlLFxuICAgICAgdXNlQ3VycmVudFVzZXJJZFxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShidW5kbGUsIGtJbnRlcm5hbDMsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBzaGFsbG93IGFzIHNoYWxsb3cyIH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NsaWVudFwiO1xuZGV0ZWN0RHVwZXMoUEtHX05BTUUsIFBLR19WRVJTSU9OLCBQS0dfRk9STUFUKTtcbmV4cG9ydCB7XG4gIENsaWVudFNpZGVTdXNwZW5zZSxcbiAgY3JlYXRlTGl2ZWJsb2Nrc0NvbnRleHQsXG4gIGNyZWF0ZVJvb21Db250ZXh0LFxuICBzaGFsbG93MiBhcyBzaGFsbG93LFxuICB1c2VMaXZlYmxvY2tzQ29udGV4dEJ1bmRsZSxcbiAgdXNlUm9vbUNvbnRleHRCdW5kbGUsXG4gIHVzZVNoYXJlZENvbnRleHRCdW5kbGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbImRldGVjdER1cGVzIiwiUEtHX05BTUUiLCJQS0dfVkVSU0lPTiIsIlBLR19GT1JNQVQiLCJSZWFjdCIsIkNsaWVudFNpZGVTdXNwZW5zZSIsInByb3BzIiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImNyZWF0ZUVsZW1lbnQiLCJTdXNwZW5zZSIsImZhbGxiYWNrIiwiY2hpbGRyZW4iLCJrSW50ZXJuYWwiLCJrSW50ZXJuYWwzIiwibWFrZVBvbGxlciIsIm1ha2VQb2xsZXIyIiwibmFub2lkIiwibmFub2lkMyIsIlJlYWN0MyIsImNyZWF0ZUNvbnRleHQiLCJjcmVhdGVDb250ZXh0MiIsInVzZUNhbGxiYWNrIiwidXNlQ2FsbGJhY2szIiwidXNlQ29udGV4dCIsInVzZUNvbnRleHQzIiwidXNlRWZmZWN0NSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidXNlU3luY0V4dGVybmFsU3RvcmUzIiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIiLCJhcHBseU9wdGltaXN0aWNVcGRhdGVzIiwic2VsZWN0ZWRJbmJveE5vdGlmaWNhdGlvbnMiLCJzdGF0ZSIsInJlc3VsdCIsIk9iamVjdCIsInZhbHVlcyIsImluYm94Tm90aWZpY2F0aW9ucyIsInNvcnQiLCJhIiwiYiIsIm5vdGlmaWVkQXQiLCJnZXRUaW1lIiwiTUFYX0VSUk9SX1JFVFJZX0NPVU5UIiwiRVJST1JfUkVUUllfSU5URVJWQUwiLCJyZXRyeUVycm9yIiwiYWN0aW9uIiwicmV0cnlDb3VudCIsInRpbWVvdXQiLCJNYXRoIiwicG93Iiwic2V0VGltZW91dCIsImtJbnRlcm5hbDIiLCJ1c2VDYWxsYmFjazIiLCJ1c2VDb250ZXh0MiIsInVzZUVmZmVjdDQiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZTIiLCJzaGFsbG93IiwiYWRkUmVhY3Rpb24iLCJDb21tZW50c0FwaUVycm9yIiwiY29uc29sZSIsImNvbnNvbGUyIiwiZGVsZXRlQ29tbWVudCIsImRlcHJlY2F0ZUlmIiwiZXJyb3JJZiIsImlzTGl2ZU5vZGUiLCJtYWtlRXZlbnRTb3VyY2UiLCJOb3RpZmljYXRpb25zQXBpRXJyb3IiLCJyZW1vdmVSZWFjdGlvbiIsIlNlcnZlck1zZ0NvZGUiLCJzdHJpbmdpZnkiLCJ1cHNlcnRDb21tZW50IiwibmFub2lkMiIsIlJlYWN0MiIsIkNyZWF0ZVRocmVhZEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNhdXNlIiwiY29udGV4dCIsIm5hbWUiLCJFZGl0VGhyZWFkTWV0YWRhdGFFcnJvciIsIkNyZWF0ZUNvbW1lbnRFcnJvciIsIkVkaXRDb21tZW50RXJyb3IiLCJEZWxldGVDb21tZW50RXJyb3IiLCJBZGRSZWFjdGlvbkVycm9yIiwiUmVtb3ZlUmVhY3Rpb25FcnJvciIsIk1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZEVycm9yIiwiVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NFcnJvciIsIlRIUkVBRF9JRF9QUkVGSVgiLCJDT01NRU5UX0lEX1BSRUZJWCIsImNyZWF0ZU9wdGltaXN0aWNJZCIsInByZWZpeCIsImNyZWF0ZVRocmVhZElkIiwiY3JlYXRlQ29tbWVudElkIiwiYXBwbHlPcHRpbWlzdGljVXBkYXRlczIiLCJubiIsInNlbGVjdE5vdGlmaWNhdGlvblNldHRpbmdzIiwicm9vbUlkIiwibm90aWZpY2F0aW9uU2V0dGluZ3MiLCJhcHBseU9wdGltaXN0aWNVcGRhdGVzMyIsInNlbGVjdGVkVGhyZWFkcyIsIm9wdGlvbnMiLCJ0aHJlYWRzIiwiZmlsdGVyIiwidGhyZWFkIiwiZGVsZXRlZEF0IiwicXVlcnkiLCJrZXkiLCJtZXRhZGF0YSIsImNyZWF0ZWRBdCIsInVzZVN0YXRlMiIsInVzZUluaXRpYWwiLCJ2YWx1ZSIsInVzZUVmZmVjdDIiLCJ1c2VSZWYiLCJ1c2VMYXRlc3QiLCJyZWYiLCJjdXJyZW50IiwidXNlUmVkdWNlciIsInVzZVJlcmVuZGVyIiwidXBkYXRlIiwieCIsIm5vb3AiLCJpZGVudGl0eSIsIm1pc3NpbmdfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJyZWFjdFZlcnNpb24iLCJKU09OIiwic3VwZXJmbHVvdXNfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJzIiwiZ3MiLCJnc3MiLCJTVEFCTEVfRU1QVFlfTElTVCIsImZyZWV6ZSIsIlBPTExJTkdfSU5URVJWQUwiLCJNRU5USU9OX1NVR0dFU1RJT05TX0RFQk9VTkNFIiwiYWx3YXlzRW1wdHlMaXN0IiwiYWx3YXlzTnVsbCIsIm1ha2VNdXRhdGlvbkNvbnRleHQiLCJyb29tIiwiZXJybXNnIiwic3RvcmFnZSIsIm11dGFibGVSb290IiwiZ2V0U3RvcmFnZVNuYXBzaG90Iiwic2VsZiIsImdldFNlbGYiLCJvdGhlcnMiLCJnZXRPdGhlcnMiLCJzZXRNeVByZXNlbmNlIiwidXBkYXRlUHJlc2VuY2UiLCJDb250ZXh0QnVuZGxlIiwidXNlUm9vbUNvbnRleHRCdW5kbGUiLCJidW5kbGUiLCJjcmVhdGVSb29tQ29udGV4dCIsImNsaWVudCIsInJlc29sdmVVc2VycyIsInJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMiLCJSb29tQ29udGV4dCIsImNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZSIsInNoYXJlZCIsImNyZWF0ZVNoYXJlZENvbnRleHQiLCJSb29tUHJvdmlkZXJPdXRlciIsImNhY2hlIiwiTWFwIiwic3RhYmxlRW50ZXJSb29tIiwib3B0aW9uczIiLCJjYWNoZWQiLCJnZXQiLCJydiIsImVudGVyUm9vbSIsIm9yaWdMZWF2ZSIsImxlYXZlIiwiZGVsZXRlIiwic2V0IiwiUm9vbVByb3ZpZGVySW5uZXIiLCJpZCIsInByb2Nlc3MiLCJtYWpvclJlYWN0VmVyc2lvbiIsInBhcnNlSW50IiwidmVyc2lvbiIsIm9sZFJlYWN0VmVyc2lvbiIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwiZnJvemVuUHJvcHMiLCJpbml0aWFsUHJlc2VuY2UiLCJpbml0aWFsU3RvcmFnZSIsImF1dG9Db25uZWN0Iiwic2hvdWxkSW5pdGlhbGx5Q29ubmVjdCIsInNldFJvb21MZWF2ZVBhaXIiLCJoYW5kbGVDb21tZW50RXZlbnQiLCJtZXNzYWdlIiwiaW5mbyIsImNvbW1lbnRzIiwiZ2V0VGhyZWFkIiwidGhyZWFkSWQiLCJzdG9yZSIsImRlbGV0ZVRocmVhZCIsImluYm94Tm90aWZpY2F0aW9uIiwiZXhpc3RpbmdUaHJlYWQiLCJ0eXBlIiwiQ09NTUVOVF9FRElURUQiLCJUSFJFQURfTUVUQURBVEFfVVBEQVRFRCIsIkNPTU1FTlRfUkVBQ1RJT05fQURERUQiLCJDT01NRU5UX1JFQUNUSU9OX1JFTU9WRUQiLCJDT01NRU5UX0RFTEVURUQiLCJ1cGRhdGVUaHJlYWRBbmROb3RpZmljYXRpb24iLCJDT01NRU5UX0NSRUFURUQiLCJldmVudHMiLCJzdWJzY3JpYmUiLCJnZXRUaHJlYWRzVXBkYXRlcyIsImhhbmRsZUlzT25saW5lIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwYWlyIiwicm9vbTIiLCJjb25uZWN0IiwiUHJvdmlkZXIiLCJjb25uZWN0aW9uSWRTZWxlY3RvciIsIm1hcCIsInVzZXIiLCJjb25uZWN0aW9uSWQiLCJ1c2VSb29tIiwidXNlU3RhdHVzIiwic3RhdHVzIiwiZ2V0U25hcHNob3QiLCJnZXRTdGF0dXMiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsInVzZU15UHJlc2VuY2UiLCJteVByZXNlbmNlIiwiZ2V0UHJlc2VuY2UiLCJwcmVzZW5jZSIsInNldFByZXNlbmNlIiwidXNlVXBkYXRlTXlQcmVzZW5jZSIsInVzZU90aGVycyIsInNlbGVjdG9yIiwiaXNFcXVhbCIsInVzZU90aGVyc0Nvbm5lY3Rpb25JZHMiLCJ1c2VPdGhlcnNNYXBwZWQiLCJpdGVtU2VsZWN0b3IiLCJpdGVtSXNFcXVhbCIsIndyYXBwZWRTZWxlY3RvciIsIm90aGVyIiwid3JhcHBlZElzRXF1YWwiLCJlcSIsImlzIiwibGVuZ3RoIiwiZXZlcnkiLCJhdHVwbGUiLCJpbmRleCIsImJ0dXBsZSIsIk5PVF9GT1VORCIsIlN5bWJvbCIsInVzZU90aGVyIiwib3RoZXIyIiwiZmluZCIsIm90aGVyMyIsInByZXYiLCJjdXJyIiwidXNlQnJvYWRjYXN0RXZlbnQiLCJldmVudCIsInNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5IiwiYnJvYWRjYXN0RXZlbnQiLCJ1c2VPdGhlcnNMaXN0ZW5lciIsImNhbGxiYWNrIiwic2F2ZWRDYWxsYmFjayIsInVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIiLCJsb3N0Q29ubmVjdGlvbiIsInVzZUVycm9yTGlzdGVuZXIiLCJlcnJvciIsImUiLCJ1c2VFdmVudExpc3RlbmVyIiwibGlzdGVuZXIiLCJldmVudERhdGEiLCJjdXN0b21FdmVudCIsInVzZVNlbGYiLCJtYXliZVNlbGVjdG9yIiwibWUiLCJ1c2VNdXRhYmxlU3RvcmFnZVJvb3QiLCJzdG9yYWdlRGlkTG9hZCIsInN1YnNjcmliZU9uY2UiLCJ1c2VTdG9yYWdlUm9vdCIsInVzZUhpc3RvcnkiLCJoaXN0b3J5IiwidXNlVW5kbyIsInVuZG8iLCJ1c2VSZWRvIiwicmVkbyIsInVzZUNhblVuZG8iLCJjYW5VbmRvIiwidXNlQ2FuUmVkbyIsImNhblJlZG8iLCJ1c2VCYXRjaCIsImJhdGNoIiwidXNlTGVnYWN5S2V5Iiwicm9vdE9yTnVsbCIsInJlcmVuZGVyIiwicm9vdCIsInVuc3ViQ3VyciIsInN1YnNjcmliZVRvQ3VyciIsIm9uUm9vdENoYW5nZSIsIm5ld1ZhbHVlIiwidW5zdWJzY3JpYmVSb290IiwidXNlU3RvcmFnZSIsInJvb3RPck51bGwyIiwib25TdG9yZUNoYW5nZSIsImlzRGVlcCIsImltbSIsInRvSW1tdXRhYmxlIiwiZW5zdXJlTm90U2VydmVyU2lkZSIsInVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VMb2FkZWQiLCJQcm9taXNlIiwicmVzIiwidXNlU3VzcGVuZFVudGlsUHJlc2VuY2VMb2FkZWQiLCJ1c2VNdXRhdGlvbiIsImRlcHMiLCJ1c2VNZW1vIiwiYXJncyIsInVzZVN0b3JhZ2VTdXNwZW5zZSIsInVzZVNlbGZTdXNwZW5zZSIsInVzZU90aGVyc1N1c3BlbnNlIiwidXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlIiwidXNlT3RoZXJzTWFwcGVkU3VzcGVuc2UiLCJ1c2VPdGhlclN1c3BlbnNlIiwidXNlTGVnYWN5S2V5U3VzcGVuc2UiLCJjYWNoZVN0b3JlIiwib25NdXRhdGlvbkZhaWx1cmUiLCJpbm5lckVycm9yIiwib3B0aW1pc3RpY1VwZGF0ZUlkIiwiY3JlYXRlUHVibGljRXJyb3IiLCJvcHRpbWlzdGljVXBkYXRlcyIsImhhbmRsZUFwaUVycm9yIiwibm90aWZ5Iiwic3Vic2NyaWJlcnNCeVF1ZXJ5IiwicmVxdWVzdHNCeVF1ZXJ5IiwicG9sbGVyIiwicmVmcmVzaFRocmVhZHNBbmROb3RpZmljYXRpb25zIiwicmVxdWVzdHMiLCJnZXRSb29tSWRzIiwiZ2V0Um9vbSIsInB1c2giLCJhbGxTZXR0bGVkIiwiaW5jcmVtZW50UXVlcnlTdWJzY3JpYmVycyIsInF1ZXJ5S2V5Iiwic3Vic2NyaWJlcnMiLCJzdGFydCIsImRlY3JlbWVudFF1ZXJ5U3Vic2NyaWJlcnMiLCJ3YXJuIiwidG90YWxTdWJzY3JpYmVycyIsInN1YnNjcmliZXJzMiIsInN0b3AiLCJnZXRUaHJlYWRzQW5kSW5ib3hOb3RpZmljYXRpb25zIiwiZXhpc3RpbmdSZXF1ZXN0IiwicmVxdWVzdCIsImdldFRocmVhZHMiLCJzZXRRdWVyeVN0YXRlIiwiaXNMb2FkaW5nIiwidXBkYXRlVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnMiLCJkZWxldGVkVGhyZWFkcyIsImRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMiLCJsYXN0UmVxdWVzdGVkQXQiLCJsYXN0UmVxdWVzdGVkQXRCeVJvb20iLCJtZXRhIiwicmVxdWVzdGVkQXQiLCJlcnIiLCJERUZBVUxUX0RFRFVQSU5HX0lOVEVSVkFMIiwicmVxdWVzdFN0YXR1c0J5Um9vbSIsInNpbmNlIiwiaXNGZXRjaGluZ1RocmVhZHNVcGRhdGVzIiwidXBkYXRlcyIsInVzZVRocmVhZHMiLCJnZW5lcmF0ZVF1ZXJ5S2V5IiwicXVlcmllcyIsInVzZVRocmVhZHNTdXNwZW5zZSIsInVzZUNyZWF0ZVRocmVhZCIsImJvZHkiLCJjb21tZW50SWQiLCJEYXRlIiwibmV3Q29tbWVudCIsInVzZXJJZCIsImdldEN1cnJlbnRVc2VySWQiLCJyZWFjdGlvbnMiLCJuZXdUaHJlYWQiLCJ1cGRhdGVkQXQiLCJwdXNoT3B0aW1pc3RpY1VwZGF0ZSIsImNyZWF0ZVRocmVhZCIsInRoZW4iLCJlcnIyIiwidXNlRWRpdFRocmVhZE1ldGFkYXRhIiwiZWRpdFRocmVhZE1ldGFkYXRhIiwibWV0YWRhdGEyIiwidXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzIiwidXNlQWRkUmVhY3Rpb24iLCJlbW9qaSIsInJlYWN0aW9uIiwiYWRkZWRSZWFjdGlvbiIsInVzZVJlbW92ZVJlYWN0aW9uIiwicmVtb3ZlZEF0IiwidXNlQ3JlYXRlQ29tbWVudCIsImNvbW1lbnQiLCJjcmVhdGVDb21tZW50Iiwibm90aWZpY2F0aW9uIiwidXBkYXRlZEluYm94Tm90aWZpY2F0aW9ucyIsInJlYWRBdCIsInVzZUVkaXRDb21tZW50IiwiZWRpdGVkQXQiLCJjb21tZW50MiIsImVkaXRDb21tZW50IiwiZWRpdGVkQ29tbWVudCIsInVzZURlbGV0ZUNvbW1lbnQiLCJtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZSIsInVzZU1lbnRpb25TdWdnZXN0aW9ucyIsInNlYXJjaCIsIm1lbnRpb25TdWdnZXN0aW9ucyIsInNldE1lbnRpb25TdWdnZXN0aW9ucyIsImxhc3RJbnZva2VkQXQiLCJyZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zQXJncyIsInRleHQiLCJtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZUtleSIsImRlYm91bmNlVGltZW91dCIsImlzQ2FuY2VsZWQiLCJnZXRNZW50aW9uU3VnZ2VzdGlvbnMiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIm1lbnRpb25TdWdnZXN0aW9uczIiLCJoYXMiLCJhYnMiLCJjbGVhclRpbWVvdXQiLCJ1c2VUaHJlYWRTdWJzY3JpcHRpb24iLCJpbmJveE5vdGlmaWNhdGlvbjIiLCJ1bnJlYWRTaW5jZSIsInVzZU1hcmtUaHJlYWRBc1JlYWQiLCJpbmJveE5vdGlmaWNhdGlvbklkIiwibm90aWZpY2F0aW9ucyIsIm1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCIsIm1ha2VOb3RpZmljYXRpb25TZXR0aW5nc1F1ZXJ5S2V5IiwiZ2V0SW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyIsImdldFJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyIsInNldHRpbmdzIiwidXBkYXRlUm9vbUluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3MiLCJ1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MiLCJ1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MiLCJ1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MiLCJ1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZSIsInNldHRpbmdzMiIsInVzZUN1cnJlbnRVc2VySWQiLCJSb29tUHJvdmlkZXIiLCJ1c2VMaXN0IiwidXNlTWFwIiwidXNlT2JqZWN0Iiwic3VzcGVuc2UiLCJoYXNSZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZGV0YWlscyIsImRldGFpbGVkTWVzc2FnZSIsInN1Z2dlc3Rpb24iLCJkb2NzIiwiQm9vbGVhbiIsImpvaW4iLCJ1c2VTaGFyZWRDb250ZXh0QnVuZGxlIiwicm9vbUNvbnRleHRCdW5kbGUiLCJsaXZlYmxvY2tzQ29udGV4dEJ1bmRsZSIsIkNvbnRleHRCdW5kbGUyIiwidXNlcnNTdG9yZSIsInJvb21zSW5mb1N0b3JlIiwidXNlVXNlciIsImdldFVzZXJTdGF0ZSIsImdldFN0YXRlIiwiZGF0YSIsInVzZVVzZXJTdXNwZW5zZSIsInVzZXJTdGF0ZSIsInVzZVJvb21JbmZvIiwiZ2V0Um9vbUluZm9TdGF0ZSIsInVzZVJvb21JbmZvU3VzcGVuc2UiLCJyb29tSW5mb1N0YXRlIiwidXNlTGl2ZWJsb2Nrc0NvbnRleHRCdW5kbGUiLCJQT0xMSU5HX0lOVEVSVkFMMiIsIklOQk9YX05PVElGSUNBVElPTlNfUVVFUlkiLCJjcmVhdGVMaXZlYmxvY2tzQ29udGV4dCIsIkxpdmVibG9ja3NQcm92aWRlciIsImZldGNoSW5ib3hOb3RpZmljYXRpb25zUmVxdWVzdCIsImluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzIiwiZ2V0SW5ib3hOb3RpZmljYXRpb25zIiwiaW5jcmVtZW50SW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMiLCJkZWNyZW1lbnRJbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycyIsImZldGNoSW5ib3hOb3RpZmljYXRpb25zIiwiZXIiLCJ1c2VJbmJveE5vdGlmaWNhdGlvbnNTZWxlY3RvckNhbGxiYWNrIiwidXNlSW5ib3hOb3RpZmljYXRpb25zIiwidXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2VTZWxlY3RvciIsInVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlIiwic2VsZWN0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQiLCJjb3VudCIsInVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U2VsZWN0b3IiLCJ1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCIsInVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2VTZWxlY3RvciIsInVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2UiLCJ1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQiLCJleGlzdGluZ05vdGlmaWNhdGlvbiIsInVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQiLCJtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkIiwiZnJvbUVudHJpZXMiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwidXNlVGhyZWFkRnJvbUNhY2hlIiwiY3VycmVudFVzZXJJZFN0b3JlIiwic2hhbGxvdzIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/dist/index.mjs\n");

/***/ })

};
;