/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Ccode-files%5Cfigpro%5Capp%5CRoom.tsx&modules=C%3A%5Ccode-files%5Cfigpro%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.tsx%22%2C%22import%22%3A%22Work_Sans%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-work-sans%22%2C%22weight%22%3A%5B%22400%22%2C%22600%22%2C%22700%22%5D%7D%5D%2C%22variableName%22%3A%22workSans%22%7D&modules=C%3A%5Ccode-files%5Cfigpro%5Capp%5Cglobals.css&server=false!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Ccode-files%5Cfigpro%5Capp%5CRoom.tsx&modules=C%3A%5Ccode-files%5Cfigpro%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.tsx%22%2C%22import%22%3A%22Work_Sans%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-work-sans%22%2C%22weight%22%3A%5B%22400%22%2C%22600%22%2C%22700%22%5D%7D%5D%2C%22variableName%22%3A%22workSans%22%7D&modules=C%3A%5Ccode-files%5Cfigpro%5Capp%5Cglobals.css&server=false! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/Room.tsx */ \"(app-pages-browser)/./app/Room.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Work_Sans\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-work-sans\",\"weight\":[\"400\",\"600\",\"700\"]}],\"variableName\":\"workSans\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\layout.tsx\\\",\\\"import\\\":\\\"Work_Sans\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"],\\\"variable\\\":\\\"--font-work-sans\\\",\\\"weight\\\":[\\\"400\\\",\\\"600\\\",\\\"700\\\"]}],\\\"variableName\\\":\\\"workSans\\\"}\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/globals.css */ \"(app-pages-browser)/./app/globals.css\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1DJTNBJTVDY29kZS1maWxlcyU1Q2ZpZ3BybyU1Q2FwcCU1Q1Jvb20udHN4Jm1vZHVsZXM9QyUzQSU1Q2NvZGUtZmlsZXMlNUNmaWdwcm8lNUNub2RlX21vZHVsZXMlNUNuZXh0JTVDZm9udCU1Q2dvb2dsZSU1Q3RhcmdldC5jc3MlM0YlN0IlMjJwYXRoJTIyJTNBJTIyYXBwJTVDJTVDbGF5b3V0LnRzeCUyMiUyQyUyMmltcG9ydCUyMiUzQSUyMldvcmtfU2FucyUyMiUyQyUyMmFyZ3VtZW50cyUyMiUzQSU1QiU3QiUyMnN1YnNldHMlMjIlM0ElNUIlMjJsYXRpbiUyMiU1RCUyQyUyMnZhcmlhYmxlJTIyJTNBJTIyLS1mb250LXdvcmstc2FucyUyMiUyQyUyMndlaWdodCUyMiUzQSU1QiUyMjQwMCUyMiUyQyUyMjYwMCUyMiUyQyUyMjcwMCUyMiU1RCU3RCU1RCUyQyUyMnZhcmlhYmxlTmFtZSUyMiUzQSUyMndvcmtTYW5zJTIyJTdEJm1vZHVsZXM9QyUzQSU1Q2NvZGUtZmlsZXMlNUNmaWdwcm8lNUNhcHAlNUNnbG9iYWxzLmNzcyZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLHNKQUEwRTtBQUMxRSxza0JBQWtUO0FBQ2xUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/OTZlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXGNvZGUtZmlsZXNcXFxcZmlncHJvXFxcXGFwcFxcXFxSb29tLnRzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcY29kZS1maWxlc1xcXFxmaWdwcm9cXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZm9udFxcXFxnb29nbGVcXFxcdGFyZ2V0LmNzcz97XFxcInBhdGhcXFwiOlxcXCJhcHBcXFxcXFxcXGxheW91dC50c3hcXFwiLFxcXCJpbXBvcnRcXFwiOlxcXCJXb3JrX1NhbnNcXFwiLFxcXCJhcmd1bWVudHNcXFwiOlt7XFxcInN1YnNldHNcXFwiOltcXFwibGF0aW5cXFwiXSxcXFwidmFyaWFibGVcXFwiOlxcXCItLWZvbnQtd29yay1zYW5zXFxcIixcXFwid2VpZ2h0XFxcIjpbXFxcIjQwMFxcXCIsXFxcIjYwMFxcXCIsXFxcIjcwMFxcXCJdfV0sXFxcInZhcmlhYmxlTmFtZVxcXCI6XFxcIndvcmtTYW5zXFxcIn1cIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXGNvZGUtZmlsZXNcXFxcZmlncHJvXFxcXGFwcFxcXFxnbG9iYWxzLmNzc1wiKSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Ccode-files%5Cfigpro%5Capp%5CRoom.tsx&modules=C%3A%5Ccode-files%5Cfigpro%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.tsx%22%2C%22import%22%3A%22Work_Sans%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-work-sans%22%2C%22weight%22%3A%5B%22400%22%2C%22600%22%2C%22700%22%5D%7D%5D%2C%22variableName%22%3A%22workSans%22%7D&modules=C%3A%5Ccode-files%5Cfigpro%5Capp%5Cglobals.css&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/ZDJjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={686:(e,r,t)=>{var n=t(808);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},808:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(686);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcz84MWRhIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs2ODY6KGUscix0KT0+e3ZhciBuPXQoODA4KTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDgwODplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNjg2KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz8zNjMxIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n// dispatch for CommonJS interop named imports.\n\nvar useState = React.useState,\n    useEffect = React.useEffect,\n    useLayoutEffect = React.useLayoutEffect,\n    useDebugValue = React.useDebugValue;\nvar didWarnOld18Alpha = false;\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\n\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n// React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n  {\n    if (!didWarnOld18Alpha) {\n      if (React.startTransition !== undefined) {\n        didWarnOld18Alpha = true;\n\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n      }\n    }\n  } // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n\n\n  var value = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedValue = getSnapshot();\n\n      if (!objectIs(value, cachedValue)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  var _useState = useState({\n    inst: {\n      value: value,\n      getSnapshot: getSnapshot\n    }\n  }),\n      inst = _useState[0].inst,\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n\n  useLayoutEffect(function () {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n\n    var handleStoreChange = function () {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    }; // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(handleStoreChange);\n  }, [subscribe]);\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\nvar isServerEnvironment = !canUseDOM;\n\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n\nexports.useSyncExternalStore = useSyncExternalStore$2;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsbUZBQU87O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87OztBQUdQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzPzJhYjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbi8vIGRpc3BhdGNoIGZvciBDb21tb25KUyBpbnRlcm9wIG5hbWVkIGltcG9ydHMuXG5cbnZhciB1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlLFxuICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICB1c2VMYXlvdXRFZmZlY3QgPSBSZWFjdC51c2VMYXlvdXRFZmZlY3QsXG4gICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7XG52YXIgZGlkV2Fybk9sZDE4QWxwaGEgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IGZhbHNlOyAvLyBEaXNjbGFpbWVyOiBUaGlzIHNoaW0gYnJlYWtzIG1hbnkgb2YgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3Jrc1xuLy8gYmVjYXVzZSBvZiBhIHZlcnkgcGFydGljdWxhciBzZXQgb2YgaW1wbGVtZW50YXRpb24gZGV0YWlscyBhbmQgYXNzdW1wdGlvbnNcbi8vIC0tIGNoYW5nZSBhbnkgb25lIG9mIHRoZW0gYW5kIGl0IHdpbGwgYnJlYWsuIFRoZSBtb3N0IGltcG9ydGFudCBhc3N1bXB0aW9uXG4vLyBpcyB0aGF0IHVwZGF0ZXMgYXJlIGFsd2F5cyBzeW5jaHJvbm91cywgYmVjYXVzZSBjb25jdXJyZW50IHJlbmRlcmluZyBpc1xuLy8gb25seSBhdmFpbGFibGUgaW4gdmVyc2lvbnMgb2YgUmVhY3QgdGhhdCBhbHNvIGhhdmUgYSBidWlsdC1pblxuLy8gdXNlU3luY0V4dGVybmFsU3RvcmUgQVBJLiBBbmQgd2Ugb25seSB1c2UgdGhpcyBzaGltIHdoZW4gdGhlIGJ1aWx0LWluIEFQSVxuLy8gZG9lcyBub3QgZXhpc3QuXG4vL1xuLy8gRG8gbm90IGFzc3VtZSB0aGF0IHRoZSBjbGV2ZXIgaGFja3MgdXNlZCBieSB0aGlzIGhvb2sgYWxzbyB3b3JrIGluIGdlbmVyYWwuXG4vLyBUaGUgcG9pbnQgb2YgdGhpcyBzaGltIGlzIHRvIHJlcGxhY2UgdGhlIG5lZWQgZm9yIGhhY2tzIGJ5IG90aGVyIGxpYnJhcmllcy5cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4vLyB3aWxsIG5lZWQgdG8gdHJhY2sgdGhhdCB0aGVtc2VsdmVzIGFuZCByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWVcbi8vIGZyb20gYGdldFNuYXBzaG90YC5cbmdldFNlcnZlclNuYXBzaG90KSB7XG4gIHtcbiAgICBpZiAoIWRpZFdhcm5PbGQxOEFscGhhKSB7XG4gICAgICBpZiAoUmVhY3Quc3RhcnRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlkV2Fybk9sZDE4QWxwaGEgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdZb3UgYXJlIHVzaW5nIGFuIG91dGRhdGVkLCBwcmUtcmVsZWFzZSBhbHBoYSBvZiBSZWFjdCAxOCB0aGF0ICcgKyAnZG9lcyBub3Qgc3VwcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZS4gVGhlICcgKyAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUgc2hpbSB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS4gVXBncmFkZSAnICsgJ3RvIGEgbmV3ZXIgcHJlLXJlbGVhc2UuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBBZ2FpbiwgdGhpc1xuICAvLyBicmVha3MgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBoZXJlIGJlY2F1c2Ugb2Ygc3BlY2lmaWNcbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscywgbW9zdCBpbXBvcnRhbnRseSB0aGF0IHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuXG4gIHZhciB2YWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAge1xuICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgIHZhciBjYWNoZWRWYWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAgICAgIGlmICghb2JqZWN0SXModmFsdWUsIGNhY2hlZFZhbHVlKSkge1xuICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEJlY2F1c2UgdXBkYXRlcyBhcmUgc3luY2hyb25vdXMsIHdlIGRvbid0IHF1ZXVlIHRoZW0uIEluc3RlYWQgd2UgZm9yY2UgYVxuICAvLyByZS1yZW5kZXIgd2hlbmV2ZXIgdGhlIHN1YnNjcmliZWQgc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyBhbiBzb21lXG4gIC8vIGFyYml0cmFyeSB1c2VTdGF0ZSBob29rLiBUaGVuLCBkdXJpbmcgcmVuZGVyLCB3ZSBjYWxsIGdldFNuYXBzaG90IHRvIHJlYWRcbiAgLy8gdGhlIGN1cnJlbnQgdmFsdWUuXG4gIC8vXG4gIC8vIEJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSBzdGF0ZSByZXR1cm5lZCBieSB0aGUgdXNlU3RhdGUgaG9vaywgd2VcbiAgLy8gY2FuIHNhdmUgYSBiaXQgb2YgbWVtb3J5IGJ5IHN0b3Jpbmcgb3RoZXIgc3R1ZmYgaW4gdGhhdCBzbG90LlxuICAvL1xuICAvLyBUbyBpbXBsZW1lbnQgdGhlIGVhcmx5IGJhaWxvdXQsIHdlIG5lZWQgdG8gdHJhY2sgc29tZSB0aGluZ3Mgb24gYSBtdXRhYmxlXG4gIC8vIG9iamVjdC4gVXN1YWxseSwgd2Ugd291bGQgcHV0IHRoYXQgaW4gYSB1c2VSZWYgaG9vaywgYnV0IHdlIGNhbiBzdGFzaCBpdCBpblxuICAvLyBvdXIgdXNlU3RhdGUgaG9vayBpbnN0ZWFkLlxuICAvL1xuICAvLyBUbyBmb3JjZSBhIHJlLXJlbmRlciwgd2UgY2FsbCBmb3JjZVVwZGF0ZSh7aW5zdH0pLiBUaGF0IHdvcmtzIGJlY2F1c2UgdGhlXG4gIC8vIG5ldyBvYmplY3QgYWx3YXlzIGZhaWxzIGFuIGVxdWFsaXR5IGNoZWNrLlxuXG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHtcbiAgICBpbnN0OiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3RcbiAgICB9XG4gIH0pLFxuICAgICAgaW5zdCA9IF91c2VTdGF0ZVswXS5pbnN0LFxuICAgICAgZm9yY2VVcGRhdGUgPSBfdXNlU3RhdGVbMV07IC8vIFRyYWNrIHRoZSBsYXRlc3QgZ2V0U25hcHNob3QgZnVuY3Rpb24gd2l0aCBhIHJlZi4gVGhpcyBuZWVkcyB0byBiZSB1cGRhdGVkXG4gIC8vIGluIHRoZSBsYXlvdXQgcGhhc2Ugc28gd2UgY2FuIGFjY2VzcyBpdCBkdXJpbmcgdGhlIHRlYXJpbmcgY2hlY2sgdGhhdFxuICAvLyBoYXBwZW5zIG9uIHN1YnNjcmliZS5cblxuXG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gV2hlbmV2ZXIgZ2V0U25hcHNob3Qgb3Igc3Vic2NyaWJlIGNoYW5nZXMsIHdlIG5lZWQgdG8gY2hlY2sgaW4gdGhlXG4gICAgLy8gY29tbWl0IHBoYXNlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcmxlYXZlZCBtdXRhdGlvbi4gSW4gY29uY3VycmVudCBtb2RlXG4gICAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuICAgIC8vIGVmZmVjdCBtYXkgaGF2ZSBtdXRhdGVkIHRoZSBzdG9yZS5cblxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbc3Vic2NyaWJlLCB2YWx1ZSwgZ2V0U25hcHNob3RdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDaGVjayBmb3IgY2hhbmdlcyByaWdodCBiZWZvcmUgc3Vic2NyaWJpbmcuIFN1YnNlcXVlbnQgY2hhbmdlcyB3aWxsIGJlXG4gICAgLy8gZGV0ZWN0ZWQgaW4gdGhlIHN1YnNjcmlwdGlvbiBoYW5kbGVyLlxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETzogQmVjYXVzZSB0aGVyZSBpcyBubyBjcm9zcy1yZW5kZXJlciBBUEkgZm9yIGJhdGNoaW5nIHVwZGF0ZXMsIGl0J3NcbiAgICAgIC8vIHVwIHRvIHRoZSBjb25zdW1lciBvZiB0aGlzIGxpYnJhcnkgdG8gd3JhcCB0aGVpciBzdWJzY3JpcHRpb24gZXZlbnRcbiAgICAgIC8vIHdpdGggdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMuIFNob3VsZCB3ZSB0cnkgdG8gZGV0ZWN0IHdoZW4gdGhpcyBpc24ndFxuICAgICAgLy8gdGhlIGNhc2UgYW5kIHByaW50IGEgd2FybmluZyBpbiBkZXZlbG9wbWVudD9cbiAgICAgIC8vIFRoZSBzdG9yZSBjaGFuZ2VkLiBDaGVjayBpZiB0aGUgc25hcHNob3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlXG4gICAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgICBpbnN0OiBpbnN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07IC8vIFN1YnNjcmliZSB0byB0aGUgc3RvcmUgYW5kIHJldHVybiBhIGNsZWFuLXVwIGZ1bmN0aW9uLlxuXG5cbiAgICByZXR1cm4gc3Vic2NyaWJlKGhhbmRsZVN0b3JlQ2hhbmdlKTtcbiAgfSwgW3N1YnNjcmliZV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2ZcbiAgLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4gIC8vIHdpbGwgbmVlZCB0byB0cmFjayB0aGF0IHRoZW1zZWx2ZXMgYW5kIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZVxuICAvLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG4gIHJldHVybiBnZXRTbmFwc2hvdCgpO1xufVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cbnZhciBpc1NlcnZlckVudmlyb25tZW50ID0gIWNhblVzZURPTTtcblxudmFyIHNoaW0gPSBpc1NlcnZlckVudmlyb25tZW50ID8gdXNlU3luY0V4dGVybmFsU3RvcmUkMSA6IHVzZVN5bmNFeHRlcm5hbFN0b3JlO1xudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDIgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPT0gdW5kZWZpbmVkID8gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUgOiBzaGltO1xuXG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmUkMjtcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar shim = __webpack_require__(/*! use-sync-external-store/shim */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\");\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\nvar useSyncExternalStore = shim.useSyncExternalStore;\n\n// for CommonJS interop.\n\nvar useRef = React.useRef,\n    useEffect = React.useEffect,\n    useMemo = React.useMemo,\n    useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n\nfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n  // Use this to track the rendered snapshot.\n  var instRef = useRef(null);\n  var inst;\n\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n\n  var _useMemo = useMemo(function () {\n    // Track the memoized state using closure variables that are local to this\n    // memoized instance of a getSnapshot function. Intentionally not using a\n    // useRef hook, because that state would be shared across all concurrent\n    // copies of the hook/component.\n    var hasMemo = false;\n    var memoizedSnapshot;\n    var memoizedSelection;\n\n    var memoizedSelector = function (nextSnapshot) {\n      if (!hasMemo) {\n        // The first time the hook is called, there is no memoized result.\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n\n        var _nextSelection = selector(nextSnapshot);\n\n        if (isEqual !== undefined) {\n          // Even if the selector has changed, the currently rendered selection\n          // may be equal to the new selection. We should attempt to reuse the\n          // current value if possible, to preserve downstream memoizations.\n          if (inst.hasValue) {\n            var currentSelection = inst.value;\n\n            if (isEqual(currentSelection, _nextSelection)) {\n              memoizedSelection = currentSelection;\n              return currentSelection;\n            }\n          }\n        }\n\n        memoizedSelection = _nextSelection;\n        return _nextSelection;\n      } // We may be able to reuse the previous invocation's result.\n\n\n      // We may be able to reuse the previous invocation's result.\n      var prevSnapshot = memoizedSnapshot;\n      var prevSelection = memoizedSelection;\n\n      if (objectIs(prevSnapshot, nextSnapshot)) {\n        // The snapshot is the same as last time. Reuse the previous selection.\n        return prevSelection;\n      } // The snapshot has changed, so we need to compute a new selection.\n\n\n      // The snapshot has changed, so we need to compute a new selection.\n      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n\n      // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n        return prevSelection;\n      }\n\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    }; // Assigning this to a constant so that Flow knows it can't change.\n\n\n    // Assigning this to a constant so that Flow knows it can't change.\n    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n\n    var getSnapshotWithSelector = function () {\n      return memoizedSelector(getSnapshot());\n    };\n\n    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {\n      return memoizedSelector(maybeGetServerSnapshot());\n    };\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]),\n      getSelection = _useMemo[0],\n      getServerSelection = _useMemo[1];\n\n  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n  useEffect(function () {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n  useDebugValue(value);\n  return value;\n}\n\nexports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxtRkFBTztBQUNyQyxXQUFXLG1CQUFPLENBQUMsOEdBQThCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcz8xODY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0nKTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gc2hpbS51c2VTeW5jRXh0ZXJuYWxTdG9yZTtcblxuLy8gZm9yIENvbW1vbkpTIGludGVyb3AuXG5cbnZhciB1c2VSZWYgPSBSZWFjdC51c2VSZWYsXG4gICAgdXNlRWZmZWN0ID0gUmVhY3QudXNlRWZmZWN0LFxuICAgIHVzZU1lbW8gPSBSZWFjdC51c2VNZW1vLFxuICAgIHVzZURlYnVnVmFsdWUgPSBSZWFjdC51c2VEZWJ1Z1ZhbHVlOyAvLyBTYW1lIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlLCBidXQgc3VwcG9ydHMgc2VsZWN0b3IgYW5kIGlzRXF1YWwgYXJndW1lbnRzLlxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgdGhlIHJlbmRlcmVkIHNuYXBzaG90LlxuICB2YXIgaW5zdFJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGluc3Q7XG5cbiAgaWYgKGluc3RSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgIGluc3QgPSB7XG4gICAgICBoYXNWYWx1ZTogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH07XG4gICAgaW5zdFJlZi5jdXJyZW50ID0gaW5zdDtcbiAgfSBlbHNlIHtcbiAgICBpbnN0ID0gaW5zdFJlZi5jdXJyZW50O1xuICB9XG5cbiAgdmFyIF91c2VNZW1vID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gVHJhY2sgdGhlIG1lbW9pemVkIHN0YXRlIHVzaW5nIGNsb3N1cmUgdmFyaWFibGVzIHRoYXQgYXJlIGxvY2FsIHRvIHRoaXNcbiAgICAvLyBtZW1vaXplZCBpbnN0YW5jZSBvZiBhIGdldFNuYXBzaG90IGZ1bmN0aW9uLiBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBhXG4gICAgLy8gdXNlUmVmIGhvb2ssIGJlY2F1c2UgdGhhdCBzdGF0ZSB3b3VsZCBiZSBzaGFyZWQgYWNyb3NzIGFsbCBjb25jdXJyZW50XG4gICAgLy8gY29waWVzIG9mIHRoZSBob29rL2NvbXBvbmVudC5cbiAgICB2YXIgaGFzTWVtbyA9IGZhbHNlO1xuICAgIHZhciBtZW1vaXplZFNuYXBzaG90O1xuICAgIHZhciBtZW1vaXplZFNlbGVjdGlvbjtcblxuICAgIHZhciBtZW1vaXplZFNlbGVjdG9yID0gZnVuY3Rpb24gKG5leHRTbmFwc2hvdCkge1xuICAgICAgaWYgKCFoYXNNZW1vKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHRoZSBob29rIGlzIGNhbGxlZCwgdGhlcmUgaXMgbm8gbWVtb2l6ZWQgcmVzdWx0LlxuICAgICAgICBoYXNNZW1vID0gdHJ1ZTtcbiAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcblxuICAgICAgICB2YXIgX25leHRTZWxlY3Rpb24gPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuXG4gICAgICAgIGlmIChpc0VxdWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBFdmVuIGlmIHRoZSBzZWxlY3RvciBoYXMgY2hhbmdlZCwgdGhlIGN1cnJlbnRseSByZW5kZXJlZCBzZWxlY3Rpb25cbiAgICAgICAgICAvLyBtYXkgYmUgZXF1YWwgdG8gdGhlIG5ldyBzZWxlY3Rpb24uIFdlIHNob3VsZCBhdHRlbXB0IHRvIHJldXNlIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgdmFsdWUgaWYgcG9zc2libGUsIHRvIHByZXNlcnZlIGRvd25zdHJlYW0gbWVtb2l6YXRpb25zLlxuICAgICAgICAgIGlmIChpbnN0Lmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGluc3QudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChpc0VxdWFsKGN1cnJlbnRTZWxlY3Rpb24sIF9uZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lbW9pemVkU2VsZWN0aW9uID0gX25leHRTZWxlY3Rpb247XG4gICAgICAgIHJldHVybiBfbmV4dFNlbGVjdGlvbjtcbiAgICAgIH0gLy8gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgdGhlIHByZXZpb3VzIGludm9jYXRpb24ncyByZXN1bHQuXG5cblxuICAgICAgLy8gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgdGhlIHByZXZpb3VzIGludm9jYXRpb24ncyByZXN1bHQuXG4gICAgICB2YXIgcHJldlNuYXBzaG90ID0gbWVtb2l6ZWRTbmFwc2hvdDtcbiAgICAgIHZhciBwcmV2U2VsZWN0aW9uID0gbWVtb2l6ZWRTZWxlY3Rpb247XG5cbiAgICAgIGlmIChvYmplY3RJcyhwcmV2U25hcHNob3QsIG5leHRTbmFwc2hvdCkpIHtcbiAgICAgICAgLy8gVGhlIHNuYXBzaG90IGlzIHRoZSBzYW1lIGFzIGxhc3QgdGltZS4gUmV1c2UgdGhlIHByZXZpb3VzIHNlbGVjdGlvbi5cbiAgICAgICAgcmV0dXJuIHByZXZTZWxlY3Rpb247XG4gICAgICB9IC8vIFRoZSBzbmFwc2hvdCBoYXMgY2hhbmdlZCwgc28gd2UgbmVlZCB0byBjb21wdXRlIGEgbmV3IHNlbGVjdGlvbi5cblxuXG4gICAgICAvLyBUaGUgc25hcHNob3QgaGFzIGNoYW5nZWQsIHNvIHdlIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBzZWxlY3Rpb24uXG4gICAgICB2YXIgbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7IC8vIElmIGEgY3VzdG9tIGlzRXF1YWwgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHVzZSB0aGF0IHRvIGNoZWNrIGlmIHRoZSBkYXRhXG4gICAgICAvLyBoYXMgY2hhbmdlZC4gSWYgaXQgaGFzbid0LCByZXR1cm4gdGhlIHByZXZpb3VzIHNlbGVjdGlvbi4gVGhhdCBzaWduYWxzXG4gICAgICAvLyB0byBSZWFjdCB0aGF0IHRoZSBzZWxlY3Rpb25zIGFyZSBjb25jZXB0dWFsbHkgZXF1YWwsIGFuZCB3ZSBjYW4gYmFpbFxuICAgICAgLy8gb3V0IG9mIHJlbmRlcmluZy5cblxuICAgICAgLy8gSWYgYSBjdXN0b20gaXNFcXVhbCBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdXNlIHRoYXQgdG8gY2hlY2sgaWYgdGhlIGRhdGFcbiAgICAgIC8vIGhhcyBjaGFuZ2VkLiBJZiBpdCBoYXNuJ3QsIHJldHVybiB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLiBUaGF0IHNpZ25hbHNcbiAgICAgIC8vIHRvIFJlYWN0IHRoYXQgdGhlIHNlbGVjdGlvbnMgYXJlIGNvbmNlcHR1YWxseSBlcXVhbCwgYW5kIHdlIGNhbiBiYWlsXG4gICAgICAvLyBvdXQgb2YgcmVuZGVyaW5nLlxuICAgICAgaWYgKGlzRXF1YWwgIT09IHVuZGVmaW5lZCAmJiBpc0VxdWFsKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBwcmV2U2VsZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBuZXh0U2VsZWN0aW9uO1xuICAgICAgcmV0dXJuIG5leHRTZWxlY3Rpb247XG4gICAgfTsgLy8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdGFudCBzbyB0aGF0IEZsb3cga25vd3MgaXQgY2FuJ3QgY2hhbmdlLlxuXG5cbiAgICAvLyBBc3NpZ25pbmcgdGhpcyB0byBhIGNvbnN0YW50IHNvIHRoYXQgRmxvdyBrbm93cyBpdCBjYW4ndCBjaGFuZ2UuXG4gICAgdmFyIG1heWJlR2V0U2VydmVyU25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdldFNlcnZlclNuYXBzaG90O1xuXG4gICAgdmFyIGdldFNuYXBzaG90V2l0aFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IoZ2V0U25hcHNob3QoKSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3RvciA9IG1heWJlR2V0U2VydmVyU25hcHNob3QgPT09IG51bGwgPyB1bmRlZmluZWQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihtYXliZUdldFNlcnZlclNuYXBzaG90KCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFtnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciwgZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3JdO1xuICB9LCBbZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90LCBzZWxlY3RvciwgaXNFcXVhbF0pLFxuICAgICAgZ2V0U2VsZWN0aW9uID0gX3VzZU1lbW9bMF0sXG4gICAgICBnZXRTZXJ2ZXJTZWxlY3Rpb24gPSBfdXNlTWVtb1sxXTtcblxuICB2YXIgdmFsdWUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNlbGVjdGlvbiwgZ2V0U2VydmVyU2VsZWN0aW9uKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpbnN0Lmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICBpbnN0LnZhbHVlID0gdmFsdWU7XG4gIH0sIFt2YWx1ZV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3I7XG4gICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xufVxuICAgICAgICBcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js":
/*!************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw0TUFBOEU7QUFDaEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanM/MDUzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js":
/*!********************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/with-selector.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim/with-selector.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHdPQUE0RjtBQUM5RiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzPzBjMDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"f4d659cb3d93\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzP2RkM2UiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJmNGQ2NTljYjNkOTNcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/Room.tsx":
/*!**********************!*\
  !*** ./app/Room.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Room: function() { return /* binding */ Room; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _liveblocks_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../liveblocks.config */ \"(app-pages-browser)/./liveblocks.config.ts\");\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liveblocks/react */ \"(app-pages-browser)/./node_modules/@liveblocks/react/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ Room auto */ \n\n\nfunction Room(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_liveblocks_config__WEBPACK_IMPORTED_MODULE_1__.RoomProvider, {\n        id: \"my-room\",\n        initialPresence: {},\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_liveblocks_react__WEBPACK_IMPORTED_MODULE_2__.ClientSideSuspense, {\n            fallback: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: \"Loading…\"\n            }, void 0, false, {\n                fileName: \"C:\\\\code-files\\\\figpro\\\\app\\\\Room.tsx\",\n                lineNumber: 10,\n                columnNumber: 37\n            }, void 0),\n            children: ()=>children\n        }, void 0, false, {\n            fileName: \"C:\\\\code-files\\\\figpro\\\\app\\\\Room.tsx\",\n            lineNumber: 10,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\code-files\\\\figpro\\\\app\\\\Room.tsx\",\n        lineNumber: 9,\n        columnNumber: 5\n    }, this);\n}\n_c = Room;\nvar _c;\n$RefreshReg$(_c, \"Room\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9Sb29tLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUdvRDtBQUNHO0FBRWhELFNBQVNFLEtBQUssS0FBcUM7UUFBckMsRUFBRUMsUUFBUSxFQUEyQixHQUFyQztJQUNuQixxQkFDRSw4REFBQ0gsNERBQVlBO1FBQUNJLElBQUc7UUFBVUMsaUJBQWlCLENBQUM7a0JBQzNDLDRFQUFDSixpRUFBa0JBO1lBQUNLLHdCQUFVLDhEQUFDQzswQkFBSTs7Ozs7O3NCQUNoQyxJQUFNSjs7Ozs7Ozs7Ozs7QUFJZjtLQVJnQkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL1Jvb20udHN4Pzk4Y2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgeyBSZWFjdE5vZGUgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgUm9vbVByb3ZpZGVyIH0gZnJvbSBcIi4uL2xpdmVibG9ja3MuY29uZmlnXCI7XHJcbmltcG9ydCB7IENsaWVudFNpZGVTdXNwZW5zZSB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9yZWFjdFwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFJvb20oeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSkge1xyXG4gIHJldHVybiAoXHJcbiAgICA8Um9vbVByb3ZpZGVyIGlkPVwibXktcm9vbVwiIGluaXRpYWxQcmVzZW5jZT17e319PlxyXG4gICAgICA8Q2xpZW50U2lkZVN1c3BlbnNlIGZhbGxiYWNrPXs8ZGl2PkxvYWRpbmfigKY8L2Rpdj59PlxyXG4gICAgICAgIHsoKSA9PiBjaGlsZHJlbn1cclxuICAgICAgPC9DbGllbnRTaWRlU3VzcGVuc2U+XHJcbiAgICA8L1Jvb21Qcm92aWRlcj5cclxuICApO1xyXG59Il0sIm5hbWVzIjpbIlJvb21Qcm92aWRlciIsIkNsaWVudFNpZGVTdXNwZW5zZSIsIlJvb20iLCJjaGlsZHJlbiIsImlkIiwiaW5pdGlhbFByZXNlbmNlIiwiZmFsbGJhY2siLCJkaXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/Room.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./liveblocks.config.ts":
/*!******************************!*\
  !*** ./liveblocks.config.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiveblocksProvider: function() { return /* binding */ LiveblocksProvider; },\n/* harmony export */   RoomProvider: function() { return /* binding */ RoomProvider; },\n/* harmony export */   useAddReaction: function() { return /* binding */ useAddReaction; },\n/* harmony export */   useBatch: function() { return /* binding */ useBatch; },\n/* harmony export */   useBroadcastEvent: function() { return /* binding */ useBroadcastEvent; },\n/* harmony export */   useCanRedo: function() { return /* binding */ useCanRedo; },\n/* harmony export */   useCanUndo: function() { return /* binding */ useCanUndo; },\n/* harmony export */   useCreateComment: function() { return /* binding */ useCreateComment; },\n/* harmony export */   useCreateThread: function() { return /* binding */ useCreateThread; },\n/* harmony export */   useDeleteComment: function() { return /* binding */ useDeleteComment; },\n/* harmony export */   useEditComment: function() { return /* binding */ useEditComment; },\n/* harmony export */   useEditThreadMetadata: function() { return /* binding */ useEditThreadMetadata; },\n/* harmony export */   useErrorListener: function() { return /* binding */ useErrorListener; },\n/* harmony export */   useEventListener: function() { return /* binding */ useEventListener; },\n/* harmony export */   useHistory: function() { return /* binding */ useHistory; },\n/* harmony export */   useInboxNotifications: function() { return /* binding */ useInboxNotifications; },\n/* harmony export */   useList: function() { return /* binding */ useList; },\n/* harmony export */   useLostConnectionListener: function() { return /* binding */ useLostConnectionListener; },\n/* harmony export */   useMap: function() { return /* binding */ useMap; },\n/* harmony export */   useMarkAllInboxNotificationsAsRead: function() { return /* binding */ useMarkAllInboxNotificationsAsRead; },\n/* harmony export */   useMarkInboxNotificationAsRead: function() { return /* binding */ useMarkInboxNotificationAsRead; },\n/* harmony export */   useMarkThreadAsRead: function() { return /* binding */ useMarkThreadAsRead; },\n/* harmony export */   useMutation: function() { return /* binding */ useMutation; },\n/* harmony export */   useMyPresence: function() { return /* binding */ useMyPresence; },\n/* harmony export */   useObject: function() { return /* binding */ useObject; },\n/* harmony export */   useOther: function() { return /* binding */ useOther; },\n/* harmony export */   useOthers: function() { return /* binding */ useOthers; },\n/* harmony export */   useOthersConnectionIds: function() { return /* binding */ useOthersConnectionIds; },\n/* harmony export */   useOthersListener: function() { return /* binding */ useOthersListener; },\n/* harmony export */   useOthersMapped: function() { return /* binding */ useOthersMapped; },\n/* harmony export */   useRedo: function() { return /* binding */ useRedo; },\n/* harmony export */   useRemoveReaction: function() { return /* binding */ useRemoveReaction; },\n/* harmony export */   useRoom: function() { return /* binding */ useRoom; },\n/* harmony export */   useRoomInfo: function() { return /* binding */ useRoomInfo; },\n/* harmony export */   useRoomNotificationSettings: function() { return /* binding */ useRoomNotificationSettings; },\n/* harmony export */   useSelf: function() { return /* binding */ useSelf; },\n/* harmony export */   useStatus: function() { return /* binding */ useStatus; },\n/* harmony export */   useStorage: function() { return /* binding */ useStorage; },\n/* harmony export */   useThreadSubscription: function() { return /* binding */ useThreadSubscription; },\n/* harmony export */   useThreads: function() { return /* binding */ useThreads; },\n/* harmony export */   useUndo: function() { return /* binding */ useUndo; },\n/* harmony export */   useUnreadInboxNotificationsCount: function() { return /* binding */ useUnreadInboxNotificationsCount; },\n/* harmony export */   useUpdateMyPresence: function() { return /* binding */ useUpdateMyPresence; },\n/* harmony export */   useUpdateRoomNotificationSettings: function() { return /* binding */ useUpdateRoomNotificationSettings; },\n/* harmony export */   useUser: function() { return /* binding */ useUser; }\n/* harmony export */ });\n/* harmony import */ var _liveblocks_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @liveblocks/client */ \"(app-pages-browser)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/react */ \"(app-pages-browser)/./node_modules/@liveblocks/react/dist/index.mjs\");\n\n\nconst client = (0,_liveblocks_client__WEBPACK_IMPORTED_MODULE_0__.createClient)({\n    publicApiKey: \"pk_dev_JsY4wgbhsAfYfKJ7WcwOjVZVnDIYxp5yLUy_CxIkPnEWOfYx7RR86aO0MgAx3zxH\"\n});\n// Room-level hooks, use inside `RoomProvider`\nconst { suspense: { RoomProvider, useRoom, useMyPresence, useUpdateMyPresence, useSelf, useOthers, useOthersMapped, useOthersListener, useOthersConnectionIds, useOther, useBroadcastEvent, useEventListener, useErrorListener, useStorage, useObject, useMap, useList, useBatch, useHistory, useUndo, useRedo, useCanUndo, useCanRedo, useMutation, useStatus, useLostConnectionListener, useThreads, useCreateThread, useEditThreadMetadata, useCreateComment, useEditComment, useDeleteComment, useAddReaction, useRemoveReaction, useThreadSubscription, useMarkThreadAsRead, useRoomNotificationSettings, useUpdateRoomNotificationSettings } } = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_1__.createRoomContext)(client);\n// Project-level hooks, use inside `LiveblocksProvider`\nconst { suspense: { LiveblocksProvider, useMarkInboxNotificationAsRead, useMarkAllInboxNotificationsAsRead, useInboxNotifications, useUnreadInboxNotificationsCount, // These hooks can be exported from either context\nuseUser, useRoomInfo } } = (0,_liveblocks_react__WEBPACK_IMPORTED_MODULE_1__.createLiveblocksContext)(client);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpdmVibG9ja3MuY29uZmlnLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtEO0FBQzZCO0FBRS9FLE1BQU1HLFNBQVNILGdFQUFZQSxDQUFDO0lBQzFCSSxjQUFjQyx5RUFBNEM7QUFDNUQ7QUEwQ0EsOENBQThDO0FBQ3ZDLE1BQU0sRUFDWEcsVUFBVSxFQUNSQyxZQUFZLEVBQ1pDLE9BQU8sRUFDUEMsYUFBYSxFQUNiQyxtQkFBbUIsRUFDbkJDLE9BQU8sRUFDUEMsU0FBUyxFQUNUQyxlQUFlLEVBQ2ZDLGlCQUFpQixFQUNqQkMsc0JBQXNCLEVBQ3RCQyxRQUFRLEVBQ1JDLGlCQUFpQixFQUNqQkMsZ0JBQWdCLEVBQ2hCQyxnQkFBZ0IsRUFDaEJDLFVBQVUsRUFDVkMsU0FBUyxFQUNUQyxNQUFNLEVBQ05DLE9BQU8sRUFDUEMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLE9BQU8sRUFDUEMsT0FBTyxFQUNQQyxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyxTQUFTLEVBQ1RDLHlCQUF5QixFQUN6QkMsVUFBVSxFQUNWQyxlQUFlLEVBQ2ZDLHFCQUFxQixFQUNyQkMsZ0JBQWdCLEVBQ2hCQyxjQUFjLEVBQ2RDLGdCQUFnQixFQUNoQkMsY0FBYyxFQUNkQyxpQkFBaUIsRUFDakJDLHFCQUFxQixFQUNyQkMsbUJBQW1CLEVBQ25CQywyQkFBMkIsRUFDM0JDLGlDQUFpQyxFQUtsQyxFQUNGLEdBQUc3QyxvRUFBaUJBLENBQXlERSxRQUFRO0FBRXRGLHVEQUF1RDtBQUNoRCxNQUFNLEVBQ1hLLFVBQVUsRUFDUnVDLGtCQUFrQixFQUNsQkMsOEJBQThCLEVBQzlCQyxrQ0FBa0MsRUFDbENDLHFCQUFxQixFQUNyQkMsZ0NBQWdDLEVBRWhDLGtEQUFrRDtBQUNsREMsT0FBTyxFQUNQQyxXQUFXLEVBQ1osRUFDRixHQUFHbkQsMEVBQXVCQSxDQUEyQkMsUUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saXZlYmxvY2tzLmNvbmZpZy50cz9iYzA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jbGllbnRcIjtcbmltcG9ydCB7IGNyZWF0ZVJvb21Db250ZXh0LCBjcmVhdGVMaXZlYmxvY2tzQ29udGV4dCB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9yZWFjdFwiO1xuICBcbmNvbnN0IGNsaWVudCA9IGNyZWF0ZUNsaWVudCh7XG4gIHB1YmxpY0FwaUtleTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTElWRUJMT0NLX1BVQkxJQ19LRVkhLFxufSk7XG5cbi8vIFByZXNlbmNlIHJlcHJlc2VudHMgdGhlIHByb3BlcnRpZXMgdGhhdCBleGlzdCBvbiBldmVyeSB1c2VyIGluIHRoZSBSb29tXG4vLyBhbmQgdGhhdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUga2VwdCBpbiBzeW5jLiBBY2Nlc3NpYmxlIHRocm91Z2ggdGhlXG4vLyBgdXNlci5wcmVzZW5jZWAgcHJvcGVydHkuIE11c3QgYmUgSlNPTi1zZXJpYWxpemFibGUuXG50eXBlIFByZXNlbmNlID0ge1xuICAvLyBjdXJzb3I6IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSB8IG51bGwsXG4gIC8vIC4uLlxufTtcblxuLy8gT3B0aW9uYWxseSwgU3RvcmFnZSByZXByZXNlbnRzIHRoZSBzaGFyZWQgZG9jdW1lbnQgdGhhdCBwZXJzaXN0cyBpbiB0aGVcbi8vIFJvb20sIGV2ZW4gYWZ0ZXIgYWxsIHVzZXJzIGxlYXZlLiBGaWVsZHMgdW5kZXIgU3RvcmFnZSB0eXBpY2FsbHkgYXJlXG4vLyBMaXZlTGlzdCwgTGl2ZU1hcCwgTGl2ZU9iamVjdCBpbnN0YW5jZXMsIGZvciB3aGljaCB1cGRhdGVzIGFyZVxuLy8gYXV0b21hdGljYWxseSBwZXJzaXN0ZWQgYW5kIHN5bmNlZCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMuXG50eXBlIFN0b3JhZ2UgPSB7XG4gIC8vIGF1dGhvcjogTGl2ZU9iamVjdDx7IGZpcnN0TmFtZTogc3RyaW5nLCBsYXN0TmFtZTogc3RyaW5nIH0+LFxuICAvLyAuLi5cbn07XG5cbi8vIE9wdGlvbmFsbHksIFVzZXJNZXRhIHJlcHJlc2VudHMgc3RhdGljL3JlYWRvbmx5IG1ldGFkYXRhIG9uIGVhY2ggdXNlciwgYXNcbi8vIHByb3ZpZGVkIGJ5IHlvdXIgb3duIGN1c3RvbSBhdXRoIGJhY2sgZW5kIChpZiB1c2VkKS4gVXNlZnVsIGZvciBkYXRhIHRoYXRcbi8vIHdpbGwgbm90IGNoYW5nZSBkdXJpbmcgYSBzZXNzaW9uLCBsaWtlIGEgdXNlcidzIG5hbWUgb3IgYXZhdGFyLlxudHlwZSBVc2VyTWV0YSA9IHtcbiAgLy8gaWQ/OiBzdHJpbmcsICAvLyBBY2Nlc3NpYmxlIHRocm91Z2ggYHVzZXIuaWRgXG4gIC8vIGluZm8/OiBKc29uLCAgLy8gQWNjZXNzaWJsZSB0aHJvdWdoIGB1c2VyLmluZm9gXG59O1xuXG4vLyBPcHRpb25hbGx5LCB0aGUgdHlwZSBvZiBjdXN0b20gZXZlbnRzIGJyb2FkY2FzdCBhbmQgbGlzdGVuZWQgdG8gaW4gdGhpc1xuLy8gcm9vbS4gVXNlIGEgdW5pb24gZm9yIG11bHRpcGxlIGV2ZW50cy4gTXVzdCBiZSBKU09OLXNlcmlhbGl6YWJsZS5cbnR5cGUgUm9vbUV2ZW50ID0ge1xuICAvLyB0eXBlOiBcIk5PVElGSUNBVElPTlwiLFxuICAvLyAuLi5cbn07XG5cbi8vIE9wdGlvbmFsbHksIHdoZW4gdXNpbmcgQ29tbWVudHMsIFRocmVhZE1ldGFkYXRhIHJlcHJlc2VudHMgbWV0YWRhdGEgb25cbi8vIGVhY2ggdGhyZWFkLiBDYW4gb25seSBjb250YWluIGJvb2xlYW5zLCBzdHJpbmdzLCBhbmQgbnVtYmVycy5cbmV4cG9ydCB0eXBlIFRocmVhZE1ldGFkYXRhID0ge1xuICAvLyByZXNvbHZlZDogYm9vbGVhbjtcbiAgLy8gcXVvdGU6IHN0cmluZztcbiAgLy8gdGltZTogbnVtYmVyO1xufTtcblxuLy8gUm9vbS1sZXZlbCBob29rcywgdXNlIGluc2lkZSBgUm9vbVByb3ZpZGVyYFxuZXhwb3J0IGNvbnN0IHtcbiAgc3VzcGVuc2U6IHtcbiAgICBSb29tUHJvdmlkZXIsXG4gICAgdXNlUm9vbSxcbiAgICB1c2VNeVByZXNlbmNlLFxuICAgIHVzZVVwZGF0ZU15UHJlc2VuY2UsXG4gICAgdXNlU2VsZixcbiAgICB1c2VPdGhlcnMsXG4gICAgdXNlT3RoZXJzTWFwcGVkLFxuICAgIHVzZU90aGVyc0xpc3RlbmVyLFxuICAgIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHMsXG4gICAgdXNlT3RoZXIsXG4gICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgdXNlRXZlbnRMaXN0ZW5lcixcbiAgICB1c2VFcnJvckxpc3RlbmVyLFxuICAgIHVzZVN0b3JhZ2UsXG4gICAgdXNlT2JqZWN0LFxuICAgIHVzZU1hcCxcbiAgICB1c2VMaXN0LFxuICAgIHVzZUJhdGNoLFxuICAgIHVzZUhpc3RvcnksXG4gICAgdXNlVW5kbyxcbiAgICB1c2VSZWRvLFxuICAgIHVzZUNhblVuZG8sXG4gICAgdXNlQ2FuUmVkbyxcbiAgICB1c2VNdXRhdGlvbixcbiAgICB1c2VTdGF0dXMsXG4gICAgdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcixcbiAgICB1c2VUaHJlYWRzLFxuICAgIHVzZUNyZWF0ZVRocmVhZCxcbiAgICB1c2VFZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgdXNlQ3JlYXRlQ29tbWVudCxcbiAgICB1c2VFZGl0Q29tbWVudCxcbiAgICB1c2VEZWxldGVDb21tZW50LFxuICAgIHVzZUFkZFJlYWN0aW9uLFxuICAgIHVzZVJlbW92ZVJlYWN0aW9uLFxuICAgIHVzZVRocmVhZFN1YnNjcmlwdGlvbixcbiAgICB1c2VNYXJrVGhyZWFkQXNSZWFkLFxuICAgIHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIFxuICAgIC8vIFRoZXNlIGhvb2tzIGNhbiBiZSBleHBvcnRlZCBmcm9tIGVpdGhlciBjb250ZXh0XG4gICAgLy8gdXNlVXNlcixcbiAgICAvLyB1c2VSb29tSW5mb1xuICB9XG59ID0gY3JlYXRlUm9vbUNvbnRleHQ8UHJlc2VuY2UsIFN0b3JhZ2UsIFVzZXJNZXRhLCBSb29tRXZlbnQsIFRocmVhZE1ldGFkYXRhPihjbGllbnQpO1xuXG4vLyBQcm9qZWN0LWxldmVsIGhvb2tzLCB1c2UgaW5zaWRlIGBMaXZlYmxvY2tzUHJvdmlkZXJgXG5leHBvcnQgY29uc3Qge1xuICBzdXNwZW5zZToge1xuICAgIExpdmVibG9ja3NQcm92aWRlcixcbiAgICB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gICAgdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICB1c2VJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQsXG4gIFxuICAgIC8vIFRoZXNlIGhvb2tzIGNhbiBiZSBleHBvcnRlZCBmcm9tIGVpdGhlciBjb250ZXh0XG4gICAgdXNlVXNlcixcbiAgICB1c2VSb29tSW5mbyxcbiAgfVxufSA9IGNyZWF0ZUxpdmVibG9ja3NDb250ZXh0PFVzZXJNZXRhLCBUaHJlYWRNZXRhZGF0YT4oY2xpZW50KTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJjcmVhdGVSb29tQ29udGV4dCIsImNyZWF0ZUxpdmVibG9ja3NDb250ZXh0IiwiY2xpZW50IiwicHVibGljQXBpS2V5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0xJVkVCTE9DS19QVUJMSUNfS0VZIiwic3VzcGVuc2UiLCJSb29tUHJvdmlkZXIiLCJ1c2VSb29tIiwidXNlTXlQcmVzZW5jZSIsInVzZVVwZGF0ZU15UHJlc2VuY2UiLCJ1c2VTZWxmIiwidXNlT3RoZXJzIiwidXNlT3RoZXJzTWFwcGVkIiwidXNlT3RoZXJzTGlzdGVuZXIiLCJ1c2VPdGhlcnNDb25uZWN0aW9uSWRzIiwidXNlT3RoZXIiLCJ1c2VCcm9hZGNhc3RFdmVudCIsInVzZUV2ZW50TGlzdGVuZXIiLCJ1c2VFcnJvckxpc3RlbmVyIiwidXNlU3RvcmFnZSIsInVzZU9iamVjdCIsInVzZU1hcCIsInVzZUxpc3QiLCJ1c2VCYXRjaCIsInVzZUhpc3RvcnkiLCJ1c2VVbmRvIiwidXNlUmVkbyIsInVzZUNhblVuZG8iLCJ1c2VDYW5SZWRvIiwidXNlTXV0YXRpb24iLCJ1c2VTdGF0dXMiLCJ1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyIiwidXNlVGhyZWFkcyIsInVzZUNyZWF0ZVRocmVhZCIsInVzZUVkaXRUaHJlYWRNZXRhZGF0YSIsInVzZUNyZWF0ZUNvbW1lbnQiLCJ1c2VFZGl0Q29tbWVudCIsInVzZURlbGV0ZUNvbW1lbnQiLCJ1c2VBZGRSZWFjdGlvbiIsInVzZVJlbW92ZVJlYWN0aW9uIiwidXNlVGhyZWFkU3Vic2NyaXB0aW9uIiwidXNlTWFya1RocmVhZEFzUmVhZCIsInVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyIsInVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyIsIkxpdmVibG9ja3NQcm92aWRlciIsInVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCIsInVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQiLCJ1c2VJbmJveE5vdGlmaWNhdGlvbnMiLCJ1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCIsInVzZVVzZXIiLCJ1c2VSb29tSW5mbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./liveblocks.config.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Work_Sans\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-work-sans\",\"weight\":[\"400\",\"600\",\"700\"]}],\"variableName\":\"workSans\"}":
/*!***************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\layout.tsx","import":"Work_Sans","arguments":[{"subsets":["latin"],"variable":"--font-work-sans","weight":["400","600","700"]}],"variableName":"workSans"} ***!
  \***************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Work_Sans_707bea', '__Work_Sans_Fallback_707bea'\",\"fontStyle\":\"normal\"},\"className\":\"__className_707bea\",\"variable\":\"__variable_707bea\"};\n    if(true) {\n      // 1710055617243\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwiYXBwXFxcXGxheW91dC50c3hcIixcImltcG9ydFwiOlwiV29ya19TYW5zXCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdLFwidmFyaWFibGVcIjpcIi0tZm9udC13b3JrLXNhbnNcIixcIndlaWdodFwiOltcIjQwMFwiLFwiNjAwXCIsXCI3MDBcIl19XSxcInZhcmlhYmxlTmFtZVwiOlwid29ya1NhbnNcIn0iLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0IsU0FBUyx3RkFBd0Y7QUFDbkgsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsd01BQTBHLGNBQWMsc0RBQXNEO0FBQzVNLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz84MGQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJzdHlsZVwiOntcImZvbnRGYW1pbHlcIjpcIidfX1dvcmtfU2Fuc183MDdiZWEnLCAnX19Xb3JrX1NhbnNfRmFsbGJhY2tfNzA3YmVhJ1wiLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lXzcwN2JlYVwiLFwidmFyaWFibGVcIjpcIl9fdmFyaWFibGVfNzA3YmVhXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MTAwNTU2MTcyNDNcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovY29kZS1maWxlcy9maWdwcm8vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Work_Sans\",\"arguments\":[{\"subsets\":[\"latin\"],\"variable\":\"--font-work-sans\",\"weight\":[\"400\",\"600\",\"700\"]}],\"variableName\":\"workSans\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV = jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUEscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiwyREFBMkQsVUFBVTtBQUNyRSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZEO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsR0FBRztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRCxzQkFBc0IsaUJBQWlCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsOENBQThDLGdEQUFnRCxNQUFNLGFBQWE7O0FBRWpIO0FBQ0EsK0NBQStDLGtDQUFrQyxPQUFPOztBQUV4Rix1R0FBdUcsY0FBYyxVQUFVLGdHQUFnRyxrQkFBa0IsVUFBVSxVQUFVOztBQUVyUTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz85NTk0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9DQUNIRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbnZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTtcblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMiA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMiB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTsgLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxKSB7XG4gICAgICAvLyBUT0RPOiBDcmVhdGUgYSBjb252ZW50aW9uIGZvciBuYW1pbmcgY2xpZW50IHJlZmVyZW5jZXMgd2l0aCBkZWJ1ZyBpbmZvLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBSRUFDVF9DQUNIRV9UWVBFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJ0NhY2hlJztcbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFViQxKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShwYXJlbnRUeXBlKTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFViQxKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdrZXknKSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIGsgIT09ICdrZXknO1xuICAgICAgfSk7XG4gICAgICB2YXIgYmVmb3JlRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7a2V5OiBzb21lS2V5LCAnICsga2V5cy5qb2luKCc6IC4uLiwgJykgKyAnOiAuLi59JyA6ICd7a2V5OiBzb21lS2V5fSc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0S2V5U3ByZWFkW2NvbXBvbmVudE5hbWUgKyBiZWZvcmVFeGFtcGxlXSkge1xuICAgICAgICB2YXIgYWZ0ZXJFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3snICsga2V5cy5qb2luKCc6IC4uLiwgJykgKyAnOiAuLi59JyA6ICd7fSc7XG5cbiAgICAgICAgZXJyb3IoJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbicgKyAnICBsZXQgcHJvcHMgPSAlcztcXG4nICsgJyAgPCVzIHsuLi5wcm9wc30gLz5cXG4nICsgJ1JlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbicgKyAnICBsZXQgcHJvcHMgPSAlcztcXG4nICsgJyAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsIGJlZm9yZUV4YW1wbGUsIGNvbXBvbmVudE5hbWUsIGFmdGVyRXhhbXBsZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NvbXBvbmVudE5hbWUgKyBiZWZvcmVFeGFtcGxlXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYgPSBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3hERVYgPSBqc3hERVY7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/YmY2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@liveblocks/core/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: function() { return /* binding */ ClientMsgCode; },\n/* harmony export */   CommentsApiError: function() { return /* binding */ CommentsApiError; },\n/* harmony export */   CrdtType: function() { return /* binding */ CrdtType; },\n/* harmony export */   LiveList: function() { return /* binding */ LiveList; },\n/* harmony export */   LiveMap: function() { return /* binding */ LiveMap; },\n/* harmony export */   LiveObject: function() { return /* binding */ LiveObject; },\n/* harmony export */   NotificationsApiError: function() { return /* binding */ NotificationsApiError; },\n/* harmony export */   OpCode: function() { return /* binding */ OpCode; },\n/* harmony export */   ServerMsgCode: function() { return /* binding */ ServerMsgCode; },\n/* harmony export */   WebsocketCloseCodes: function() { return /* binding */ WebsocketCloseCodes; },\n/* harmony export */   ackOp: function() { return /* binding */ ackOp; },\n/* harmony export */   addReaction: function() { return /* binding */ addReaction; },\n/* harmony export */   applyOptimisticUpdates: function() { return /* binding */ applyOptimisticUpdates; },\n/* harmony export */   asPos: function() { return /* binding */ asPos; },\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   assertNever: function() { return /* binding */ assertNever; },\n/* harmony export */   b64decode: function() { return /* binding */ b64decode; },\n/* harmony export */   cloneLson: function() { return /* binding */ cloneLson; },\n/* harmony export */   console: function() { return /* binding */ fancy_console_exports; },\n/* harmony export */   convertToCommentData: function() { return /* binding */ convertToCommentData; },\n/* harmony export */   convertToCommentUserReaction: function() { return /* binding */ convertToCommentUserReaction; },\n/* harmony export */   convertToThreadData: function() { return /* binding */ convertToThreadData; },\n/* harmony export */   createClient: function() { return /* binding */ createClient; },\n/* harmony export */   deleteComment: function() { return /* binding */ deleteComment; },\n/* harmony export */   deprecate: function() { return /* binding */ deprecate; },\n/* harmony export */   deprecateIf: function() { return /* binding */ deprecateIf; },\n/* harmony export */   detectDupes: function() { return /* binding */ detectDupes; },\n/* harmony export */   errorIf: function() { return /* binding */ errorIf; },\n/* harmony export */   freeze: function() { return /* binding */ freeze; },\n/* harmony export */   getMentionedIdsFromCommentBody: function() { return /* binding */ getMentionedIdsFromCommentBody; },\n/* harmony export */   isChildCrdt: function() { return /* binding */ isChildCrdt; },\n/* harmony export */   isJsonArray: function() { return /* binding */ isJsonArray; },\n/* harmony export */   isJsonObject: function() { return /* binding */ isJsonObject; },\n/* harmony export */   isJsonScalar: function() { return /* binding */ isJsonScalar; },\n/* harmony export */   isLiveNode: function() { return /* binding */ isLiveNode; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   isRootCrdt: function() { return /* binding */ isRootCrdt; },\n/* harmony export */   kInternal: function() { return /* binding */ kInternal; },\n/* harmony export */   legacy_patchImmutableObject: function() { return /* binding */ legacy_patchImmutableObject; },\n/* harmony export */   lsonToJson: function() { return /* binding */ lsonToJson; },\n/* harmony export */   makeEventSource: function() { return /* binding */ makeEventSource; },\n/* harmony export */   makePoller: function() { return /* binding */ makePoller; },\n/* harmony export */   makePosition: function() { return /* binding */ makePosition; },\n/* harmony export */   nn: function() { return /* binding */ nn; },\n/* harmony export */   patchLiveObjectKey: function() { return /* binding */ patchLiveObjectKey; },\n/* harmony export */   raise: function() { return /* binding */ raise; },\n/* harmony export */   removeReaction: function() { return /* binding */ removeReaction; },\n/* harmony export */   shallow: function() { return /* binding */ shallow; },\n/* harmony export */   stringify: function() { return /* binding */ stringify; },\n/* harmony export */   stringifyCommentBody: function() { return /* binding */ stringifyCommentBody; },\n/* harmony export */   throwUsageError: function() { return /* binding */ throwUsageError; },\n/* harmony export */   toPlainLson: function() { return /* binding */ toPlainLson; },\n/* harmony export */   tryParseJson: function() { return /* binding */ tryParseJson; },\n/* harmony export */   upsertComment: function() { return /* binding */ upsertComment; },\n/* harmony export */   withTimeout: function() { return /* binding */ withTimeout; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"1.10.2\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (false) {} else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (true) {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let flagger;\n  const promise = new Promise((res) => {\n    flagger = res;\n  });\n  if (!flagger) {\n    throw new Error(\"Should never happen\");\n  }\n  return [promise, flagger];\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _onetimeObservers = /* @__PURE__ */ new Set();\n  const _observers = /* @__PURE__ */ new Set();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      notify(event);\n    }\n    _buffer = null;\n  }\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    _onetimeObservers.add(callback);\n    return () => _onetimeObservers.delete(callback);\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n    } else {\n      notify(event);\n    }\n  }\n  function notify(event) {\n    _onetimeObservers.forEach((callback) => callback(event));\n    _onetimeObservers.clear();\n    _observers.forEach((callback) => callback(event));\n  }\n  function clear() {\n    _onetimeObservers.clear();\n    _observers.clear();\n  }\n  function count() {\n    return _onetimeObservers.size + _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify: notifyOrBuffer,\n    subscribe,\n    subscribeOnce,\n    clear,\n    count,\n    waitUntil,\n    pause,\n    unpause,\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  constructor(initialContext) {\n    this.curr = initialContext;\n  }\n  get current() {\n    return this.curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.curr,\n      patch(patch) {\n        if (allowed) {\n          self.curr = Object.assign({}, self.curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get initialState() {\n    const result = this.states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.currentStateOrNull === null) {\n      if (this.runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.runningState = 1 /* STARTED */;\n    this.currentStateOrNull = this.initialState;\n    this.enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.exit(null);\n    this.runningState = 2 /* STOPPED */;\n    this.currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.runningState = 0 /* NOT_STARTED_YET */;\n    this.currentStateOrNull = null;\n    this.states = /* @__PURE__ */ new Set();\n    this.enterFns = /* @__PURE__ */ new Map();\n    this.cleanupStack = [];\n    this.knownEventTypes = /* @__PURE__ */ new Set();\n    this.allowedTransitions = /* @__PURE__ */ new Map();\n    this.currentContext = new SafeContext(initialContext);\n    this.eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n      willTransition: this.eventHub.willTransition.observable,\n      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n      willExitState: this.eventHub.willExitState.observable,\n      didEnterState: this.eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      let done = false;\n      void promiseFn(this.currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.getStatesMatching(nameOrPattern)) {\n      let map = this.allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern The state name, or state group pattern name.\n   * @param after          Number of milliseconds after which to take the\n   *                       transition. If in the mean time, another transition\n   *                       is taken, the timer will get cancelled.\n   * @param target     The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  getTargetFn(eventName) {\n    return this.allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  exit(levels) {\n    this.eventHub.willExitState.notify(this.currentState);\n    this.currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.cleanupStack.push(cleanupFn);\n        } else {\n          this.cleanupStack.push(null);\n        }\n      }\n    });\n    this.eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.transition(event, targetFn);\n    } else {\n      this.eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  transition(event, target) {\n    this.eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.exit(up);\n    }\n    this.currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.enter(down);\n    }\n  }\n};\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction newToLegacyStatus(status) {\n  switch (status) {\n    case \"connecting\":\n      return \"connecting\";\n    case \"connected\":\n      return \"open\";\n    case \"reconnecting\":\n      return \"unavailable\";\n    case \"disconnected\":\n      return \"failed\";\n    case \"initial\":\n      return \"closed\";\n    default:\n      return \"closed\";\n  }\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nvar LiveblocksError = class extends Error {\n  /** @internal */\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (code: ${event.code}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeEventSource();\n  onMessage.pause();\n  const onLiveblocksError = makeEventSource();\n  function fireErrorEvent(errmsg, errcode) {\n    return () => {\n      const err = new LiveblocksError(errmsg, errcode);\n      onLiveblocksError.notify(err);\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onLiveblocksError: onLiveblocksError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.machine = machine;\n    this.events = events;\n    this.cleanups = cleanups;\n  }\n  getLegacyStatus() {\n    return newToLegacyStatus(this.getStatus());\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.machine.stop();\n    let cleanup;\n    while (cleanup = this.cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      verifyTokenPermissions(parsed, options);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          verifyTokenPermissions(parsed, options);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  function verifyTokenPermissions(parsedToken, options) {\n    if (!options.roomId && parsedToken.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      if (Object.entries(parsedToken.parsed.perms).length === 0) {\n        return;\n      }\n      for (const [resource, scopes] of Object.entries(\n        parsedToken.parsed.perms\n      )) {\n        if (resource.includes(\"*\") && hasCorrespondingScopes(options.requestedScope, scopes)) {\n          return;\n        }\n      }\n      throw new StopRetrying(\n        \"The issued access token doesn't grant enough permissions. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/access-tokens-not-enough-permissions\"\n      );\n    }\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch2, endpoint, body) {\n  const res = await fetch2(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif ( true && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storage.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/stringify.ts\nfunction stringify(object, ...args) {\n  if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n    return JSON.stringify(object, ...args);\n  }\n  const sortedObject = Object.keys(object).sort().reduce(\n    (sortedObject2, key) => {\n      sortedObject2[key] = object[key];\n      return sortedObject2;\n    },\n    {}\n  );\n  return JSON.stringify(sortedObject, ...args);\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar DEFAULT_DELAY = 100;\nvar noop = () => {\n};\nvar BatchCall = class {\n  constructor(args) {\n    this.resolve = noop;\n    this.reject = noop;\n    this.promise = new Promise(noop);\n    this.args = args;\n  }\n};\nvar Batch = class {\n  constructor(callback, options) {\n    this.queue = [];\n    this.error = false;\n    this.callback = callback;\n    this.size = options?.size ?? DEFAULT_SIZE;\n    this.delay = options?.delay ?? DEFAULT_DELAY;\n  }\n  clearDelayTimeout() {\n    if (this.delayTimeoutId !== void 0) {\n      clearTimeout(this.delayTimeoutId);\n      this.delayTimeoutId = void 0;\n    }\n  }\n  schedule() {\n    if (this.queue.length === this.size) {\n      void this.flush();\n    } else if (this.queue.length === 1) {\n      this.clearDelayTimeout();\n      this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay);\n    }\n  }\n  async flush() {\n    if (this.queue.length === 0) {\n      return;\n    }\n    const calls = this.queue.splice(0);\n    const args = calls.map((call) => call.args);\n    try {\n      const results = await this.callback(args);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (result instanceof Error) {\n          call.reject(result);\n        } else if (result !== void 0) {\n          call.resolve(result);\n        } else {\n          if (Array.isArray(results)) {\n            call.reject(\n              new Error(\n                `Batch callback must return an array of the same length as the number of calls in the batch. Expected ${calls.length}, but got ${results.length}.`\n              )\n            );\n          } else {\n            call.reject(new Error(\"Batch callback must return an array.\"));\n          }\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(...args) {\n    const existingCall = this.queue.find(\n      (call2) => stringify(call2.args) === stringify(args)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(args);\n    call.promise = new Promise((resolve, reject) => {\n      call.resolve = resolve;\n      call.reject = reject;\n    });\n    this.queue.push(call);\n    this.schedule();\n    return call.promise;\n  }\n  clear() {\n    this.queue = [];\n    this.error = false;\n    this.clearDelayTimeout();\n  }\n};\nfunction createBatchStore(callback, options) {\n  const batch = new Batch(callback, options);\n  const cache = /* @__PURE__ */ new Map();\n  const eventSource2 = makeEventSource();\n  function getCacheKey(args) {\n    return stringify(args);\n  }\n  function setStateAndNotify(cacheKey, state) {\n    if (state) {\n      cache.set(cacheKey, state);\n    } else {\n      cache.delete(cacheKey);\n    }\n    eventSource2.notify(state);\n  }\n  async function get(...args) {\n    const cacheKey = getCacheKey(args);\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      setStateAndNotify(cacheKey, { isLoading: true });\n      const result = await batch.get(...args);\n      setStateAndNotify(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      setStateAndNotify(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getState(...args) {\n    const cacheKey = getCacheKey(args);\n    return cache.get(cacheKey);\n  }\n  return {\n    ...eventSource2,\n    get,\n    getState\n  };\n}\n\n// src/lib/create-store.ts\nfunction createStore(initialState) {\n  let state = initialState;\n  const subscribers = /* @__PURE__ */ new Set();\n  function get() {\n    return state;\n  }\n  function set(callback) {\n    const newState = callback(state);\n    if (state === newState) {\n      return;\n    }\n    state = newState;\n    for (const subscriber of subscribers) {\n      subscriber(state);\n    }\n  }\n  function subscribe(callback) {\n    subscribers.add(callback);\n    callback(state);\n    return () => {\n      subscribers.delete(callback);\n    };\n  }\n  return {\n    get,\n    set,\n    subscribe\n  };\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (true) {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (true) {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (true) {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const updatedAt = data.updatedAt ? new Date(data.updatedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url.toString();\n}\n\n// src/notifications.ts\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY = 50;\nfunction createNotificationsApi({\n  baseUrl,\n  authManager,\n  currentUserIdStore,\n  fetcher\n}) {\n  async function fetchJson(endpoint, options, params) {\n    const authValue = await authManager.getAuthValue({\n      requestedScope: \"comments:read\"\n    });\n    if (authValue.type === \"secret\" && authValue.token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      const userId = authValue.token.parsed.uid;\n      currentUserIdStore.set(() => userId);\n    }\n    const url = urljoin(baseUrl, `/v2/c${endpoint}`, params);\n    const response = await fetcher(url.toString(), {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getInboxNotifications(options) {\n    const json = await fetchJson(\"/inbox-notifications\", void 0, {\n      limit: options?.limit,\n      since: options?.since?.toISOString()\n    });\n    return {\n      threads: json.threads.map((thread) => convertToThreadData(thread)),\n      inboxNotifications: json.inboxNotifications.map(\n        (notification) => convertToInboxNotificationData(notification)\n      ),\n      deletedThreads: json.deletedThreads.map(\n        (info) => convertToThreadDeleteInfo(info)\n      ),\n      deletedInboxNotifications: json.deletedInboxNotifications.map(\n        (info) => convertToInboxNotificationDeleteInfo(info)\n      ),\n      meta: {\n        requestedAt: new Date(json.meta.requestedAt)\n      }\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await fetchJson(\"/inbox-notifications/count\");\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds: \"all\" })\n    });\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead\n  };\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  constructor() {\n    /** @internal */\n    this._parent = NoParent;\n  }\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.__pool;\n  }\n  get roomId() {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.__id;\n  }\n  /** @internal */\n  get parent() {\n    return this._parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this._parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.__id = id;\n    this.__pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this._parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this._parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.__pool = void 0;\n  }\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n      this._cachedImmutable = void 0;\n      this._cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n      this._cachedTreeNodeKey = key;\n      this._cachedTreeNode = this._toTreeNode(key);\n    }\n    return this._cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this._cachedImmutable === void 0) {\n      this._cachedImmutable = this._toImmutable();\n    }\n    return this._cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/lib/nanoid.ts\nfunction nanoid(length = 7) {\n  const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-\";\n  const len = alphabet.length;\n  return Array.from(\n    { length },\n    () => alphabet.charAt(Math.floor(Math.random() * len))\n  ).join(\"\");\n}\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  constructor(data) {\n    super();\n    this._data = data;\n  }\n  get data() {\n    return this._data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  constructor(items = []) {\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this._unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this._items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList();\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this._items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this._unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this._items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this._items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this._items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n        this._items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  /** @internal */\n  _applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this._items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        );\n        this._items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition));\n      }\n      const previousIndex = this._items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(existingItem);\n      if (newIndex !== previousIndex) {\n        delta.push(moveDelta(previousIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this._items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  /** @internal */\n  _applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  /** @internal */\n  _applyInsertAck(op) {\n    const existingItem = this._items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this._items[existingItemIndex]?._parentPos;\n      const after2 = this._items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  /** @internal */\n  _applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this._unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this._items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this._applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this._items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      this._items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _applySetChildKeyRemote(newKey, child) {\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this._items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  /** @internal */\n  _applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this._implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this._items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this._items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this._items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this._items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`\n      );\n    }\n    const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n    const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this._items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n      beforePosition = this._items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this._items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this._items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const item = this._items[index];\n    item._detach();\n    this._items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0));\n        }\n      }\n      this._items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n      this._items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const existingItem = this._items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this._items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this._items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this._items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this._items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this._items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n  /** @internal */\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  /** @internal */\n  _shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1 ? this._items[index + 1]?._parentPos : void 0\n    );\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this._items.map((node) => node.toImmutable());\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this._items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this._innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index) {\n  return {\n    index,\n    type: \"delete\"\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    index,\n    type: \"move\",\n    previousIndex,\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/lib/freeze.ts\nvar freeze =  false ? (\n  /* istanbul ignore next */\n  0\n) : Object.freeze;\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  constructor(entries2) {\n    super();\n    this.unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = /* @__PURE__ */ new Map();\n    }\n  }\n  /**\n   * @internal\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map._map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /**\n   * @internal\n   */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.unacknowledgedSet.delete(key);\n    }\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this._map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n  /**\n   * @internal\n   */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this._map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this._map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this._map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this._map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this._map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this._map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this._map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this._map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this._map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this._map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this._map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  constructor(obj = {}) {\n    super();\n    this._propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this._map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  static _buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @internal */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj._map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        this._propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === void 0) {\n    } else if (this._propToLastUpdate.get(key) === opId) {\n      this._propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this._map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this._applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  /** @internal */\n  _applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        this._propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this._map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  /** @internal */\n  _applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this._map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this._map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this._map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this._map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this._map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this._map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this._map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this._map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this._map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this._map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this._propToLastUpdate.set(key, opId);\n      }\n      this._map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this._map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList();\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n  constructor() {\n    this._ev = makeEventSource();\n  }\n  get didInvalidate() {\n    return this._ev.observable;\n  }\n  invalidate() {\n    if (this._cache !== void 0) {\n      this._cache = void 0;\n      this._ev.notify();\n    }\n  }\n  get current() {\n    return this._cache ?? (this._cache = this._toImmutable());\n  }\n};\n\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar OthersRef = class extends ImmutableRef {\n  //\n  // --------------------------------------------------------------\n  //\n  constructor() {\n    super();\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n  }\n  connectionIds() {\n    return this._connections.keys();\n  }\n  /** @internal */\n  _toImmutable() {\n    const users = compact(\n      Array.from(this._presences.keys()).map(\n        (connectionId) => this.getUser(Number(connectionId))\n      )\n    );\n    return users;\n  }\n  clearOthers() {\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n    this.invalidate();\n  }\n  /** @internal */\n  _getUser(connectionId) {\n    const conn = this._connections.get(connectionId);\n    const presence = this._presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this._users.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this._getUser(connectionId);\n    if (computedUser) {\n      this._users.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  /** @internal */\n  _invalidateUser(connectionId) {\n    if (this._users.has(connectionId)) {\n      this._users.delete(connectionId);\n    }\n    this.invalidate();\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this._connections.set(\n      connectionId,\n      freeze({\n        connectionId,\n        id: metaUserId,\n        info: metaUserInfo,\n        scopes\n      })\n    );\n    if (this._presences.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this._connections.delete(connectionId);\n    this._presences.delete(connectionId);\n    this._invalidateUser(connectionId);\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this._presences.set(connectionId, freeze(compactObject(presence)));\n    if (this._connections.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    const oldPresence = this._presences.get(connectionId);\n    if (oldPresence === void 0) {\n      return;\n    }\n    const newPresence = merge(oldPresence, patch);\n    if (oldPresence !== newPresence) {\n      this._presences.set(connectionId, freeze(newPresence));\n      this._invalidateUser(connectionId);\n    }\n  }\n};\n\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n  constructor(data) {\n    super();\n    this._data = freeze(compactObject(data));\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    const oldData = this._data;\n    const newData = merge(oldData, patch);\n    if (oldData !== newData) {\n      this._data = freeze(newData);\n      this.invalidate();\n    }\n  }\n};\n\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n  constructor(initialValue) {\n    super();\n    this._value = freeze(initialValue);\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._value;\n  }\n  set(newValue) {\n    this._value = freeze(newValue);\n    this.invalidate();\n  }\n};\nvar DerivedRef = class extends ImmutableRef {\n  constructor(...args) {\n    super();\n    const transformFn = args.pop();\n    const otherRefs = args;\n    this._refs = otherRefs;\n    this._refs.forEach((ref) => {\n      ref.didInvalidate.subscribe(() => this.invalidate());\n    });\n    this._transform = transformFn;\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._transform(\n      ...this._refs.map((ref) => ref.current)\n    );\n  }\n};\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: user\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nvar CommentsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction createCommentsApi(roomId, getAuthValue, fetchClientApi) {\n  async function fetchCommentsApi(endpoint, params, options) {\n    const authValue = await getAuthValue();\n    return fetchClientApi(roomId, endpoint, authValue, options, params);\n  }\n  async function fetchJson(endpoint, options, params) {\n    const response = await fetchCommentsApi(endpoint, params, options);\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new CommentsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new CommentsApiError(response.statusText, response.status);\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getThreads(options) {\n    const response = await fetchCommentsApi(\n      \"/threads/search\",\n      {\n        since: options?.since?.toISOString()\n      },\n      {\n        body: JSON.stringify({\n          ...options?.query?.metadata && { metadata: options.query.metadata }\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        method: \"POST\"\n      }\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        threads: json.data.map((thread) => convertToThreadData(thread)),\n        inboxNotifications: json.inboxNotifications.map(\n          (notification) => convertToInboxNotificationData(notification)\n        ),\n        deletedThreads: json.deletedThreads.map(\n          (info) => convertToThreadDeleteInfo(info)\n        ),\n        deletedInboxNotifications: json.deletedInboxNotifications.map(\n          (info) => convertToInboxNotificationDeleteInfo(info)\n        ),\n        meta: {\n          requestedAt: new Date(json.meta.requestedAt)\n        }\n      };\n    } else if (response.status === 404) {\n      return {\n        threads: [],\n        inboxNotifications: [],\n        deletedThreads: [],\n        deletedInboxNotifications: [],\n        meta: {\n          requestedAt: /* @__PURE__ */ new Date()\n        }\n      };\n    } else {\n      throw new Error(\"There was an error while getting threads.\");\n    }\n  }\n  async function getThread({ threadId }) {\n    const response = await fetchCommentsApi(\n      `/thread-with-notification/${threadId}`\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return;\n    } else {\n      throw new Error(`There was an error while getting thread ${threadId}.`);\n    }\n  }\n  async function createThread({\n    metadata,\n    body,\n    commentId,\n    threadId\n  }) {\n    const thread = await fetchJson(\n      \"/threads\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: threadId,\n          comment: {\n            id: commentId,\n            body\n          },\n          metadata\n        })\n      }\n    );\n    return convertToThreadData(thread);\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/metadata`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(metadata)\n      }\n    );\n  }\n  async function createComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: commentId,\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment2({\n    threadId,\n    commentId\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  async function addReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    const reaction = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ emoji })\n      }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions/${encodeURIComponent(emoji)}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  return {\n    getThreads,\n    getThread,\n    createThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    deleteComment: deleteComment2,\n    addReaction: addReaction2,\n    removeReaction: removeReaction2\n  };\n}\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 = 50;\nfunction createRoom(options, config) {\n  const initialPresence = typeof options.initialPresence === \"function\" ? options.initialPresence(config.roomId) : options.initialPresence;\n  const initialStorage = typeof options.initialStorage === \"function\" ? options.initialStorage(config.roomId) : options.initialStorage;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence™ update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfo: new ValueRef(null),\n    dynamicSessionInfo: new ValueRef(null),\n    myPresence: new PatchableRef(initialPresence),\n    others: new OthersRef(),\n    initialStorage,\n    idFactory: null,\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: /* @__PURE__ */ new Map(),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n  };\n  const doNotBatchUpdates = (cb) => cb();\n  const batchUpdates = config.unstable_batchedUpdates ?? doNotBatchUpdates;\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getAuthBearerHeaderFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfo.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfo.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    batchUpdates(() => {\n      eventHub.status.notify(newStatus);\n      notifySelfChanged(doNotBatchUpdates);\n    });\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        batchUpdates(() => {\n          eventHub.lostConnection.notify(\"lost\");\n          _hasLostConnection = true;\n          context.others.clearOthers();\n          notify({ others: [{ type: \"reset\" }] }, doNotBatchUpdates);\n        });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"failed\");\n          });\n        } else {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"restored\");\n          });\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.current }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onLiveblocksError.subscribe((err) => {\n    batchUpdates(() => {\n      if (true) {\n        error2(\n          `Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`\n        );\n      }\n      eventHub.error.notify(err);\n    });\n  });\n  const pool = {\n    roomId: config.roomId,\n    getNode: (id) => context.nodes.get(id),\n    addNode: (id, node) => void context.nodes.set(id, node),\n    deleteNode: (id) => void context.nodes.delete(id),\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch;\n      if (true) {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n      if (activeBatch) {\n        activeBatch.ops.push(...ops);\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        batchUpdates(() => {\n          addToUndoStack(reverse, doNotBatchUpdates);\n          context.redoStack.length = 0;\n          dispatchOps(ops);\n          notify({ storageUpdates }, doNotBatchUpdates);\n        });\n      }\n    },\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfo.current?.scopes;\n      if (scopes === void 0) {\n        return;\n      }\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n  const eventHub = {\n    connection: makeEventSource(),\n    // Old/deprecated API\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    error: makeEventSource(),\n    storage: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource()\n  };\n  async function fetchClientApi(roomId, endpoint, authValue, options2, params) {\n    const url = urljoin(\n      config.baseUrl,\n      `/v2/c/rooms/${encodeURIComponent(roomId)}${endpoint}`,\n      params\n    );\n    const fetcher = config.polyfills?.fetch || /* istanbul ignore next */\n    fetch;\n    return await fetcher(url, {\n      ...options2,\n      headers: {\n        ...options2?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n  }\n  async function streamFetch(authValue, roomId) {\n    return fetchClientApi(roomId, \"/storage\", authValue, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n  }\n  async function httpPostToRoom(endpoint, body) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(config.roomId, endpoint, managedSocket.authValue, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body)\n    });\n  }\n  function sendMessages(messages) {\n    const serializedPayload = JSON.stringify(messages);\n    const nonce = context.dynamicSessionInfo.current?.nonce;\n    if (config.unstable_fallbackToHTTP && nonce) {\n      const size = new TextEncoder().encode(serializedPayload).length;\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\n        void httpPostToRoom(\"/send-message\", { nonce, messages }).then(\n          (resp) => {\n            if (!resp.ok && resp.status === 403) {\n              managedSocket.reconnect();\n            }\n          }\n        );\n        warn(\n          \"Message was too large for websockets and sent over HTTP instead\"\n        );\n        return;\n      }\n    }\n    managedSocket.send(serializedPayload);\n  }\n  const self = new DerivedRef(\n    context.staticSessionInfo,\n    context.dynamicSessionInfo,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes),\n          isReadOnly: !canWrite\n          // Deprecated, kept for backward-compatibility\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged(batchedUpdatesWrapper) {\n    const currSelf = self.current;\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      batchedUpdatesWrapper(() => {\n        eventHub.self.notify(currSelf);\n      });\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = new DerivedRef(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items, batchedUpdatesWrapper);\n    } else {\n      context.root = LiveObject._fromItems(message.items, pool);\n    }\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        context.root.set(key, cloneLson(context.initialStorage[key]));\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items, batchedUpdatesWrapper) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates, batchedUpdatesWrapper);\n  }\n  function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange(batchedUpdatesWrapper);\n  }\n  function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.unshift(...historyOps);\n    } else {\n      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n    }\n  }\n  function notify(updates, batchedUpdatesWrapper) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    batchedUpdatesWrapper(() => {\n      if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n        const others = context.others.current;\n        for (const event of othersUpdates) {\n          eventHub.others.notify({ ...event, others });\n        }\n      }\n      if (updates.presence ?? false) {\n        notifySelfChanged(doNotBatchUpdates);\n        eventHub.myPresence.notify(context.myPresence.current);\n      }\n      if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n        const updates2 = Array.from(storageUpdates.values());\n        eventHub.storage.notify(updates2);\n      }\n      notifyStorageStatus();\n    });\n  }\n  function getConnectionId() {\n    const info = context.dynamicSessionInfo.current;\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: [],\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.unshift(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (true) {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.unshift(...applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: output.reverse,\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.current[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.unshift({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      batchUpdates(() => {\n        if (options2?.addToHistory) {\n          addToUndoStack(\n            [{ type: \"presence\", data: oldValues }],\n            doNotBatchUpdates\n          );\n        }\n        notify({ presence: true }, doNotBatchUpdates);\n      });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message, batchedUpdatesWrapper) {\n    context.dynamicSessionInfo.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged(batchedUpdatesWrapper);\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange(batchedUpdatesWrapper) {\n    batchedUpdatesWrapper(() => {\n      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n    });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.current,\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const ops = Array.from(offlineOps.values());\n    const result = applyOps(ops, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates, batchedUpdatesWrapper);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    batchUpdates(() => {\n      for (const message of messages) {\n        switch (message.type) {\n          case 101 /* USER_JOINED */: {\n            const userJoinedUpdate = onUserJoinedMessage(message);\n            if (userJoinedUpdate) {\n              updates.others.push(userJoinedUpdate);\n            }\n            break;\n          }\n          case 100 /* UPDATE_PRESENCE */: {\n            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n            if (othersPresenceUpdate) {\n              updates.others.push(othersPresenceUpdate);\n            }\n            break;\n          }\n          case 103 /* BROADCASTED_EVENT */: {\n            const others = context.others.current;\n            eventHub.customEvent.notify({\n              connectionId: message.actor,\n              user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n              event: message.event\n            });\n            break;\n          }\n          case 102 /* USER_LEFT */: {\n            const event2 = onUserLeftMessage(message);\n            if (event2) {\n              updates.others.push(event2);\n            }\n            break;\n          }\n          case 300 /* UPDATE_YDOC */: {\n            eventHub.ydoc.notify(message);\n            break;\n          }\n          case 104 /* ROOM_STATE */: {\n            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n            break;\n          }\n          case 200 /* INITIAL_STORAGE_STATE */: {\n            processInitialStorage(message);\n            break;\n          }\n          case 201 /* UPDATE_STORAGE */: {\n            const applyResult = applyOps(message.ops, false);\n            for (const [key, value] of applyResult.updates.storageUpdates) {\n              updates.storageUpdates.set(\n                key,\n                mergeStorageUpdates(updates.storageUpdates.get(key), value)\n              );\n            }\n            break;\n          }\n          case 299 /* REJECT_STORAGE_OP */: {\n            errorWithTitle(\n              \"Storage mutation rejection error\",\n              message.reason\n            );\n            if (true) {\n              const traces = /* @__PURE__ */ new Set();\n              for (const opId of message.opIds) {\n                const trace = context.opStackTraces?.get(opId);\n                if (trace) {\n                  traces.add(trace);\n                }\n              }\n              if (traces.size > 0) {\n                warnWithTitle(\n                  \"The following function calls caused the rejected storage mutations:\",\n                  `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n                );\n              }\n              throw new Error(\n                `Storage mutations rejected by server: ${message.reason}`\n              );\n            }\n            break;\n          }\n          case 400 /* THREAD_CREATED */:\n          case 401 /* THREAD_METADATA_UPDATED */:\n          case 405 /* COMMENT_REACTION_ADDED */:\n          case 406 /* COMMENT_REACTION_REMOVED */:\n          case 402 /* COMMENT_CREATED */:\n          case 403 /* COMMENT_EDITED */:\n          case 404 /* COMMENT_DELETED */: {\n            eventHub.comments.notify(message);\n            break;\n          }\n        }\n      }\n      notify(updates, doNotBatchUpdates);\n    });\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence™ update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    context.buffer.storageOperations.push(...ops);\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n    applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) {\n      return;\n    }\n    const result = await streamFetch(managedSocket.authValue, config.roomId);\n    const items = await result.json();\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.redoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.undoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    batchUpdates(() => {\n      context.activeBatch = {\n        ops: [],\n        updates: {\n          storageUpdates: /* @__PURE__ */ new Map(),\n          presence: false,\n          others: []\n        },\n        reverseOps: []\n      };\n      try {\n        returnValue = callback();\n      } finally {\n        const currentBatch = context.activeBatch;\n        context.activeBatch = null;\n        if (currentBatch.reverseOps.length > 0) {\n          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n        }\n        if (currentBatch.ops.length > 0) {\n          context.redoStack.length = 0;\n        }\n        if (currentBatch.ops.length > 0) {\n          dispatchOps(currentBatch.ops);\n        }\n        notify(currentBatch.updates, doNotBatchUpdates);\n        flushNowOrSoon();\n      }\n    });\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = [];\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(historyOps, batchUpdates);\n    }\n  }\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n  }\n  const others_forDevTools = new DerivedRef(\n    context.others,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    error: eventHub.error.observable,\n    storage: eventHub.storage.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable\n  };\n  const commentsApi = createCommentsApi(\n    config.roomId,\n    delegates.authenticate,\n    fetchClientApi\n  );\n  async function fetchNotificationsJson(endpoint, options2) {\n    const authValue = await delegates.authenticate();\n    const response = await fetchClientApi(\n      config.roomId,\n      endpoint,\n      authValue,\n      options2\n    );\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  function getRoomNotificationSettings() {\n    return fetchNotificationsJson(\n      \"/notification-settings\"\n    );\n  }\n  function updateRoomNotificationSettings(settings) {\n    return fetchNotificationsJson(\n      \"/notification-settings\",\n      {\n        method: \"POST\",\n        body: JSON.stringify(settings),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchNotificationsJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.nodes.size;\n        },\n        // prettier-ignore\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.current,\n        getOthers_forDevTools: () => others_forDevTools.current,\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        comments: {\n          ...commentsApi\n        },\n        notifications: {\n          getRoomNotificationSettings,\n          updateRoomNotificationSettings,\n          markInboxNotificationAsRead\n        }\n      },\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(events),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getConnectionState: () => managedSocket.getLegacyStatus(),\n      getSelf: () => self.current,\n      // Presence\n      getPresence: () => context.myPresence.current,\n      getOthers: () => context.others.current\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(events) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storage.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storage.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\":\n          return events.error.subscribe(callback);\n        case \"connection\": {\n          const cb = callback;\n          return events.status.subscribe(\n            (status) => cb(newToLegacyStatus(status))\n          );\n        }\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storage.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url = new URL(baseUrl);\n    url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url.pathname = \"/v7\";\n    url.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url.toString());\n  };\n}\n\n// src/store.ts\nfunction createClientStore() {\n  const store = createStore({\n    threads: {},\n    queries: {},\n    optimisticUpdates: [],\n    inboxNotifications: {},\n    notificationSettings: {}\n  });\n  return {\n    ...store,\n    deleteThread(threadId) {\n      store.set((state) => {\n        return {\n          ...state,\n          threads: deleteKeyImmutable(state.threads, threadId),\n          inboxNotifications: Object.fromEntries(\n            Object.entries(state.inboxNotifications).filter(\n              ([_id, notification]) => notification.threadId !== threadId\n            )\n          )\n        };\n      });\n    },\n    updateThreadAndNotification(thread, inboxNotification) {\n      store.set((state) => {\n        const existingThread = state.threads[thread.id];\n        return {\n          ...state,\n          threads: existingThread === void 0 || compareThreads(thread, existingThread) === 1 ? { ...state.threads, [thread.id]: thread } : state.threads,\n          inboxNotifications: inboxNotification === void 0 ? state.inboxNotifications : {\n            ...state.inboxNotifications,\n            [inboxNotification.id]: inboxNotification\n          }\n        };\n      });\n    },\n    updateThreadsAndNotifications(threads, inboxNotifications, deletedThreads, deletedInboxNotifications, queryKey) {\n      store.set((state) => ({\n        ...state,\n        threads: applyThreadUpdates(state.threads, {\n          newThreads: threads,\n          deletedThreads\n        }),\n        inboxNotifications: applyNotificationsUpdates(\n          state.inboxNotifications,\n          {\n            newInboxNotifications: inboxNotifications,\n            deletedNotifications: deletedInboxNotifications\n          }\n        ),\n        queries: queryKey !== void 0 ? {\n          ...state.queries,\n          [queryKey]: {\n            isLoading: false\n          }\n        } : state.queries\n      }));\n    },\n    updateRoomInboxNotificationSettings(roomId, settings, queryKey) {\n      store.set((state) => ({\n        ...state,\n        notificationSettings: {\n          ...state.notificationSettings,\n          [roomId]: settings\n        },\n        queries: {\n          ...state.queries,\n          [queryKey]: {\n            isLoading: false\n          }\n        }\n      }));\n    },\n    pushOptimisticUpdate(optimisticUpdate) {\n      store.set((state) => ({\n        ...state,\n        optimisticUpdates: [...state.optimisticUpdates, optimisticUpdate]\n      }));\n    },\n    setQueryState(queryKey, queryState) {\n      store.set((state) => ({\n        ...state,\n        queries: {\n          ...state.queries,\n          [queryKey]: queryState\n        }\n      }));\n    }\n  };\n}\nfunction deleteKeyImmutable(record, key) {\n  if (Object.prototype.hasOwnProperty.call(record, key)) {\n    const { [key]: _toDelete, ...rest } = record;\n    return rest;\n  }\n  return record;\n}\nfunction compareThreads(thread1, thread2) {\n  if (thread1.updatedAt && thread2.updatedAt) {\n    return thread1.updatedAt > thread2.updatedAt ? 1 : thread1.updatedAt < thread2.updatedAt ? -1 : 0;\n  } else if (thread1.updatedAt || thread2.updatedAt) {\n    return thread1.updatedAt ? 1 : -1;\n  }\n  if (thread1.createdAt > thread2.createdAt) {\n    return 1;\n  } else if (thread1.createdAt < thread2.createdAt) {\n    return -1;\n  }\n  return 0;\n}\nfunction applyOptimisticUpdates(state) {\n  const result = {\n    threads: {\n      ...state.threads\n    },\n    inboxNotifications: {\n      ...state.inboxNotifications\n    },\n    notificationSettings: {\n      ...state.notificationSettings\n    }\n  };\n  for (const optimisticUpdate of state.optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        result.threads[optimisticUpdate.thread.id] = optimisticUpdate.thread;\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        if (thread.updatedAt !== void 0 && thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n        result.threads[thread.id] = {\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata\n          }\n        };\n        break;\n      }\n      case \"create-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        const inboxNotification = Object.values(result.inboxNotifications).find(\n          (notification) => notification.threadId === thread.id\n        );\n        if (inboxNotification === void 0) {\n          break;\n        }\n        result.inboxNotifications[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt\n        };\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = deleteComment(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.deletedAt\n        );\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = addReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.reaction\n        );\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = removeReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.emoji,\n          optimisticUpdate.userId,\n          optimisticUpdate.removedAt\n        );\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        result.inboxNotifications[optimisticUpdate.inboxNotificationId] = {\n          ...state.inboxNotifications[optimisticUpdate.inboxNotificationId],\n          readAt: optimisticUpdate.readAt\n        };\n        break;\n      }\n      case \"mark-inbox-notifications-as-read\": {\n        for (const id in result.inboxNotifications) {\n          result.inboxNotifications[id] = {\n            ...result.inboxNotifications[id],\n            readAt: optimisticUpdate.readAt\n          };\n        }\n        break;\n      }\n      case \"update-notification-settings\": {\n        result.notificationSettings[optimisticUpdate.roomId] = {\n          ...result.notificationSettings[optimisticUpdate.roomId],\n          ...optimisticUpdate.settings\n        };\n      }\n    }\n  }\n  return result;\n}\nfunction applyThreadUpdates(existingThreads, updates) {\n  const updatedThreads = { ...existingThreads };\n  updates.newThreads.forEach((thread) => {\n    const existingThread = updatedThreads[thread.id];\n    if (existingThread) {\n      const result = compareThreads(existingThread, thread);\n      if (result === 1)\n        return;\n    }\n    updatedThreads[thread.id] = thread;\n  });\n  updates.deletedThreads.forEach(({ id, deletedAt }) => {\n    const existingThread = updatedThreads[id];\n    if (existingThread === void 0)\n      return;\n    existingThread.deletedAt = deletedAt;\n    existingThread.updatedAt = deletedAt;\n    existingThread.comments = [];\n  });\n  return updatedThreads;\n}\nfunction applyNotificationsUpdates(existingInboxNotifications, updates) {\n  const updatedInboxNotifications = { ...existingInboxNotifications };\n  updates.newInboxNotifications.forEach((notification) => {\n    const existingNotification = updatedInboxNotifications[notification.id];\n    if (existingNotification) {\n      const result = compareInboxNotifications(\n        existingNotification,\n        notification\n      );\n      if (result === 1)\n        return;\n    }\n    updatedInboxNotifications[notification.id] = notification;\n  });\n  updates.deletedNotifications.forEach(\n    ({ id }) => delete updatedInboxNotifications[id]\n  );\n  return updatedInboxNotifications;\n}\nfunction compareInboxNotifications(inboxNotificationA, inboxNotificationB) {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n  return 0;\n}\nfunction upsertComment(thread, comment) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  if (comment.threadId !== thread.id) {\n    warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (existingComment2) => existingComment2.id === comment.id\n  );\n  if (existingComment === void 0) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt?.getTime() || 0, comment.createdAt.getTime())\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment]\n    };\n    return updatedThread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {\n    const updatedComments = thread.comments.map(\n      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt?.getTime() || 0,\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments\n    };\n    return updatedThread;\n  }\n  return thread;\n}\nfunction deleteComment(thread, commentId, deletedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      deletedAt,\n      body: void 0\n    } : comment\n  );\n  if (!updatedComments.some((comment) => comment.deletedAt === void 0)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt,\n      comments: []\n    };\n  }\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments\n  };\n}\nfunction addReaction(thread, commentId, reaction) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: upsertReaction(comment.reactions, reaction)\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction removeReaction(thread, commentId, emoji, userId, removedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: comment.reactions.map(\n        (reaction) => reaction.emoji === emoji ? {\n          ...reaction,\n          users: reaction.users.filter((user) => user.id !== userId)\n        } : reaction\n      ).filter((reaction) => reaction.users.length > 0)\n      // Remove reactions with no users left\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction upsertReaction(reactions, reaction) {\n  const existingReaction = reactions.find(\n    (existingReaction2) => existingReaction2.emoji === reaction.emoji\n  );\n  if (existingReaction === void 0) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }]\n      }\n    ];\n  }\n  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {\n    return reactions.map(\n      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {\n        ...existingReaction2,\n        users: [...existingReaction2.users, { id: reaction.userId }]\n      } : existingReaction2\n    );\n  }\n  return reactions;\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  baseUrl || (baseUrl = process.env.LIVEBLOCKS_BASE_URL || process.env.NEXT_PUBLIC_LIVEBLOCKS_BASE_URL || process.env.VITE_LIVEBLOCKS_BASE_URL || void 0);\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction getAuthBearerHeaderFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const authManager = createAuthManager(options);\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(info) {\n    const leave = () => {\n      const self = leave;\n      if (!info.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (info.unsubs.size === 0) {\n          teardownRoom(info.room);\n        }\n      }\n    };\n    info.unsubs.add(leave);\n    return {\n      room: info.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, options2) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    deprecateIf(\n      options2.initialPresence === null || options2.initialPresence === void 0,\n      \"Please provide an initial presence value for the current user when entering the room.\"\n    );\n    const newRoom = createRoom(\n      {\n        initialPresence: options2.initialPresence ?? {},\n        initialStorage: options2.initialStorage\n      },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        unstable_batchedUpdates: options2?.unstable_batchedUpdates,\n        baseUrl,\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n        unstable_streamData: !!clientOptions.unstable_streamData\n      }\n    );\n    const newRoomInfo = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomInfo);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? options2.shouldInitiallyConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomInfo);\n  }\n  function enter(roomId, options2) {\n    const { room, leave: _ } = enterRoom(roomId, options2);\n    return room;\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function forceLeave(roomId) {\n    const unsubs = roomsById.get(roomId)?.unsubs ?? /* @__PURE__ */ new Set();\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  }\n  function logout() {\n    authManager.reset();\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const currentUserIdStore = createStore(null);\n  const {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead\n  } = createNotificationsApi({\n    baseUrl,\n    fetcher: clientOptions.polyfills?.fetch || /* istanbul ignore next */\n    fetch,\n    authManager,\n    currentUserIdStore\n  });\n  const cacheStore = createClientStore();\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const usersStore = createBatchStore(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const roomsInfoStore = createBatchStore(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  return Object.defineProperty(\n    {\n      logout,\n      // Old, deprecated APIs\n      enter,\n      getRoom,\n      leave: forceLeave,\n      // New, preferred API\n      enterRoom,\n      // Internal\n      [kInternal]: {\n        notifications: {\n          getInboxNotifications,\n          getUnreadInboxNotificationsCount,\n          markAllInboxNotificationsAsRead,\n          markInboxNotificationAsRead\n        },\n        currentUserIdStore,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        cacheStore,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        }\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n}\nvar NotificationsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0)\n    return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (true) {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {}\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyText(element) {\n  return \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values) {\n  return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values) {\n  return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url) {\n  if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return url;\n  } else if (url.startsWith(\"www.\")) {\n    return \"https://\" + url;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (true) {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/Poller.ts\nfunction makePoller(callback) {\n  let context = {\n    state: \"stopped\",\n    timeoutHandle: null,\n    interval: null,\n    lastScheduledAt: null,\n    remainingInterval: null\n  };\n  function poll() {\n    if (context.state === \"running\") {\n      schedule(context.interval);\n    }\n    void callback();\n  }\n  function schedule(interval) {\n    context = {\n      state: \"running\",\n      interval: context.state !== \"stopped\" ? context.interval : interval,\n      lastScheduledAt: performance.now(),\n      timeoutHandle: setTimeout(poll, interval),\n      remainingInterval: null\n    };\n  }\n  function scheduleRemaining(remaining) {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    context = {\n      state: \"running\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: setTimeout(poll, remaining),\n      remainingInterval: null\n    };\n  }\n  function start(interval) {\n    if (context.state === \"running\") {\n      return;\n    }\n    schedule(interval);\n  }\n  function restart(interval) {\n    stop();\n    start(interval);\n  }\n  function pause() {\n    if (context.state !== \"running\") {\n      return;\n    }\n    clearTimeout(context.timeoutHandle);\n    context = {\n      state: \"paused\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: null,\n      remainingInterval: context.interval - (performance.now() - context.lastScheduledAt)\n    };\n  }\n  function resume() {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    scheduleRemaining(context.remainingInterval);\n  }\n  function stop() {\n    if (context.state === \"stopped\") {\n      return;\n    }\n    if (context.timeoutHandle) {\n      clearTimeout(context.timeoutHandle);\n    }\n    context = {\n      state: \"stopped\",\n      interval: null,\n      lastScheduledAt: null,\n      timeoutHandle: null,\n      remainingInterval: null\n    };\n  }\n  return {\n    start,\n    restart,\n    pause,\n    resume,\n    stop\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null || Object.prototype.toString.call(objA) !== \"[object Object]\" || Object.prototype.toString.call(objB) !== \"[object Object]\") {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9jb3JlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCLEdBQUcsVUFBVTtBQUN4RTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSjtBQUNBLHFHQUFxRyxrQkFBa0I7QUFDdkg7QUFDQTtBQUNBLFdBQVcsU0FBUyxFQUFFLFVBQVU7QUFDaEMsV0FBVyxTQUFTLEVBQUUsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsd0JBQXdCO0FBQzNHO0FBQ0E7QUFDQSxhQUFhLFVBQVUsUUFBUSxZQUFZO0FBQzNDLGFBQWEsU0FBUyxRQUFRLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0MscUJBQXFCLFdBQVcsZ0JBQWdCLHVCQUF1QixnQkFBZ0I7QUFDdkg7QUFDQTtBQUNBLDBDQUEwQyxhQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFvQjtBQUM5RDtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOEJBQThCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUssUUFBUSxTQUFTLFVBQVUsY0FBYztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQSwwQ0FBMEMsK0JBQStCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixtREFBbUQsNEZBQTRGO0FBQy9JO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlJQUFpSSxjQUFjO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQkFBc0IscUVBQXFFLEdBQUcsWUFBWSxtQkFBbUIsU0FBUztBQUN0STtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JELE1BQU07QUFDTixpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0VBQWdFLFNBQVMsS0FBSztBQUM5RTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjLG1DQUFtQyxTQUFTLGFBQWE7QUFDdkg7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGdCQUFnQix5QkFBeUIsSUFBSSxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUyxHQUFHLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBcUM7QUFDM0M7QUFDQTtBQUNBLGdCQUFnQix3REFBd0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx3SEFBd0gsYUFBYSxZQUFZLGVBQWU7QUFDaEs7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBLG9DQUFvQyxnQ0FBZ0M7QUFDcEUsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0Q0FBNEM7QUFDN0U7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0I7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLE1BQU0sUUFBUTtBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQixJQUFJO0FBQzVELFFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTSxtQ0FBbUMsbUJBQW1CO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNLG1DQUFtQyx1QkFBdUI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNLG1DQUFtQyx1QkFBdUI7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBcUMsR0FBRyxDQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsYUFBYSxNQUFxQztBQUNsRDtBQUNBLEVBQUUsQ0FBUTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELCtCQUErQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ04sZUFBZTtBQUNmO0FBQ0E7QUFDQTtB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RDtBQUM5RSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxxQkFBcUIsT0FBTyxHQUFHLEtBQUs7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFxQyxHQUFHLENBQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYSxHQUFHLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsU0FBUztBQUNU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NEM7QUFDN0U7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlC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QUFNO0FBQ04sc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLHNCQUFzQjtBQUNuRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxzQ0FBc0M7QUFDbkg7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9DQUFvQyxlQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZLDRCQUE0QixVQUFVO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEIsWUFBWTtBQUNsRTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUF5REU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4Lm1qcz84MWJlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMS4xMC4yXCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9kdXBlLWRldGVjdGlvbi50c1xudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9O1xudmFyIGNyb3NzTGlua2VkRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2Nyb3NzLWxpbmtlZFwiO1xudmFyIGR1cGVzRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2R1cGVzXCI7XG52YXIgU1BBQ0UgPSBcIiBcIjtcbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtc2cpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlY3REdXBlcyhwa2dOYW1lLCBwa2dWZXJzaW9uLCBwa2dGb3JtYXQpIHtcbiAgY29uc3QgcGtnSWQgPSBTeW1ib2wuZm9yKHBrZ05hbWUpO1xuICBjb25zdCBwa2dCdWlsZEluZm8gPSBwa2dGb3JtYXQgPyBgJHtwa2dWZXJzaW9uIHx8IFwiZGV2XCJ9ICgke3BrZ0Zvcm1hdH0pYCA6IHBrZ1ZlcnNpb24gfHwgXCJkZXZcIjtcbiAgaWYgKCFnW3BrZ0lkXSkge1xuICAgIGdbcGtnSWRdID0gcGtnQnVpbGRJbmZvO1xuICB9IGVsc2UgaWYgKGdbcGtnSWRdID09PSBwa2dCdWlsZEluZm8pIHtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtc2cgPSBbXG4gICAgICBgTXVsdGlwbGUgY29waWVzIG9mIExpdmVibG9ja3MgYXJlIGJlaW5nIGxvYWRlZCBpbiB5b3VyIHByb2plY3QuIFRoaXMgd2lsbCBjYXVzZSBpc3N1ZXMhIFNlZSAke2R1cGVzRG9jcyArIFNQQUNFfWAsXG4gICAgICBcIlwiLFxuICAgICAgXCJDb25mbGljdHM6XCIsXG4gICAgICBgLSAke3BrZ05hbWV9ICR7Z1twa2dJZF19IChhbHJlYWR5IGxvYWRlZClgLFxuICAgICAgYC0gJHtwa2dOYW1lfSAke3BrZ0J1aWxkSW5mb30gKHRyeWluZyB0byBsb2FkIHRoaXMgbm93KWBcbiAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgZXJyb3IobXNnKTtcbiAgfVxuICBpZiAocGtnVmVyc2lvbiAmJiBQS0dfVkVSU0lPTiAmJiBwa2dWZXJzaW9uICE9PSBQS0dfVkVSU0lPTikge1xuICAgIGVycm9yKFxuICAgICAgW1xuICAgICAgICBgQ3Jvc3MtbGlua2VkIHZlcnNpb25zIG9mIExpdmVibG9ja3MgZm91bmQsIHdoaWNoIHdpbGwgY2F1c2UgaXNzdWVzISBTZWUgJHtjcm9zc0xpbmtlZERvY3MgKyBTUEFDRX1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkNvbmZsaWN0czpcIixcbiAgICAgICAgYC0gJHtQS0dfTkFNRX0gaXMgYXQgJHtQS0dfVkVSU0lPTn1gLFxuICAgICAgICBgLSAke3BrZ05hbWV9IGlzIGF0ICR7cGtnVmVyc2lvbn1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkFsd2F5cyB1cGdyYWRlIGFsbCBMaXZlYmxvY2tzIHBhY2thZ2VzIHRvIHRoZSBzYW1lIHZlcnNpb24gbnVtYmVyLlwiXG4gICAgICBdLmpvaW4oXCJcXG5cIilcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9saWIvYXNzZXJ0LnRzXG5mdW5jdGlvbiBhc3NlcnROZXZlcihfdmFsdWUsIGVycm1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IoZXJybXNnKTtcbn1cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIGVycm1zZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihlcnJtc2cpO1xuICAgICAgZXJyLm5hbWUgPSBcIkFzc2VydGlvbiBmYWlsdXJlXCI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBubih2YWx1ZSwgZXJybXNnID0gXCJFeHBlY3RlZCB2YWx1ZSB0byBiZSBub24tbnVsbGFibGVcIikge1xuICBhc3NlcnQodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCwgZXJybXNnKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBzcmMvbGliL2NvbnRyb2xsZWRQcm9taXNlLnRzXG5mdW5jdGlvbiBjb250cm9sbGVkUHJvbWlzZSgpIHtcbiAgbGV0IGZsYWdnZXI7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgZmxhZ2dlciA9IHJlcztcbiAgfSk7XG4gIGlmICghZmxhZ2dlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBuZXZlciBoYXBwZW5cIik7XG4gIH1cbiAgcmV0dXJuIFtwcm9taXNlLCBmbGFnZ2VyXTtcbn1cblxuLy8gc3JjL2xpYi9FdmVudFNvdXJjZS50c1xuZnVuY3Rpb24gbWFrZUV2ZW50U291cmNlKCkge1xuICBjb25zdCBfb25ldGltZU9ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IF9vYnNlcnZlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgX2J1ZmZlciA9IG51bGw7XG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIF9idWZmZXIgPSBbXTtcbiAgfVxuICBmdW5jdGlvbiB1bnBhdXNlKCkge1xuICAgIGlmIChfYnVmZmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgX2J1ZmZlcikge1xuICAgICAgbm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gICAgX2J1ZmZlciA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgX29ic2VydmVycy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiBfb2JzZXJ2ZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlT25jZShjYWxsYmFjaykge1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IF9vbmV0aW1lT2JzZXJ2ZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsKHByZWRpY2F0ZSkge1xuICAgIGxldCB1bnN1YjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgdW5zdWIgPSBzdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUgPT09IHZvaWQgMCB8fCBwcmVkaWNhdGUoZXZlbnQpKSB7XG4gICAgICAgICAgcmVzKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB1bnN1Yj8uKCkpO1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeU9yQnVmZmVyKGV2ZW50KSB7XG4gICAgaWYgKF9idWZmZXIgIT09IG51bGwpIHtcbiAgICAgIF9idWZmZXIucHVzaChldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeShldmVudCkge1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhldmVudCkpO1xuICAgIF9vbmV0aW1lT2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgX29ic2VydmVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soZXZlbnQpKTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBfb25ldGltZU9ic2VydmVycy5jbGVhcigpO1xuICAgIF9vYnNlcnZlcnMuY2xlYXIoKTtcbiAgfVxuICBmdW5jdGlvbiBjb3VudCgpIHtcbiAgICByZXR1cm4gX29uZXRpbWVPYnNlcnZlcnMuc2l6ZSArIF9vYnNlcnZlcnMuc2l6ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC8vIFByaXZhdGUvaW50ZXJuYWwgY29udHJvbCBvdmVyIGV2ZW50IGVtaXNzaW9uXG4gICAgbm90aWZ5OiBub3RpZnlPckJ1ZmZlcixcbiAgICBzdWJzY3JpYmUsXG4gICAgc3Vic2NyaWJlT25jZSxcbiAgICBjbGVhcixcbiAgICBjb3VudCxcbiAgICB3YWl0VW50aWwsXG4gICAgcGF1c2UsXG4gICAgdW5wYXVzZSxcbiAgICAvLyBQdWJsaWNseSBleHBvc2FibGUgc3Vic2NyaXB0aW9uIEFQSVxuICAgIG9ic2VydmFibGU6IHtcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIHN1YnNjcmliZU9uY2UsXG4gICAgICB3YWl0VW50aWxcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvZmFuY3ktY29uc29sZS50c1xudmFyIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZmFuY3lfY29uc29sZV9leHBvcnRzLCB7XG4gIGVycm9yOiAoKSA9PiBlcnJvcjIsXG4gIGVycm9yV2l0aFRpdGxlOiAoKSA9PiBlcnJvcldpdGhUaXRsZSxcbiAgd2FybjogKCkgPT4gd2FybixcbiAgd2FybldpdGhUaXRsZTogKCkgPT4gd2FybldpdGhUaXRsZVxufSk7XG52YXIgYmFkZ2UgPSBcImJhY2tncm91bmQ6IzBlMGQxMjtib3JkZXItcmFkaXVzOjk5OTlweDtjb2xvcjojZmZmO3BhZGRpbmc6M3B4IDdweDtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjYwMDtcIjtcbnZhciBib2xkID0gXCJmb250LXdlaWdodDo2MDBcIjtcbmZ1bmN0aW9uIHdyYXAobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIChtZXNzYWdlLCAuLi5hcmdzKSA9PiBjb25zb2xlW21ldGhvZF0oXCIlY0xpdmVibG9ja3NcIiwgYmFkZ2UsIG1lc3NhZ2UsIC4uLmFyZ3MpXG4gICk7XG59XG52YXIgd2FybiA9IHdyYXAoXCJ3YXJuXCIpO1xudmFyIGVycm9yMiA9IHdyYXAoXCJlcnJvclwiKTtcbmZ1bmN0aW9uIHdyYXBXaXRoVGl0bGUobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICh0aXRsZSwgbWVzc2FnZSwgLi4uYXJncykgPT4gY29uc29sZVttZXRob2RdKFxuICAgICAgYCVjTGl2ZWJsb2NrcyVjICR7dGl0bGV9YCxcbiAgICAgIGJhZGdlLFxuICAgICAgYm9sZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICAuLi5hcmdzXG4gICAgKVxuICApO1xufVxudmFyIHdhcm5XaXRoVGl0bGUgPSB3cmFwV2l0aFRpdGxlKFwid2FyblwiKTtcbnZhciBlcnJvcldpdGhUaXRsZSA9IHdyYXBXaXRoVGl0bGUoXCJlcnJvclwiKTtcblxuLy8gc3JjL2xpYi9mc20udHNcbmZ1bmN0aW9uIGRpc3RhbmNlKHN0YXRlMSwgc3RhdGUyKSB7XG4gIGlmIChzdGF0ZTEgPT09IHN0YXRlMikge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgY29uc3QgY2h1bmtzMSA9IHN0YXRlMS5zcGxpdChcIi5cIik7XG4gIGNvbnN0IGNodW5rczIgPSBzdGF0ZTIuc3BsaXQoXCIuXCIpO1xuICBjb25zdCBtaW5MZW4gPSBNYXRoLm1pbihjaHVua3MxLmxlbmd0aCwgY2h1bmtzMi5sZW5ndGgpO1xuICBsZXQgc2hhcmVkID0gMDtcbiAgZm9yICg7IHNoYXJlZCA8IG1pbkxlbjsgc2hhcmVkKyspIHtcbiAgICBpZiAoY2h1bmtzMVtzaGFyZWRdICE9PSBjaHVua3MyW3NoYXJlZF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCB1cCA9IGNodW5rczEubGVuZ3RoIC0gc2hhcmVkO1xuICBjb25zdCBkb3duID0gY2h1bmtzMi5sZW5ndGggLSBzaGFyZWQ7XG4gIHJldHVybiBbdXAsIGRvd25dO1xufVxuZnVuY3Rpb24gcGF0dGVybnModGFyZ2V0U3RhdGUsIGxldmVscykge1xuICBjb25zdCBwYXJ0cyA9IHRhcmdldFN0YXRlLnNwbGl0KFwiLlwiKTtcbiAgaWYgKGxldmVscyA8IDEgfHwgbGV2ZWxzID4gcGFydHMubGVuZ3RoICsgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIGxldmVsc1wiKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKGxldmVscyA+IHBhcnRzLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wdXNoKFwiKlwiKTtcbiAgfVxuICBmb3IgKGxldCBpID0gcGFydHMubGVuZ3RoIC0gbGV2ZWxzICsgMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2xpY2UgPSBwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnB1c2goc2xpY2Uuam9pbihcIi5cIikgKyBcIi4qXCIpO1xuICAgIH1cbiAgfVxuICByZXN1bHQucHVzaCh0YXJnZXRTdGF0ZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgU2FmZUNvbnRleHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxDb250ZXh0KSB7XG4gICAgdGhpcy5jdXJyID0gaW5pdGlhbENvbnRleHQ7XG4gIH1cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycjtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHBhdGNoaW5nIG9mIHRoZSBjb250ZXh0LCBieVxuICAgKiBjYWxsaW5nIGBjb250ZXh0LnBhdGNoKClgLiBQYXRjaGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIHRoZSBkdXJhdGlvblxuICAgKiBvZiB0aGlzIHdpbmRvdy5cbiAgICovXG4gIGFsbG93UGF0Y2hpbmcoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgYWxsb3dlZCA9IHRydWU7XG4gICAgY29uc3QgcGF0Y2hhYmxlQ29udGV4dCA9IHtcbiAgICAgIC4uLnRoaXMuY3VycixcbiAgICAgIHBhdGNoKHBhdGNoKSB7XG4gICAgICAgIGlmIChhbGxvd2VkKSB7XG4gICAgICAgICAgc2VsZi5jdXJyID0gT2JqZWN0LmFzc2lnbih7fSwgc2VsZi5jdXJyLCBwYXRjaCk7XG4gICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIE9iamVjdC5lbnRyaWVzKHBhdGNoKSkge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gcGFpcjtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IFwicGF0Y2hcIikge1xuICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vIGxvbmdlciBwYXRjaCBzdGFsZSBjb250ZXh0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjYWxsYmFjayhwYXRjaGFibGVDb250ZXh0KTtcbiAgICBhbGxvd2VkID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG59O1xudmFyIG5leHRJZCA9IDE7XG52YXIgRlNNID0gY2xhc3Mge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5pdGlhbCBzdGF0ZSwgd2hpY2ggaXMgZGVmaW5lZCBieSB0aGUgZmlyc3QgY2FsbCBtYWRlIHRvXG4gICAqIC5hZGRTdGF0ZSgpLlxuICAgKi9cbiAgZ2V0IGluaXRpYWxTdGF0ZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnN0YXRlcy52YWx1ZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCkubmV4dCgpO1xuICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3RhdGVzIGRlZmluZWQgeWV0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfVxuICBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbCA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucnVubmluZ1N0YXRlID09PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3RhcnRlZCB5ZXRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0b3BwZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbDtcbiAgfVxuICAvKipcbiAgICogU3RhcnRzIHRoZSBtYWNoaW5lIGJ5IGVudGVyaW5nIHRoZSBpbml0aWFsIHN0YXRlLlxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgbWFjaGluZSBoYXMgYWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLnJ1bm5pbmdTdGF0ZSA9IDEgLyogU1RBUlRFRCAqLztcbiAgICB0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbCA9IHRoaXMuaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMuZW50ZXIobnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSBzdGF0ZSBtYWNoaW5lLiBTdG9wcGluZyB0aGUgc3RhdGUgbWFjaGluZSB3aWxsIGNhbGwgZXhpdFxuICAgKiBoYW5kbGVycyBmb3IgdGhlIGN1cnJlbnQgc3RhdGUsIGJ1dCBub3QgZW50ZXIgYSBuZXcgc3RhdGUuXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMSAvKiBTVEFSVEVEICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3RvcCBhIHN0YXRlIG1hY2hpbmUgdGhhdCBoYXNuJ3Qgc3RhcnRlZCB5ZXRcIik7XG4gICAgfVxuICAgIHRoaXMuZXhpdChudWxsKTtcbiAgICB0aGlzLnJ1bm5pbmdTdGF0ZSA9IDIgLyogU1RPUFBFRCAqLztcbiAgICB0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbCA9IG51bGw7XG4gIH1cbiAgY29uc3RydWN0b3IoaW5pdGlhbENvbnRleHQpIHtcbiAgICB0aGlzLmlkID0gbmV4dElkKys7XG4gICAgdGhpcy5ydW5uaW5nU3RhdGUgPSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLztcbiAgICB0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbCA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuZW50ZXJGbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY2xlYW51cFN0YWNrID0gW107XG4gICAgdGhpcy5rbm93bkV2ZW50VHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuYWxsb3dlZFRyYW5zaXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0gbmV3IFNhZmVDb250ZXh0KGluaXRpYWxDb250ZXh0KTtcbiAgICB0aGlzLmV2ZW50SHViID0ge1xuICAgICAgZGlkUmVjZWl2ZUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIHdpbGxUcmFuc2l0aW9uOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIGRpZElnbm9yZUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIHdpbGxFeGl0U3RhdGU6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgZGlkRW50ZXJTdGF0ZTogbWFrZUV2ZW50U291cmNlKClcbiAgICB9O1xuICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgZGlkUmVjZWl2ZUV2ZW50OiB0aGlzLmV2ZW50SHViLmRpZFJlY2VpdmVFdmVudC5vYnNlcnZhYmxlLFxuICAgICAgd2lsbFRyYW5zaXRpb246IHRoaXMuZXZlbnRIdWIud2lsbFRyYW5zaXRpb24ub2JzZXJ2YWJsZSxcbiAgICAgIGRpZElnbm9yZUV2ZW50OiB0aGlzLmV2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm9ic2VydmFibGUsXG4gICAgICB3aWxsRXhpdFN0YXRlOiB0aGlzLmV2ZW50SHViLndpbGxFeGl0U3RhdGUub2JzZXJ2YWJsZSxcbiAgICAgIGRpZEVudGVyU3RhdGU6IHRoaXMuZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5vYnNlcnZhYmxlXG4gICAgfTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50Q29udGV4dC5jdXJyZW50O1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmUgYW4gZXhwbGljaXQgZmluaXRlIHN0YXRlIGluIHRoZSBzdGF0ZSBtYWNoaW5lLlxuICAgKi9cbiAgYWRkU3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVzLmFkZChzdGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb25FbnRlcihuYW1lT3JQYXR0ZXJuLCBlbnRlckZuKSB7XG4gICAgaWYgKHRoaXMucnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lbnRlckZucy5oYXMobmFtZU9yUGF0dGVybikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgLy8gVE9ETyBXZSBfY3VycmVudGx5XyBkb24ndCBzdXBwb3J0IG11bHRpcGxlIC5vbkVudGVycygpIGZvciB0aGUgc2FtZVxuICAgICAgICAvLyBzdGF0ZSwgYnV0IHRoaXMgaXMgbm90IGEgZnVuZGFtZW50YWwgbGltaXRhdGlvbi4gSnVzdCBub3RcbiAgICAgICAgLy8gaW1wbGVtZW50ZWQgeWV0LiBJZiB3ZSB3YW50ZWQgdG8sIHdlIGNvdWxkIG1ha2UgdGhpcyBhbiBhcnJheS5cbiAgICAgICAgYGVudGVyL2V4aXQgZnVuY3Rpb24gZm9yICR7bmFtZU9yUGF0dGVybn0gYWxyZWFkeSBleGlzdHNgXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmVudGVyRm5zLnNldChuYW1lT3JQYXR0ZXJuLCBlbnRlckZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbkVudGVyQXN5bmMobmFtZU9yUGF0dGVybiwgcHJvbWlzZUZuLCBvbk9LLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuIHRoaXMub25FbnRlcihuYW1lT3JQYXR0ZXJuLCAoKSA9PiB7XG4gICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBzaWduYWwgPSBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgIHZvaWQgcHJvbWlzZUZuKHRoaXMuY3VycmVudENvbnRleHQuY3VycmVudCwgc2lnbmFsKS50aGVuKFxuICAgICAgICAvLyBPbiBPS1xuICAgICAgICAoZGF0YSkgPT4ge1xuICAgICAgICAgIGlmICghc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uKHsgdHlwZTogXCJBU1lOQ19PS1wiLCBkYXRhIH0sIG9uT0spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gT24gRXJyb3JcbiAgICAgICAgKHJlYXNvbikgPT4ge1xuICAgICAgICAgIGlmICghc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uKHsgdHlwZTogXCJBU1lOQ19FUlJPUlwiLCByZWFzb24gfSwgb25FcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBpZiAobmFtZU9yUGF0dGVybiA9PT0gXCIqXCIpIHtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5hbWVPclBhdHRlcm4uZW5kc1dpdGgoXCIuKlwiKSkge1xuICAgICAgY29uc3QgcHJlZml4ID0gbmFtZU9yUGF0dGVybi5zbGljZSgwLCAtMSk7XG4gICAgICBmb3IgKGNvbnN0IHN0YXRlIG9mIHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBuYW1lT3JQYXR0ZXJuO1xuICAgICAgaWYgKHRoaXMuc3RhdGVzLmhhcyhuYW1lKSkge1xuICAgICAgICBtYXRjaGVzLnB1c2gobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdGF0ZXMgbWF0Y2ggJHtKU09OLnN0cmluZ2lmeShuYW1lT3JQYXR0ZXJuKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cbiAgLyoqXG4gICAqIERlZmluZSBhbGwgYWxsb3dlZCBvdXRnb2luZyB0cmFuc2l0aW9ucyBmb3IgYSBzdGF0ZS5cbiAgICpcbiAgICogVGhlIHRhcmdldHMgZm9yIGVhY2ggZXZlbnQgY2FuIGJlIGRlZmluZWQgYXMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZVxuICAgKiBuZXh0IHN0YXRlIHRvIHRyYW5zaXRpb24gdG8uIFRoZXNlIGZ1bmN0aW9ucyBjYW4gbG9vayBhdCB0aGUgYGV2ZW50YCBvclxuICAgKiBgY29udGV4dGAgcGFyYW1zIHRvIGNvbmRpdGlvbmFsbHkgZGVjaWRlIHdoaWNoIG5leHQgc3RhdGUgdG8gdHJhbnNpdGlvblxuICAgKiB0by5cbiAgICpcbiAgICogSWYgeW91IHNldCBpdCB0byBgbnVsbGAsIHRoZW4gdGhlIHRyYW5zaXRpb24gd2lsbCBiZSBleHBsaWNpdGx5IGZvcmJpZGRlblxuICAgKiBhbmQgdGhyb3cgYW4gZXJyb3IuIElmIHlvdSBkb24ndCBkZWZpbmUgYSB0YXJnZXQgZm9yIGEgdHJhbnNpdGlvbiwgdGhlblxuICAgKiBzdWNoIGV2ZW50cyB3aWxsIGdldCBpZ25vcmVkLlxuICAgKi9cbiAgYWRkVHJhbnNpdGlvbnMobmFtZU9yUGF0dGVybiwgbWFwcGluZykge1xuICAgIGlmICh0aGlzLnJ1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzcmNTdGF0ZSBvZiB0aGlzLmdldFN0YXRlc01hdGNoaW5nKG5hbWVPclBhdHRlcm4pKSB7XG4gICAgICBsZXQgbWFwID0gdGhpcy5hbGxvd2VkVHJhbnNpdGlvbnMuZ2V0KHNyY1N0YXRlKTtcbiAgICAgIGlmIChtYXAgPT09IHZvaWQgMCkge1xuICAgICAgICBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmFsbG93ZWRUcmFuc2l0aW9ucy5zZXQoc3JjU3RhdGUsIG1hcCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFt0eXBlLCB0YXJnZXRfXSBvZiBPYmplY3QuZW50cmllcyhtYXBwaW5nKSkge1xuICAgICAgICBpZiAobWFwLmhhcyh0eXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBUcnlpbmcgdG8gc2V0IHRyYW5zaXRpb24gXCIke3R5cGV9XCIgb24gXCIke3NyY1N0YXRlfVwiICh2aWEgXCIke25hbWVPclBhdHRlcm59XCIpLCBidXQgYSB0cmFuc2l0aW9uIGFscmVhZHkgZXhpc3RzIHRoZXJlLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldF87XG4gICAgICAgIHRoaXMua25vd25FdmVudFR5cGVzLmFkZCh0eXBlKTtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0Rm4gPSB0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIgPyB0YXJnZXQgOiAoKSA9PiB0YXJnZXQ7XG4gICAgICAgICAgbWFwLnNldCh0eXBlLCB0YXJnZXRGbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIExpa2UgYC5hZGRUcmFuc2l0aW9uKClgLCBidXQgdGFrZXMgYW4gKGFub255bW91cykgdHJhbnNpdGlvbiB3aGVuZXZlciB0aGVcbiAgICogdGltZXIgZmlyZXMuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZU9yUGF0dGVybiBUaGUgc3RhdGUgbmFtZSwgb3Igc3RhdGUgZ3JvdXAgcGF0dGVybiBuYW1lLlxuICAgKiBAcGFyYW0gYWZ0ZXIgICAgICAgICAgTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCB0byB0YWtlIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbi4gSWYgaW4gdGhlIG1lYW4gdGltZSwgYW5vdGhlciB0cmFuc2l0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBpcyB0YWtlbiwgdGhlIHRpbWVyIHdpbGwgZ2V0IGNhbmNlbGxlZC5cbiAgICogQHBhcmFtIHRhcmdldCAgICAgVGhlIHRhcmdldCBzdGF0ZSB0byBnbyB0by5cbiAgICovXG4gIGFkZFRpbWVkVHJhbnNpdGlvbihzdGF0ZU9yUGF0dGVybiwgYWZ0ZXIyLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5vbkVudGVyKHN0YXRlT3JQYXR0ZXJuLCAoKSA9PiB7XG4gICAgICBjb25zdCBtcyA9IHR5cGVvZiBhZnRlcjIgPT09IFwiZnVuY3Rpb25cIiA/IGFmdGVyMih0aGlzLmN1cnJlbnRDb250ZXh0LmN1cnJlbnQpIDogYWZ0ZXIyO1xuICAgICAgY29uc3QgdGltZW91dElEID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbih7IHR5cGU6IFwiVElNRVJcIiB9LCB0YXJnZXQpO1xuICAgICAgfSwgbXMpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGdldFRhcmdldEZuKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFsbG93ZWRUcmFuc2l0aW9ucy5nZXQodGhpcy5jdXJyZW50U3RhdGUpPy5nZXQoZXZlbnROYW1lKTtcbiAgfVxuICAvKipcbiAgICogRXhpdHMgdGhlIGN1cnJlbnQgc3RhdGUsIGFuZCBleGVjdXRlcyBhbnkgbmVjZXNzYXJ5IGNsZWFudXAgZnVuY3Rpb25zLlxuICAgKiBDYWxsIHRoaXMgYmVmb3JlIGNoYW5naW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gbGV2ZWxzIERlZmluZXMgaG93IG1hbnkgXCJsZXZlbHNcIiBvZiBuZXN0aW5nIHdpbGwgYmVcbiAgICogZXhpdGVkLiBGb3IgZXhhbXBsZSwgaWYgeW91IHRyYW5zaXRpb24gZnJvbSBgZm9vLmJhci5xdXhgIHRvXG4gICAqIGBmb28uYmFyLmJhemAsIHRoZW4gdGhlIGxldmVsIGlzIDEuIEJ1dCBpZiB5b3UgdHJhbnNpdGlvbiBmcm9tXG4gICAqIGBmb28uYmFyLnF1eGAgdG8gYGJsYS5ibGFgLCB0aGVuIHRoZSBsZXZlbCBpcyAzLlxuICAgKiBJZiBgbnVsbGAsIGl0IHdpbGwgZXhpdCBhbGwgbGV2ZWxzLlxuICAgKi9cbiAgZXhpdChsZXZlbHMpIHtcbiAgICB0aGlzLmV2ZW50SHViLndpbGxFeGl0U3RhdGUubm90aWZ5KHRoaXMuY3VycmVudFN0YXRlKTtcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgIGxldmVscyA9IGxldmVscyA/PyB0aGlzLmNsZWFudXBTdGFjay5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVsczsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cFN0YWNrLnBvcCgpPy4ocGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVudGVycyB0aGUgY3VycmVudCBzdGF0ZSwgYW5kIGV4ZWN1dGVzIGFueSBuZWNlc3Nhcnkgb25FbnRlciBoYW5kbGVycy5cbiAgICogQ2FsbCB0aGlzIGRpcmVjdGx5IF9hZnRlcl8gc2V0dGluZyB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICovXG4gIGVudGVyKGxldmVscykge1xuICAgIGNvbnN0IGVudGVyUGF0dGVybnMgPSBwYXR0ZXJucyhcbiAgICAgIHRoaXMuY3VycmVudFN0YXRlLFxuICAgICAgbGV2ZWxzID8/IHRoaXMuY3VycmVudFN0YXRlLnNwbGl0KFwiLlwiKS5sZW5ndGggKyAxXG4gICAgKTtcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBlbnRlclBhdHRlcm5zKSB7XG4gICAgICAgIGNvbnN0IGVudGVyRm4gPSB0aGlzLmVudGVyRm5zLmdldChwYXR0ZXJuKTtcbiAgICAgICAgY29uc3QgY2xlYW51cEZuID0gZW50ZXJGbj8uKHBhdGNoYWJsZUNvbnRleHQpO1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFudXBGbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5jbGVhbnVwU3RhY2sucHVzaChjbGVhbnVwRm4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2xlYW51cFN0YWNrLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmV2ZW50SHViLmRpZEVudGVyU3RhdGUubm90aWZ5KHRoaXMuY3VycmVudFN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYW4gZXZlbnQgdG8gdGhlIG1hY2hpbmUsIHdoaWNoIG1heSBjYXVzZSBhbiBpbnRlcm5hbCBzdGF0ZVxuICAgKiB0cmFuc2l0aW9uIHRvIGhhcHBlbi4gV2hlbiB0aGF0IGhhcHBlbnMsIHdpbGwgdHJpZ2dlciBzaWRlIGVmZmVjdHMuXG4gICAqL1xuICBzZW5kKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmtub3duRXZlbnRUeXBlcy5oYXMoZXZlbnQudHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBldmVudCAke0pTT04uc3RyaW5naWZ5KGV2ZW50LnR5cGUpfWApO1xuICAgIH1cbiAgICBpZiAodGhpcy5ydW5uaW5nU3RhdGUgPT09IDIgLyogU1RPUFBFRCAqLykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRGbiA9IHRoaXMuZ2V0VGFyZ2V0Rm4oZXZlbnQudHlwZSk7XG4gICAgaWYgKHRhcmdldEZuICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb24oZXZlbnQsIHRhcmdldEZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgfVxuICB0cmFuc2l0aW9uKGV2ZW50LCB0YXJnZXQpIHtcbiAgICB0aGlzLmV2ZW50SHViLmRpZFJlY2VpdmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5jdXJyZW50U3RhdGU7XG4gICAgY29uc3QgdGFyZ2V0Rm4gPSB0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIgPyB0YXJnZXQgOiAoKSA9PiB0YXJnZXQ7XG4gICAgY29uc3QgbmV4dFRhcmdldCA9IHRhcmdldEZuKGV2ZW50LCB0aGlzLmN1cnJlbnRDb250ZXh0LmN1cnJlbnQpO1xuICAgIGxldCBuZXh0U3RhdGU7XG4gICAgbGV0IGVmZmVjdHMgPSB2b2lkIDA7XG4gICAgaWYgKG5leHRUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXh0VGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXh0VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXh0VGFyZ2V0LnRhcmdldDtcbiAgICAgIGVmZmVjdHMgPSBBcnJheS5pc0FycmF5KG5leHRUYXJnZXQuZWZmZWN0KSA/IG5leHRUYXJnZXQuZWZmZWN0IDogW25leHRUYXJnZXQuZWZmZWN0XTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnN0YXRlcy5oYXMobmV4dFN0YXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5leHQgc3RhdGUgbmFtZTogJHtKU09OLnN0cmluZ2lmeShuZXh0U3RhdGUpfWApO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50SHViLndpbGxUcmFuc2l0aW9uLm5vdGlmeSh7IGZyb206IG9sZFN0YXRlLCB0bzogbmV4dFN0YXRlIH0pO1xuICAgIGNvbnN0IFt1cCwgZG93bl0gPSBkaXN0YW5jZSh0aGlzLmN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICBpZiAodXAgPiAwKSB7XG4gICAgICB0aGlzLmV4aXQodXApO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRTdGF0ZU9yTnVsbCA9IG5leHRTdGF0ZTtcbiAgICBpZiAoZWZmZWN0cyAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBlZmZlY3RzVG9SdW4gPSBlZmZlY3RzO1xuICAgICAgdGhpcy5jdXJyZW50Q29udGV4dC5hbGxvd1BhdGNoaW5nKChwYXRjaGFibGVDb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIGVmZmVjdHNUb1J1bikge1xuICAgICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGVmZmVjdChwYXRjaGFibGVDb250ZXh0LCBldmVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGNoYWJsZUNvbnRleHQucGF0Y2goZWZmZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZG93biA+IDApIHtcbiAgICAgIHRoaXMuZW50ZXIoZG93bik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvbGliL3V0aWxzLnRzXG5mdW5jdGlvbiByYWlzZShtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KGJsb2IpIHtcbiAgcmV0dXJuIGJsb2IgIT09IG51bGwgJiYgdHlwZW9mIGJsb2IgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJsb2IpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gZW50cmllcyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9iaik7XG59XG5mdW5jdGlvbiB0cnlQYXJzZUpzb24ocmF3TWVzc2FnZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJhd01lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gZGVlcENsb25lKHZhbHVlKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBiNjRkZWNvZGUoYjY0dmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IGI2NHZhbHVlLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgIGNvbnN0IGRlY29kZWRWYWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChcbiAgICAgIGF0b2IoZm9ybWF0dGVkVmFsdWUpLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBcIiVcIiArIChcIjAwXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICB9KS5qb2luKFwiXCIpXG4gICAgKTtcbiAgICByZXR1cm4gZGVjb2RlZFZhbHVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gYXRvYihiNjR2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBhY3QoaXRlbXMpIHtcbiAgcmV0dXJuIGl0ZW1zLmZpbHRlcihcbiAgICAoaXRlbSkgPT4gaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB2b2lkIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbXBhY3RPYmplY3Qob2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IHsgLi4ub2JqIH07XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgaWYgKG5ld09ialtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3T2JqO1xufVxuYXN5bmMgZnVuY3Rpb24gd2l0aFRpbWVvdXQocHJvbWlzZSwgbWlsbGlzLCBlcnJtc2cpIHtcbiAgbGV0IHRpbWVySUQ7XG4gIGNvbnN0IHRpbWVyJCA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICB0aW1lcklEID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZWplY3QobmV3IEVycm9yKGVycm1zZykpO1xuICAgIH0sIG1pbGxpcyk7XG4gIH0pO1xuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwcm9taXNlLCB0aW1lciRdKS5maW5hbGx5KCgpID0+IGNsZWFyVGltZW91dCh0aW1lcklEKSk7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9TZXJ2ZXJNc2cudHNcbnZhciBTZXJ2ZXJNc2dDb2RlID0gLyogQF9fUFVSRV9fICovICgoU2VydmVyTXNnQ29kZTIpID0+IHtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfUFJFU0VOQ0VcIl0gPSAxMDBdID0gXCJVUERBVEVfUFJFU0VOQ0VcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVU0VSX0pPSU5FRFwiXSA9IDEwMV0gPSBcIlVTRVJfSk9JTkVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVNFUl9MRUZUXCJdID0gMTAyXSA9IFwiVVNFUl9MRUZUXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQlJPQURDQVNURURfRVZFTlRcIl0gPSAxMDNdID0gXCJCUk9BRENBU1RFRF9FVkVOVFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlJPT01fU1RBVEVcIl0gPSAxMDRdID0gXCJST09NX1NUQVRFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiSU5JVElBTF9TVE9SQUdFX1NUQVRFXCJdID0gMjAwXSA9IFwiSU5JVElBTF9TVE9SQUdFX1NUQVRFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1NUT1JBR0VcIl0gPSAyMDFdID0gXCJVUERBVEVfU1RPUkFHRVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlJFSkVDVF9TVE9SQUdFX09QXCJdID0gMjk5XSA9IFwiUkVKRUNUX1NUT1JBR0VfT1BcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfWURPQ1wiXSA9IDMwMF0gPSBcIlVQREFURV9ZRE9DXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX0NSRUFURURcIl0gPSA0MDBdID0gXCJUSFJFQURfQ1JFQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9NRVRBREFUQV9VUERBVEVEXCJdID0gNDAxXSA9IFwiVEhSRUFEX01FVEFEQVRBX1VQREFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0NSRUFURURcIl0gPSA0MDJdID0gXCJDT01NRU5UX0NSRUFURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0VESVRFRFwiXSA9IDQwM10gPSBcIkNPTU1FTlRfRURJVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9ERUxFVEVEXCJdID0gNDA0XSA9IFwiQ09NTUVOVF9ERUxFVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQ09NTUVOVF9SRUFDVElPTl9BRERFRFwiXSA9IDQwNV0gPSBcIkNPTU1FTlRfUkVBQ1RJT05fQURERURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX1JFQUNUSU9OX1JFTU9WRURcIl0gPSA0MDZdID0gXCJDT01NRU5UX1JFQUNUSU9OX1JFTU9WRURcIjtcbiAgcmV0dXJuIFNlcnZlck1zZ0NvZGUyO1xufSkoU2VydmVyTXNnQ29kZSB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9JV2ViU29ja2V0LnRzXG52YXIgV2Vic29ja2V0Q2xvc2VDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKFdlYnNvY2tldENsb3NlQ29kZXMyKSA9PiB7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfTk9STUFMXCJdID0gMWUzXSA9IFwiQ0xPU0VfTk9STUFMXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiQ0xPU0VfQUJOT1JNQUxcIl0gPSAxMDA2XSA9IFwiQ0xPU0VfQUJOT1JNQUxcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJVTkVYUEVDVEVEX0NPTkRJVElPTlwiXSA9IDEwMTFdID0gXCJVTkVYUEVDVEVEX0NPTkRJVElPTlwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlRSWV9BR0FJTl9MQVRFUlwiXSA9IDEwMTNdID0gXCJUUllfQUdBSU5fTEFURVJcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJJTlZBTElEX01FU1NBR0VfRk9STUFUXCJdID0gNGUzXSA9IFwiSU5WQUxJRF9NRVNTQUdFX0ZPUk1BVFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk5PVF9BTExPV0VEXCJdID0gNDAwMV0gPSBcIk5PVF9BTExPV0VEXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfU0VDT05EU1wiXSA9IDQwMDJdID0gXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9TRUNPTkRTXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TXCJdID0gNDAwM10gPSBcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU1wiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX0RBWV9QRVJfQVBQXCJdID0gNDAwNF0gPSBcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX0RBWV9QRVJfQVBQXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TX1BFUl9ST09NXCJdID0gNDAwNV0gPSBcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU19QRVJfUk9PTVwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIktJQ0tFRFwiXSA9IDQxMDBdID0gXCJLSUNLRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJUT0tFTl9FWFBJUkVEXCJdID0gNDEwOV0gPSBcIlRPS0VOX0VYUElSRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9XSVRIT1VUX1JFVFJZXCJdID0gNDk5OV0gPSBcIkNMT1NFX1dJVEhPVVRfUkVUUllcIjtcbiAgcmV0dXJuIFdlYnNvY2tldENsb3NlQ29kZXMyO1xufSkoV2Vic29ja2V0Q2xvc2VDb2RlcyB8fCB7fSk7XG5mdW5jdGlvbiBzaG91bGREaXNjb25uZWN0KGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDQ5OTkgLyogQ0xPU0VfV0lUSE9VVF9SRVRSWSAqLyB8fCBjb2RlID49IDRlMyAmJiBjb2RlIDwgNDEwMDtcbn1cbmZ1bmN0aW9uIHNob3VsZFJlYXV0aChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDQxMDAgJiYgY29kZSA8IDQyMDA7XG59XG5mdW5jdGlvbiBzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAxMyAvKiBUUllfQUdBSU5fTEFURVIgKi8gfHwgY29kZSA+PSA0MjAwICYmIGNvZGUgPCA0MzAwO1xufVxuXG4vLyBzcmMvY29ubmVjdGlvbi50c1xuZnVuY3Rpb24gaXNJZGxlKHN0YXR1cykge1xuICByZXR1cm4gc3RhdHVzID09PSBcImluaXRpYWxcIiB8fCBzdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCI7XG59XG5mdW5jdGlvbiBuZXdUb0xlZ2FjeVN0YXR1cyhzdGF0dXMpIHtcbiAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICBjYXNlIFwiY29ubmVjdGluZ1wiOlxuICAgICAgcmV0dXJuIFwiY29ubmVjdGluZ1wiO1xuICAgIGNhc2UgXCJjb25uZWN0ZWRcIjpcbiAgICAgIHJldHVybiBcIm9wZW5cIjtcbiAgICBjYXNlIFwicmVjb25uZWN0aW5nXCI6XG4gICAgICByZXR1cm4gXCJ1bmF2YWlsYWJsZVwiO1xuICAgIGNhc2UgXCJkaXNjb25uZWN0ZWRcIjpcbiAgICAgIHJldHVybiBcImZhaWxlZFwiO1xuICAgIGNhc2UgXCJpbml0aWFsXCI6XG4gICAgICByZXR1cm4gXCJjbG9zZWRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiY2xvc2VkXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvTmV3Q29ubmVjdGlvblN0YXR1cyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXRlID0gbWFjaGluZS5jdXJyZW50U3RhdGU7XG4gIHN3aXRjaCAoc3RhdGUpIHtcbiAgICBjYXNlIFwiQG9rLmNvbm5lY3RlZFwiOlxuICAgIGNhc2UgXCJAb2suYXdhaXRpbmctcG9uZ1wiOlxuICAgICAgcmV0dXJuIFwiY29ubmVjdGVkXCI7XG4gICAgY2FzZSBcIkBpZGxlLmluaXRpYWxcIjpcbiAgICAgIHJldHVybiBcImluaXRpYWxcIjtcbiAgICBjYXNlIFwiQGF1dGguYnVzeVwiOlxuICAgIGNhc2UgXCJAYXV0aC5iYWNrb2ZmXCI6XG4gICAgY2FzZSBcIkBjb25uZWN0aW5nLmJ1c3lcIjpcbiAgICBjYXNlIFwiQGNvbm5lY3RpbmcuYmFja29mZlwiOlxuICAgIGNhc2UgXCJAaWRsZS56b21iaWVcIjpcbiAgICAgIHJldHVybiBtYWNoaW5lLmNvbnRleHQuc3VjY2Vzc0NvdW50ID4gMCA/IFwicmVjb25uZWN0aW5nXCIgOiBcImNvbm5lY3RpbmdcIjtcbiAgICBjYXNlIFwiQGlkbGUuZmFpbGVkXCI6XG4gICAgICByZXR1cm4gXCJkaXNjb25uZWN0ZWRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHN0YXRlLCBcIlVua25vd24gc3RhdGVcIik7XG4gIH1cbn1cbnZhciBCQUNLT0ZGX0RFTEFZUyA9IFsyNTAsIDUwMCwgMWUzLCAyZTMsIDRlMywgOGUzLCAxZTRdO1xudmFyIFJFU0VUX0RFTEFZID0gQkFDS09GRl9ERUxBWVNbMF0gLSAxO1xudmFyIEJBQ0tPRkZfREVMQVlTX1NMT1cgPSBbMmUzLCAzZTQsIDZlNCwgM2U1XTtcbnZhciBIRUFSVEJFQVRfSU5URVJWQUwgPSAzZTQ7XG52YXIgUE9OR19USU1FT1VUID0gMmUzO1xudmFyIEFVVEhfVElNRU9VVCA9IDFlNDtcbnZhciBTT0NLRVRfQ09OTkVDVF9USU1FT1VUID0gMWU0O1xudmFyIFN0b3BSZXRyeWluZyA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihyZWFzb24pO1xuICB9XG59O1xudmFyIExpdmVibG9ja3NFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59O1xuZnVuY3Rpb24gbmV4dEJhY2tvZmZEZWxheShjdXJyZW50RGVsYXksIGRlbGF5cykge1xuICByZXR1cm4gZGVsYXlzLmZpbmQoKGRlbGF5KSA9PiBkZWxheSA+IGN1cnJlbnREZWxheSkgPz8gZGVsYXlzW2RlbGF5cy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGluY3JlYXNlQmFja29mZkRlbGF5KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7XG4gICAgYmFja29mZkRlbGF5OiBuZXh0QmFja29mZkRlbGF5KGNvbnRleHQuYmFja29mZkRlbGF5LCBCQUNLT0ZGX0RFTEFZUylcbiAgfSk7XG59XG5mdW5jdGlvbiBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseShjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goe1xuICAgIGJhY2tvZmZEZWxheTogbmV4dEJhY2tvZmZEZWxheShjb250ZXh0LmJhY2tvZmZEZWxheSwgQkFDS09GRl9ERUxBWVNfU0xPVylcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNldFN1Y2Nlc3NDb3VudChjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goeyBzdWNjZXNzQ291bnQ6IDAgfSk7XG59XG5mdW5jdGlvbiBsb2cobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgY29uc3QgbG9nZ2VyID0gbGV2ZWwgPT09IDIgLyogRVJST1IgKi8gPyBlcnJvcjIgOiBsZXZlbCA9PT0gMSAvKiBXQVJOICovID8gd2FybiA6IChcbiAgICAvKiBibGFjayBob2xlICovXG4gICAgKCkgPT4ge1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsb2dnZXIobWVzc2FnZSk7XG4gIH07XG59XG5mdW5jdGlvbiBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlKSB7XG4gIGNvbnN0IGNvbm4gPSBcIkNvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyXCI7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgd2FybihgJHtjb25ufSBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQuICR7U3RyaW5nKGUpfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBpc0Nsb3NlRXZlbnQoZSkgPyBgJHtjb25ufSBjbG9zZWQgcHJlbWF0dXJlbHkgKGNvZGU6ICR7ZS5jb2RlfSkuIFJldHJ5aW5nIGluICR7Y3R4LmJhY2tvZmZEZWxheX1tcy5gIDogYCR7Y29ubn0gY291bGQgbm90IGJlIGVzdGFibGlzaGVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbG9nQ2xvc2VFdmVudChldmVudCkge1xuICByZXR1cm4gKGN0eCkgPT4ge1xuICAgIHdhcm4oXG4gICAgICBgQ29ubmVjdGlvbiB0byBMaXZlYmxvY2tzIHdlYnNvY2tldCBzZXJ2ZXIgY2xvc2VkIChjb2RlOiAke2V2ZW50LmNvZGV9KS4gUmV0cnlpbmcgaW4gJHtjdHguYmFja29mZkRlbGF5fW1zLmBcbiAgICApO1xuICB9O1xufVxudmFyIGxvZ1Blcm1hbmVudENsb3NlID0gbG9nKFxuICAxIC8qIFdBUk4gKi8sXG4gIFwiQ29ubmVjdGlvbiB0byBXZWJTb2NrZXQgY2xvc2VkIHBlcm1hbmVudGx5LiBXb24ndCByZXRyeS5cIlxuKTtcbmZ1bmN0aW9uIGlzQ2xvc2VFdmVudChlcnJvcjMpIHtcbiAgcmV0dXJuICEoZXJyb3IzIGluc3RhbmNlb2YgRXJyb3IpICYmIGVycm9yMy50eXBlID09PSBcImNsb3NlXCI7XG59XG5mdW5jdGlvbiBlbmFibGVUcmFjaW5nKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhcnQgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgZnVuY3Rpb24gbG9nMiguLi5hcmdzKSB7XG4gICAgd2FybihcbiAgICAgIGAkeygoKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydCkgLyAxZTMpLnRvRml4ZWQoMil9IFtGU00gIyR7bWFjaGluZS5pZH1dYCxcbiAgICAgIC4uLmFyZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IHVuc3VicyA9IFtcbiAgICBtYWNoaW5lLmV2ZW50cy5kaWRSZWNlaXZlRXZlbnQuc3Vic2NyaWJlKChlKSA9PiBsb2cyKGBFdmVudCAke2UudHlwZX1gKSksXG4gICAgbWFjaGluZS5ldmVudHMud2lsbFRyYW5zaXRpb24uc3Vic2NyaWJlKFxuICAgICAgKHsgZnJvbSwgdG8gfSkgPT4gbG9nMihcIlRyYW5zaXRpb25pbmdcIiwgZnJvbSwgXCJcXHUyMTkyXCIsIHRvKVxuICAgICksXG4gICAgbWFjaGluZS5ldmVudHMuZGlkSWdub3JlRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgKGUpID0+IGxvZzIoXCJJZ25vcmVkIGV2ZW50XCIsIGUudHlwZSwgZSwgXCIoY3VycmVudCBzdGF0ZSB3b24ndCBoYW5kbGUgaXQpXCIpXG4gICAgKVxuICAgIC8vIG1hY2hpbmUuZXZlbnRzLndpbGxFeGl0U3RhdGUuc3Vic2NyaWJlKChzKSA9PiBsb2coXCJFeGl0aW5nIHN0YXRlXCIsIHMpKSxcbiAgICAvLyBtYWNoaW5lLmV2ZW50cy5kaWRFbnRlclN0YXRlLnN1YnNjcmliZSgocykgPT4gbG9nKFwiRW50ZXJpbmcgc3RhdGVcIiwgcykpLFxuICBdO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgdW5zdWIgb2YgdW5zdWJzKSB7XG4gICAgICB1bnN1YigpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmluZUNvbm5lY3Rpdml0eUV2ZW50cyhtYWNoaW5lKSB7XG4gIGNvbnN0IHN0YXR1c0RpZENoYW5nZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBjb25zdCBkaWRDb25uZWN0ID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGNvbnN0IGRpZERpc2Nvbm5lY3QgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgbGV0IGxhc3RTdGF0dXMgPSBudWxsO1xuICBjb25zdCB1bnN1YnNjcmliZSA9IG1hY2hpbmUuZXZlbnRzLmRpZEVudGVyU3RhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICBjb25zdCBjdXJyU3RhdHVzID0gdG9OZXdDb25uZWN0aW9uU3RhdHVzKG1hY2hpbmUpO1xuICAgIGlmIChjdXJyU3RhdHVzICE9PSBsYXN0U3RhdHVzKSB7XG4gICAgICBzdGF0dXNEaWRDaGFuZ2Uubm90aWZ5KGN1cnJTdGF0dXMpO1xuICAgIH1cbiAgICBpZiAobGFzdFN0YXR1cyA9PT0gXCJjb25uZWN0ZWRcIiAmJiBjdXJyU3RhdHVzICE9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBkaWREaXNjb25uZWN0Lm5vdGlmeSgpO1xuICAgIH0gZWxzZSBpZiAobGFzdFN0YXR1cyAhPT0gXCJjb25uZWN0ZWRcIiAmJiBjdXJyU3RhdHVzID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICBkaWRDb25uZWN0Lm5vdGlmeSgpO1xuICAgIH1cbiAgICBsYXN0U3RhdHVzID0gY3VyclN0YXR1cztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzRGlkQ2hhbmdlOiBzdGF0dXNEaWRDaGFuZ2Uub2JzZXJ2YWJsZSxcbiAgICBkaWRDb25uZWN0OiBkaWRDb25uZWN0Lm9ic2VydmFibGUsXG4gICAgZGlkRGlzY29ubmVjdDogZGlkRGlzY29ubmVjdC5vYnNlcnZhYmxlLFxuICAgIHVuc3Vic2NyaWJlXG4gIH07XG59XG52YXIgYXNzaWduID0gKHBhdGNoKSA9PiAoY3R4KSA9PiBjdHgucGF0Y2gocGF0Y2gpO1xuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblN0YXRlTWFjaGluZShkZWxlZ2F0ZXMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb25NZXNzYWdlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIG9uTWVzc2FnZS5wYXVzZSgpO1xuICBjb25zdCBvbkxpdmVibG9ja3NFcnJvciA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBmaXJlRXJyb3JFdmVudChlcnJtc2csIGVycmNvZGUpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gbmV3IExpdmVibG9ja3NFcnJvcihlcnJtc2csIGVycmNvZGUpO1xuICAgICAgb25MaXZlYmxvY2tzRXJyb3Iubm90aWZ5KGVycik7XG4gICAgfTtcbiAgfVxuICBjb25zdCBpbml0aWFsQ29udGV4dCA9IHtcbiAgICBzdWNjZXNzQ291bnQ6IDAsXG4gICAgYXV0aFZhbHVlOiBudWxsLFxuICAgIHNvY2tldDogbnVsbCxcbiAgICBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZXG4gIH07XG4gIGNvbnN0IG1hY2hpbmUgPSBuZXcgRlNNKGluaXRpYWxDb250ZXh0KS5hZGRTdGF0ZShcIkBpZGxlLmluaXRpYWxcIikuYWRkU3RhdGUoXCJAaWRsZS5mYWlsZWRcIikuYWRkU3RhdGUoXCJAaWRsZS56b21iaWVcIikuYWRkU3RhdGUoXCJAYXV0aC5idXN5XCIpLmFkZFN0YXRlKFwiQGF1dGguYmFja29mZlwiKS5hZGRTdGF0ZShcIkBjb25uZWN0aW5nLmJ1c3lcIikuYWRkU3RhdGUoXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIpLmFkZFN0YXRlKFwiQG9rLmNvbm5lY3RlZFwiKS5hZGRTdGF0ZShcIkBvay5hd2FpdGluZy1wb25nXCIpO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiKlwiLCB7XG4gICAgUkVDT05ORUNUOiB7XG4gICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIHJlc2V0U3VjY2Vzc0NvdW50XVxuICAgIH0sXG4gICAgRElTQ09OTkVDVDogXCJAaWRsZS5pbml0aWFsXCJcbiAgfSk7XG4gIG1hY2hpbmUub25FbnRlcihcIkBpZGxlLipcIiwgcmVzZXRTdWNjZXNzQ291bnQpLmFkZFRyYW5zaXRpb25zKFwiQGlkbGUuKlwiLCB7XG4gICAgQ09OTkVDVDogKF8sIGN0eCkgPT4gKFxuICAgICAgLy8gSWYgd2Ugc3RpbGwgaGF2ZSBhIGtub3duIGF1dGhWYWx1ZSwgdHJ5IHRvIHJlY29ubmVjdCB0byB0aGUgc29ja2V0IGRpcmVjdGx5LFxuICAgICAgLy8gb3RoZXJ3aXNlLCB0cnkgdG8gb2J0YWluIGEgbmV3IGF1dGhWYWx1ZVxuICAgICAgY3R4LmF1dGhWYWx1ZSAhPT0gbnVsbCA/IFwiQGNvbm5lY3RpbmcuYnVzeVwiIDogXCJAYXV0aC5idXN5XCJcbiAgICApXG4gIH0pO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGF1dGguYmFja29mZlwiLCB7XG4gICAgTkFWSUdBVE9SX09OTElORToge1xuICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHsgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWSB9KVxuICAgIH1cbiAgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGF1dGguYmFja29mZlwiLFxuICAgIChjdHgpID0+IGN0eC5iYWNrb2ZmRGVsYXksXG4gICAgXCJAYXV0aC5idXN5XCJcbiAgKS5vbkVudGVyQXN5bmMoXG4gICAgXCJAYXV0aC5idXN5XCIsXG4gICAgKCkgPT4gd2l0aFRpbWVvdXQoXG4gICAgICBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCksXG4gICAgICBBVVRIX1RJTUVPVVQsXG4gICAgICBcIlRpbWVkIG91dCBkdXJpbmcgYXV0aFwiXG4gICAgKSxcbiAgICAvLyBPbiBzdWNjZXNzZnVsIGF1dGhlbnRpY2F0aW9uXG4gICAgKG9rRXZlbnQpID0+ICh7XG4gICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oe1xuICAgICAgICBhdXRoVmFsdWU6IG9rRXZlbnQuZGF0YVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAvLyBBdXRoIGZhaWxlZFxuICAgIChmYWlsZWRFdmVudCkgPT4ge1xuICAgICAgaWYgKGZhaWxlZEV2ZW50LnJlYXNvbiBpbnN0YW5jZW9mIFN0b3BSZXRyeWluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSksXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSwgLTEpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgaW5jcmVhc2VCYWNrb2ZmRGVsYXksXG4gICAgICAgICAgbG9nKFxuICAgICAgICAgICAgMiAvKiBFUlJPUiAqLyxcbiAgICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZmFpbGVkRXZlbnQucmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyBmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSA6IFN0cmluZyhmYWlsZWRFdmVudC5yZWFzb24pfWBcbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICApO1xuICBjb25zdCBvblNvY2tldEVycm9yID0gKGV2ZW50KSA9PiBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9FUlJPUlwiLCBldmVudCB9KTtcbiAgY29uc3Qgb25Tb2NrZXRDbG9zZSA9IChldmVudCkgPT4gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfQ0xPU0VcIiwgZXZlbnQgfSk7XG4gIGNvbnN0IG9uU29ja2V0TWVzc2FnZSA9IChldmVudCkgPT4gZXZlbnQuZGF0YSA9PT0gXCJwb25nXCIgPyBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlBPTkdcIiB9KSA6IG9uTWVzc2FnZS5ub3RpZnkoZXZlbnQpO1xuICBmdW5jdGlvbiB0ZWFyZG93blNvY2tldChzb2NrZXQpIHtcbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvblNvY2tldENsb3NlKTtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsIHtcbiAgICBOQVZJR0FUT1JfT05MSU5FOiB7XG4gICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oeyBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZIH0pXG4gICAgfVxuICB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXG4gICAgXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgKGN0eCkgPT4gY3R4LmJhY2tvZmZEZWxheSxcbiAgICBcIkBjb25uZWN0aW5nLmJ1c3lcIlxuICApLm9uRW50ZXJBc3luYyhcbiAgICBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAvL1xuICAgIC8vIFVzZSB0aGUgXCJjcmVhdGVTb2NrZXRcIiBkZWxlZ2F0ZSBmdW5jdGlvbiAocHJvdmlkZWQgdG8gdGhlXG4gICAgLy8gTWFuYWdlZFNvY2tldCkgdG8gY3JlYXRlIHRoZSBhY3R1YWwgV2ViU29ja2V0IGNvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAgLy8gVGhlbiwgc2V0IHVwIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycywgYW5kIHdhaXQgZm9yIHRoZVxuICAgIC8vIFwib3BlblwiIGV2ZW50IHRvIG9jY3VyLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgXCJvcGVuXCIgZXZlbnQgaGFwcGVucywgd2UncmUgcmVhZHkgdG8gdHJhbnNpdGlvbiB0byB0aGVcbiAgICAvLyBPSyBzdGF0ZS4gVGhpcyBpcyBkb25lIGJ5IHJlc29sdmluZyB0aGUgUHJvbWlzZS5cbiAgICAvL1xuICAgIGFzeW5jIChjdHgsIHNpZ25hbCkgPT4ge1xuICAgICAgbGV0IGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQgPSBudWxsO1xuICAgICAgbGV0IHVuY29uZmlybWVkU29ja2V0ID0gbnVsbDtcbiAgICAgIGNvbnN0IGNvbm5lY3QkID0gbmV3IFByb21pc2UoXG4gICAgICAgIChyZXNvbHZlLCByZWopID0+IHtcbiAgICAgICAgICBpZiAoY3R4LmF1dGhWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCBhdXRoVmFsdWVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNvY2tldCA9IGRlbGVnYXRlcy5jcmVhdGVTb2NrZXQoY3R4LmF1dGhWYWx1ZSk7XG4gICAgICAgICAgdW5jb25maXJtZWRTb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgICAgZnVuY3Rpb24gcmVqZWN0KGV2ZW50KSB7XG4gICAgICAgICAgICBjYXB0dXJlZFByZW1hdHVyZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgICAgICAgIHJlaihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IFthY3RvciQsIGRpZFJlY2VpdmVBY3Rvcl0gPSBjb250cm9sbGVkUHJvbWlzZSgpO1xuICAgICAgICAgIGlmICghb3B0aW9ucy53YWl0Rm9yQWN0b3JJZCkge1xuICAgICAgICAgICAgZGlkUmVjZWl2ZUFjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHdhaXRGb3JBY3RvcklkKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJNc2cgPSB0cnlQYXJzZUpzb24oZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBpZiAoc2VydmVyTXNnPy50eXBlID09PSAxMDQgLyogUk9PTV9TVEFURSAqLykge1xuICAgICAgICAgICAgICBkaWRSZWNlaXZlQWN0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMud2FpdEZvckFjdG9ySWQpIHtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB3YWl0Rm9yQWN0b3JJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIHJlamVjdCk7XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsICgpID0+IHtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Tb2NrZXRFcnJvcik7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIG9uU29ja2V0Q2xvc2UpO1xuICAgICAgICAgICAgY29uc3QgdW5zdWIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCByZWplY3QpO1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgd2FpdEZvckFjdG9ySWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZvaWQgYWN0b3IkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKFtzb2NrZXQsIHVuc3ViXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB3aXRoVGltZW91dChcbiAgICAgICAgY29ubmVjdCQsXG4gICAgICAgIFNPQ0tFVF9DT05ORUNUX1RJTUVPVVQsXG4gICAgICAgIFwiVGltZWQgb3V0IGR1cmluZyB3ZWJzb2NrZXQgY29ubmVjdGlvblwiXG4gICAgICApLnRoZW4oXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFBhcnQgMzpcbiAgICAgICAgLy8gQnkgbm93LCBvdXIgXCJvcGVuXCIgZXZlbnQgaGFzIGZpcmVkLCBhbmQgdGhlIHByb21pc2UgaGFzIGJlZW5cbiAgICAgICAgLy8gcmVzb2x2ZWQuIFR3byBwb3NzaWJsZSBzY2VuYXJpb3M6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIFRoZSBoYXBweSBwYXRoLiBNb3N0IGxpa2VseS5cbiAgICAgICAgLy8gMi4gVWgtb2guIEEgcHJlbWF0dXJlIGNsb3NlL2Vycm9yIGV2ZW50IGhhcyBiZWVuIG9ic2VydmVkLiBMZXQnc1xuICAgICAgICAvLyAgICByZWplY3QgdGhlIHByb21pc2UgYWZ0ZXIgYWxsLlxuICAgICAgICAvL1xuICAgICAgICAvLyBBbnkgY2xvc2UvZXJyb3IgZXZlbnQgdGhhdCB3aWxsIGdldCBzY2hlZHVsZWQgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBvbndhcmRzLCB3aWxsIGJlIGNhdWdodCBpbiB0aGUgT0sgc3RhdGUsIGFuZCBkZWFsdCB3aXRoXG4gICAgICAgIC8vIGFjY29yZGluZ2x5LlxuICAgICAgICAvL1xuICAgICAgICAoW3NvY2tldCwgdW5zdWJdKSA9PiB7XG4gICAgICAgICAgdW5zdWIoKTtcbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFib3J0ZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYXB0dXJlZFByZW1hdHVyZUV2ZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBjYXB0dXJlZFByZW1hdHVyZUV2ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgICAgICB9XG4gICAgICApLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRlYXJkb3duU29ja2V0KHVuY29uZmlybWVkU29ja2V0KTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gT25seSB0cmFuc2l0aW9uIHRvIE9LIHN0YXRlIGFmdGVyIGEgc3VjY2Vzc2Z1bGx5IG9wZW5lZCBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgIChva0V2ZW50KSA9PiAoe1xuICAgICAgdGFyZ2V0OiBcIkBvay5jb25uZWN0ZWRcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHtcbiAgICAgICAgc29ja2V0OiBva0V2ZW50LmRhdGEsXG4gICAgICAgIGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVlcbiAgICAgIH0pXG4gICAgfSksXG4gICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZFxuICAgIChmYWlsdXJlKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBmYWlsdXJlLnJlYXNvbjtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTdG9wUmV0cnlpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZXJyLm1lc3NhZ2UpLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZXJyLm1lc3NhZ2UsIC0xKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Nsb3NlRXZlbnQoZXJyKSkge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDQxMDkgLyogVE9LRU5fRVhQSVJFRCAqLykge1xuICAgICAgICAgIHJldHVybiBcIkBhdXRoLmJ1c3lcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGVyci5jb2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICAgIGluY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5LFxuICAgICAgICAgICAgICBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlcnIpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkRGlzY29ubmVjdChlcnIuY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBlcnIucmVhc29uKSxcbiAgICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZXJyLnJlYXNvbiwgZXJyLmNvZGUpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50KGVycildXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbiAgY29uc3Qgc2VuZEhlYXJ0YmVhdCA9IHtcbiAgICB0YXJnZXQ6IFwiQG9rLmF3YWl0aW5nLXBvbmdcIixcbiAgICBlZmZlY3Q6IChjdHgpID0+IHtcbiAgICAgIGN0eC5zb2NrZXQ/LnNlbmQoXCJwaW5nXCIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbWF5YmVIZWFydGJlYXQgPSAoKSA9PiB7XG4gICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gICAgY29uc3QgY2FuWm9tYmllID0gZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIgJiYgZGVsZWdhdGVzLmNhblpvbWJpZSgpO1xuICAgIHJldHVybiBjYW5ab21iaWUgPyBcIkBpZGxlLnpvbWJpZVwiIDogc2VuZEhlYXJ0YmVhdDtcbiAgfTtcbiAgbWFjaGluZS5hZGRUaW1lZFRyYW5zaXRpb24oXCJAb2suY29ubmVjdGVkXCIsIEhFQVJUQkVBVF9JTlRFUlZBTCwgbWF5YmVIZWFydGJlYXQpLmFkZFRyYW5zaXRpb25zKFwiQG9rLmNvbm5lY3RlZFwiLCB7XG4gICAgTkFWSUdBVE9SX09GRkxJTkU6IG1heWJlSGVhcnRiZWF0LFxuICAgIC8vIERvbid0IHRha2UgdGhlIGJyb3dzZXIncyB3b3JkIGZvciBpdCB3aGVuIGl0IHNheXMgaXQncyBvZmZsaW5lLiBEbyBhIHBpbmcvcG9uZyB0byBtYWtlIHN1cmUuXG4gICAgV0lORE9XX0dPVF9GT0NVUzogc2VuZEhlYXJ0YmVhdFxuICB9KTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlLnpvbWJpZVwiLCB7XG4gICAgV0lORE9XX0dPVF9GT0NVUzogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCJcbiAgICAvLyBXaGVuIGluIHpvbWJpZSBzdGF0ZSwgdGhlIGNsaWVudCB3aWxsIHRyeSB0byB3YWtlIHVwIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgd2luZG93IHJlZ2FpbnMgZm9jdXNcbiAgfSk7XG4gIG1hY2hpbmUub25FbnRlcihcIkBvay4qXCIsIChjdHgpID0+IHtcbiAgICBjdHgucGF0Y2goeyBzdWNjZXNzQ291bnQ6IGN0eC5zdWNjZXNzQ291bnQgKyAxIH0pO1xuICAgIGNvbnN0IHRpbWVySUQgPSBzZXRUaW1lb3V0KFxuICAgICAgLy8gT24gdGhlIG5leHQgdGljaywgc3RhcnQgZGVsaXZlcmluZyBhbGwgbWVzc2FnZXMgdGhhdCBoYXZlIGFscmVhZHlcbiAgICAgIC8vIGJlZW4gcmVjZWl2ZWQsIGFuZCBjb250aW51ZSBzeW5jaHJvbm91cyBkZWxpdmVyeSBvZiBhbGwgZnV0dXJlXG4gICAgICAvLyBpbmNvbWluZyBtZXNzYWdlcy5cbiAgICAgIG9uTWVzc2FnZS51bnBhdXNlLFxuICAgICAgMFxuICAgICk7XG4gICAgcmV0dXJuIChjdHgyKSA9PiB7XG4gICAgICB0ZWFyZG93blNvY2tldChjdHgyLnNvY2tldCk7XG4gICAgICBjdHgyLnBhdGNoKHsgc29ja2V0OiBudWxsIH0pO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpO1xuICAgICAgb25NZXNzYWdlLnBhdXNlKCk7XG4gICAgfTtcbiAgfSkuYWRkVHJhbnNpdGlvbnMoXCJAb2suYXdhaXRpbmctcG9uZ1wiLCB7IFBPTkc6IFwiQG9rLmNvbm5lY3RlZFwiIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcIkBvay5hd2FpdGluZy1wb25nXCIsIFBPTkdfVElNRU9VVCwge1xuICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgLy8gTG9nIGltcGxpY2l0IGNvbm5lY3Rpb24gbG9zcyBhbmQgZHJvcCB0aGUgY3VycmVudCBvcGVuIHNvY2tldFxuICAgIGVmZmVjdDogbG9nKFxuICAgICAgMSAvKiBXQVJOICovLFxuICAgICAgXCJSZWNlaXZlZCBubyBwb25nIGZyb20gc2VydmVyLCBhc3N1bWUgaW1wbGljaXQgY29ubmVjdGlvbiBsb3NzLlwiXG4gICAgKVxuICB9KS5hZGRUcmFuc2l0aW9ucyhcIkBvay4qXCIsIHtcbiAgICAvLyBXaGVuIGEgc29ja2V0IHJlY2VpdmVzIGFuIGVycm9yLCB0aGlzIGNhbiBjYXVzZSB0aGUgY2xvc2luZyBvZiB0aGVcbiAgICAvLyBzb2NrZXQsIG9yIG5vdC4gU28gYWx3YXlzIGNoZWNrIHRvIHNlZSBpZiB0aGUgc29ja2V0IGlzIHN0aWxsIE9QRU4gb3JcbiAgICAvLyBub3QuIFdoZW4gc3RpbGwgT1BFTiwgZG9uJ3QgdHJhbnNpdGlvbi5cbiAgICBFWFBMSUNJVF9TT0NLRVRfRVJST1I6IChfLCBjb250ZXh0KSA9PiB7XG4gICAgICBpZiAoY29udGV4dC5zb2NrZXQ/LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IGluY3JlYXNlQmFja29mZkRlbGF5XG4gICAgICB9O1xuICAgIH0sXG4gICAgRVhQTElDSVRfU09DS0VUX0NMT1NFOiAoZSkgPT4ge1xuICAgICAgaWYgKHNob3VsZERpc2Nvbm5lY3QoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZ1Blcm1hbmVudENsb3NlLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZS5ldmVudC5yZWFzb24sIGUuZXZlbnQuY29kZSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVhdXRoKGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgaWYgKGUuZXZlbnQuY29kZSA9PT0gNDEwOSAvKiBUT0tFTl9FWFBJUkVEICovKSB7XG4gICAgICAgICAgcmV0dXJuIFwiQGF1dGguYnVzeVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gICAgY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHZvaWQgMDtcbiAgICBjb25zdCByb290ID0gd2luID8/IGRvYztcbiAgICBtYWNoaW5lLm9uRW50ZXIoXCIqXCIsIChjdHgpID0+IHtcbiAgICAgIGZ1bmN0aW9uIG9uTmV0d29ya09mZmxpbmUoKSB7XG4gICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiTkFWSUdBVE9SX09GRkxJTkVcIiB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTmV0d29ya0JhY2tPbmxpbmUoKSB7XG4gICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiTkFWSUdBVE9SX09OTElORVwiIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJXSU5ET1dfR09UX0ZPQ1VTXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbk5ldHdvcmtCYWNrT25saW5lKTtcbiAgICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb25OZXR3b3JrT2ZmbGluZSk7XG4gICAgICByb290Py5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcm9vdD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgICAgd2luPy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9uTmV0d29ya0JhY2tPbmxpbmUpO1xuICAgICAgICB3aW4/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9uTmV0d29ya09mZmxpbmUpO1xuICAgICAgICB0ZWFyZG93blNvY2tldChjdHguc29ja2V0KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgY2xlYW51cHMgPSBbXTtcbiAgY29uc3QgeyBzdGF0dXNEaWRDaGFuZ2UsIGRpZENvbm5lY3QsIGRpZERpc2Nvbm5lY3QsIHVuc3Vic2NyaWJlIH0gPSBkZWZpbmVDb25uZWN0aXZpdHlFdmVudHMobWFjaGluZSk7XG4gIGNsZWFudXBzLnB1c2godW5zdWJzY3JpYmUpO1xuICBpZiAob3B0aW9ucy5lbmFibGVEZWJ1Z0xvZ2dpbmcpIHtcbiAgICBjbGVhbnVwcy5wdXNoKGVuYWJsZVRyYWNpbmcobWFjaGluZSkpO1xuICB9XG4gIG1hY2hpbmUuc3RhcnQoKTtcbiAgcmV0dXJuIHtcbiAgICBtYWNoaW5lLFxuICAgIGNsZWFudXBzLFxuICAgIC8vIE9ic2VydmFibGUgZXZlbnRzIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoaXMgbWFjaGluZVxuICAgIGV2ZW50czoge1xuICAgICAgc3RhdHVzRGlkQ2hhbmdlLFxuICAgICAgZGlkQ29ubmVjdCxcbiAgICAgIGRpZERpc2Nvbm5lY3QsXG4gICAgICBvbk1lc3NhZ2U6IG9uTWVzc2FnZS5vYnNlcnZhYmxlLFxuICAgICAgb25MaXZlYmxvY2tzRXJyb3I6IG9uTGl2ZWJsb2Nrc0Vycm9yLm9ic2VydmFibGVcbiAgICB9XG4gIH07XG59XG52YXIgTWFuYWdlZFNvY2tldCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZGVsZWdhdGVzLCBlbmFibGVEZWJ1Z0xvZ2dpbmcgPSBmYWxzZSwgd2FpdEZvckFjdG9ySWQgPSB0cnVlKSB7XG4gICAgY29uc3QgeyBtYWNoaW5lLCBldmVudHMsIGNsZWFudXBzIH0gPSBjcmVhdGVDb25uZWN0aW9uU3RhdGVNYWNoaW5lKFxuICAgICAgZGVsZWdhdGVzLFxuICAgICAgeyB3YWl0Rm9yQWN0b3JJZCwgZW5hYmxlRGVidWdMb2dnaW5nIH1cbiAgICApO1xuICAgIHRoaXMubWFjaGluZSA9IG1hY2hpbmU7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgdGhpcy5jbGVhbnVwcyA9IGNsZWFudXBzO1xuICB9XG4gIGdldExlZ2FjeVN0YXR1cygpIHtcbiAgICByZXR1cm4gbmV3VG9MZWdhY3lTdGF0dXModGhpcy5nZXRTdGF0dXMoKSk7XG4gIH1cbiAgZ2V0U3RhdHVzKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdG9OZXdDb25uZWN0aW9uU3RhdHVzKHRoaXMubWFjaGluZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGF1dGggYXV0aFZhbHVlLlxuICAgKi9cbiAgZ2V0IGF1dGhWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYWNoaW5lLmNvbnRleHQuYXV0aFZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIHRyeSB0byBjb25uZWN0IHRvIGEgV2ViU29ja2V0LiBUaGlzIG9ubHkgaGFzIGFuIGVmZmVjdFxuICAgKiBpZiB0aGUgbWFjaGluZSBpcyBpZGxlIGF0IHRoZSBtb21lbnQsIG90aGVyd2lzZSB0aGlzIGlzIGEgbm8tb3AuXG4gICAqL1xuICBjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIElmIGlkbGUsIHdpbGwgdHJ5IHRvIGNvbm5lY3QuIE90aGVyd2lzZSwgaXQgd2lsbCBhdHRlbXB0IHRvIHJlY29ubmVjdCB0b1xuICAgKiB0aGUgc29ja2V0LCBwb3RlbnRpYWxseSBvYnRhaW5pbmcgYSBuZXcgYXV0aFZhbHVlIGZpcnN0LCBpZiBuZWVkZWQuXG4gICAqL1xuICByZWNvbm5lY3QoKSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlJFQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIGRpc2Nvbm5lY3QgZnJvbSB0aGUgY3VycmVudCBXZWJTb2NrZXQuIElzIGdvaW5nIHRvIGJlXG4gICAqIGEgbm8tb3AgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIGNvbm5lY3Rpb24uXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMubWFjaGluZS5zZW5kKHsgdHlwZTogXCJESVNDT05ORUNUXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhpcyB0byBzdG9wIHRoZSBtYWNoaW5lIGFuZCBydW4gbmVjZXNzYXJ5IGNsZWFudXAgZnVuY3Rpb25zLiBBZnRlclxuICAgKiBjYWxsaW5nIGRlc3Ryb3koKSwgeW91IGNhbiBubyBsb25nZXIgdXNlIHRoaXMgaW5zdGFuY2UuIENhbGwgdGhpcyBiZWZvcmVcbiAgICogbGV0dGluZyB0aGUgaW5zdGFuY2UgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm1hY2hpbmUuc3RvcCgpO1xuICAgIGxldCBjbGVhbnVwO1xuICAgIHdoaWxlIChjbGVhbnVwID0gdGhpcy5jbGVhbnVwcy5wb3AoKSkge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2FmZWx5IHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjdXJyZW50IFdlYlNvY2tldCBjb25uZWN0aW9uLiBXaWxsIGVtaXQgYSBsb2dcbiAgICogbWVzc2FnZSBpZiB0aGlzIGlzIHNvbWVob3cgaW1wb3NzaWJsZS5cbiAgICovXG4gIHNlbmQoZGF0YSkge1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubWFjaGluZS5jb250ZXh0Py5zb2NrZXQ7XG4gICAgaWYgKHNvY2tldCA9PT0gbnVsbCkge1xuICAgICAgd2FybihcIkNhbm5vdCBzZW5kOiBub3QgY29ubmVjdGVkIHlldFwiLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PSAxKSB7XG4gICAgICB3YXJuKFwiQ2Fubm90IHNlbmQ6IFdlYlNvY2tldCBubyBsb25nZXIgb3BlblwiLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBOT1RFOiBVc2VkIGJ5IHRoZSBFMkUgYXBwIG9ubHksIHRvIHNpbXVsYXRlIGV4cGxpY2l0IGV2ZW50cy5cbiAgICogTm90IGlkZWFsIHRvIGtlZXAgZXhwb3NlZCA6KFxuICAgKi9cbiAgX3ByaXZhdGVTZW5kTWFjaGluZUV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5tYWNoaW5lLnNlbmQoZXZlbnQpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdG9jb2wvQXV0aFRva2VuLnRzXG5mdW5jdGlvbiBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKSB7XG4gIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xufVxuZnVuY3Rpb24gY2FuQ29tbWVudChzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcImNvbW1lbnRzOndyaXRlXCIgLyogQ29tbWVudHNXcml0ZSAqLykgfHwgc2NvcGVzLmluY2x1ZGVzKFwicm9vbTp3cml0ZVwiIC8qIFdyaXRlICovKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRBdXRoVG9rZW5QYXlsb2FkKGRhdGEpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoZGF0YSkgJiYgKGRhdGEuayA9PT0gXCJhY2NcIiAvKiBBQ0NFU1NfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcImlkXCIgLyogSURfVE9LRU4gKi8gfHwgZGF0YS5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXV0aFRva2VuKHJhd1Rva2VuU3RyaW5nKSB7XG4gIGNvbnN0IHRva2VuUGFydHMgPSByYXdUb2tlblN0cmluZy5zcGxpdChcIi5cIik7XG4gIGlmICh0b2tlblBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGhlbnRpY2F0aW9uIGVycm9yOiBpbnZhbGlkIEpXVCB0b2tlblwiKTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gdHJ5UGFyc2VKc29uKGI2NGRlY29kZSh0b2tlblBhcnRzWzFdKSk7XG4gIGlmICghKHBheWxvYWQgJiYgaXNWYWxpZEF1dGhUb2tlblBheWxvYWQocGF5bG9hZCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBdXRoZW50aWNhdGlvbiBlcnJvcjogZXhwZWN0ZWQgYSB2YWxpZCB0b2tlbiBidXQgZGlkIG5vdCBnZXQgb25lLiBIaW50OiBpZiB5b3UgYXJlIHVzaW5nIGEgY2FsbGJhY2ssIGVuc3VyZSB0aGUgcm9vbSBpcyBwYXNzZWQgd2hlbiBjcmVhdGluZyB0aGUgdG9rZW4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudENhbGxiYWNrXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmF3OiByYXdUb2tlblN0cmluZyxcbiAgICBwYXJzZWQ6IHBheWxvYWRcbiAgfTtcbn1cblxuLy8gc3JjL2F1dGgtbWFuYWdlci50c1xuZnVuY3Rpb24gY3JlYXRlQXV0aE1hbmFnZXIoYXV0aE9wdGlvbnMpIHtcbiAgY29uc3QgYXV0aGVudGljYXRpb24gPSBwcmVwYXJlQXV0aGVudGljYXRpb24oYXV0aE9wdGlvbnMpO1xuICBjb25zdCBzZWVuVG9rZW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGNvbnN0IGV4cGlyeVRpbWVzID0gW107XG4gIGNvbnN0IHJlcXVlc3RQcm9taXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHNlZW5Ub2tlbnMuY2xlYXIoKTtcbiAgICB0b2tlbnMubGVuZ3RoID0gMDtcbiAgICBleHBpcnlUaW1lcy5sZW5ndGggPSAwO1xuICAgIHJlcXVlc3RQcm9taXNlcy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0NvcnJlc3BvbmRpbmdTY29wZXMocmVxdWVzdGVkU2NvcGUsIHNjb3Blcykge1xuICAgIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJjb21tZW50czpyZWFkXCIpIHtcbiAgICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czpyZWFkXCIgLyogQ29tbWVudHNSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czp3cml0ZVwiIC8qIENvbW1lbnRzV3JpdGUgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJyb29tOnJlYWRcIikge1xuICAgICAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDYWNoZWRUb2tlbihyZXF1ZXN0T3B0aW9ucykge1xuICAgIGNvbnN0IG5vdyA9IE1hdGguY2VpbChEYXRlLm5vdygpIC8gMWUzKTtcbiAgICBmb3IgKGxldCBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IGV4cGlyeVRpbWVzW2ldO1xuICAgICAgaWYgKGV4cGlyZXNBdCA8PSBub3cpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXhwaXJ5VGltZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayA9PT0gXCJpZFwiIC8qIElEX1RPS0VOICovKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4ucGFyc2VkLmsgPT09IFwiYWNjXCIgLyogQUNDRVNTX1RPS0VOICovKSB7XG4gICAgICAgIGlmICghcmVxdWVzdE9wdGlvbnMucm9vbUlkICYmIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3Jlc291cmNlLCBzY29wZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykpIHtcbiAgICAgICAgICBpZiAoIXJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgICAgICAgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiByZXF1ZXN0T3B0aW9ucy5yb29tSWQuc3RhcnRzV2l0aChyZXNvdXJjZS5yZXBsYWNlKFwiKlwiLCBcIlwiKSkgfHwgcmVxdWVzdE9wdGlvbnMucm9vbUlkID09PSByZXNvdXJjZSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFrZUF1dGhSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBmZXRjaGVyID0gYXV0aE9wdGlvbnMucG9seWZpbGxzPy5mZXRjaCA/PyAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHdpbmRvdy5mZXRjaCk7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICBpZiAoZmV0Y2hlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgXCJUbyB1c2UgTGl2ZWJsb2NrcyBjbGllbnQgaW4gYSBub24tRE9NIGVudmlyb25tZW50IHdpdGggYSB1cmwgYXMgYXV0aCBlbmRwb2ludCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIGZldGNoIHBvbHlmaWxsLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQXV0aEVuZHBvaW50KGZldGNoZXIsIGF1dGhlbnRpY2F0aW9uLnVybCwge1xuICAgICAgICByb29tOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICB2ZXJpZnlUb2tlblBlcm1pc3Npb25zKHBhcnNlZCwgb3B0aW9ucyk7XG4gICAgICBpZiAoc2VlblRva2Vucy5oYXMocGFyc2VkLnJhdykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgICBcIlRoZSBzYW1lIExpdmVibG9ja3MgYXV0aCB0b2tlbiB3YXMgaXNzdWVkIGZyb20gdGhlIGJhY2tlbmQgYmVmb3JlLiBDYWNoaW5nIExpdmVibG9ja3MgdG9rZW5zIGlzIG5vdCBzdXBwb3J0ZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcImN1c3RvbVwiKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0aW9uLmNhbGxiYWNrKG9wdGlvbnMucm9vbUlkKTtcbiAgICAgIGlmIChyZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS50b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQXV0aFRva2VuKHJlc3BvbnNlLnRva2VuKTtcbiAgICAgICAgICB2ZXJpZnlUb2tlblBlcm1pc3Npb25zKHBhcnNlZCwgb3B0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2UuZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke1wicmVhc29uXCIgaW4gcmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlLnJlYXNvbiA9PT0gXCJzdHJpbmdcIiA/IHJlc3BvbnNlLnJlYXNvbiA6IFwiRm9yYmlkZGVuXCJ9YDtcbiAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IgPT09IFwiZm9yYmlkZGVuXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcocmVhc29uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdZb3VyIGF1dGhlbnRpY2F0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSB0b2tlbiwgYnV0IGl0IGRpZCBub3QuIEhpbnQ6IHRoZSByZXR1cm4gdmFsdWUgc2hvdWxkIGxvb2sgbGlrZTogeyB0b2tlbjogXCIuLi5cIiB9J1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJVbmV4cGVjdGVkIGF1dGhlbnRpY2F0aW9uIHR5cGUuIE11c3QgYmUgcHJpdmF0ZSBvciBjdXN0b20uXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHZlcmlmeVRva2VuUGVybWlzc2lvbnMocGFyc2VkVG9rZW4sIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMucm9vbUlkICYmIHBhcnNlZFRva2VuLnBhcnNlZC5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLykge1xuICAgICAgaWYgKE9iamVjdC5lbnRyaWVzKHBhcnNlZFRva2VuLnBhcnNlZC5wZXJtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW3Jlc291cmNlLCBzY29wZXNdIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgICBwYXJzZWRUb2tlbi5wYXJzZWQucGVybXNcbiAgICAgICkpIHtcbiAgICAgICAgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKG9wdGlvbnMucmVxdWVzdGVkU2NvcGUsIHNjb3BlcykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgIFwiVGhlIGlzc3VlZCBhY2Nlc3MgdG9rZW4gZG9lc24ndCBncmFudCBlbm91Z2ggcGVybWlzc2lvbnMuIFBsZWFzZSBmb2xsb3cgdGhlIGluc3RydWN0aW9ucyBhdCBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvbGl2ZWJsb2Nrcy1jbGllbnQvYWNjZXNzLXRva2Vucy1ub3QtZW5vdWdoLXBlcm1pc3Npb25zXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEF1dGhWYWx1ZShyZXF1ZXN0T3B0aW9ucykge1xuICAgIGlmIChhdXRoZW50aWNhdGlvbi50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInB1YmxpY1wiLCBwdWJsaWNBcGlLZXk6IGF1dGhlbnRpY2F0aW9uLnB1YmxpY0FwaUtleSB9O1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWRUb2tlbiA9IGdldENhY2hlZFRva2VuKHJlcXVlc3RPcHRpb25zKTtcbiAgICBpZiAoY2FjaGVkVG9rZW4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzZWNyZXRcIiwgdG9rZW46IGNhY2hlZFRva2VuIH07XG4gICAgfVxuICAgIGxldCBjdXJyZW50UHJvbWlzZTtcbiAgICBpZiAocmVxdWVzdE9wdGlvbnMucm9vbUlkKSB7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlcXVlc3RQcm9taXNlcy5nZXQocmVxdWVzdE9wdGlvbnMucm9vbUlkKTtcbiAgICAgIGlmIChjdXJyZW50UHJvbWlzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGN1cnJlbnRQcm9taXNlID0gbWFrZUF1dGhSZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLnNldChyZXF1ZXN0T3B0aW9ucy5yb29tSWQsIGN1cnJlbnRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFByb21pc2UgPSByZXF1ZXN0UHJvbWlzZXMuZ2V0KFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIpO1xuICAgICAgaWYgKGN1cnJlbnRQcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgY3VycmVudFByb21pc2UgPSBtYWtlQXV0aFJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuc2V0KFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIsIGN1cnJlbnRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgY3VycmVudFByb21pc2U7XG4gICAgICBjb25zdCBCVUZGRVIgPSAzMDtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMykgKyAodG9rZW4ucGFyc2VkLmV4cCAtIHRva2VuLnBhcnNlZC5pYXQpIC0gQlVGRkVSO1xuICAgICAgc2VlblRva2Vucy5hZGQodG9rZW4ucmF3KTtcbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayAhPT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLykge1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGV4cGlyeVRpbWVzLnB1c2goZXhwaXJlc0F0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6IFwic2VjcmV0XCIsIHRva2VuIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLmRlbGV0ZShyZXF1ZXN0T3B0aW9ucy5yb29tSWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzLmRlbGV0ZShcImxpdmVibG9ja3MtdXNlci10b2tlblwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXNldCxcbiAgICBnZXRBdXRoVmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVBdXRoZW50aWNhdGlvbihhdXRoT3B0aW9ucykge1xuICBjb25zdCB7IHB1YmxpY0FwaUtleSwgYXV0aEVuZHBvaW50IH0gPSBhdXRoT3B0aW9ucztcbiAgaWYgKGF1dGhFbmRwb2ludCAhPT0gdm9pZCAwICYmIHB1YmxpY0FwaUtleSAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgY2Fubm90IHNpbXVsdGFuZW91c2x5IHVzZSBgcHVibGljQXBpS2V5YCBhbmQgYGF1dGhFbmRwb2ludGAgb3B0aW9ucy4gUGxlYXNlIHBpY2sgb25lIGFuZCBsZWF2ZSB0aGUgb3RoZXIgb3B0aW9uIHVuc3BlY2lmaWVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRcIlxuICAgICk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwdWJsaWNBcGlLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAocHVibGljQXBpS2V5LnN0YXJ0c1dpdGgoXCJza19cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGBwdWJsaWNBcGlLZXlgIG9wdGlvbi4gVGhlIHZhbHVlIHlvdSBwYXNzZWQgaXMgYSBzZWNyZXQga2V5LCB3aGljaCBzaG91bGQgbm90IGJlIHVzZWQgZnJvbSB0aGUgY2xpZW50LiBQbGVhc2Ugb25seSBldmVyIHBhc3MgYSBwdWJsaWMga2V5IGhlcmUuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFB1YmxpY0tleVwiXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIXB1YmxpY0FwaUtleS5zdGFydHNXaXRoKFwicGtfXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBrZXkuIFBsZWFzZSB1c2UgdGhlIHB1YmxpYyBrZXkgZm9ybWF0OiBwa188cHVibGljIGtleT4uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFB1YmxpY0tleVwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwdWJsaWNcIixcbiAgICAgIHB1YmxpY0FwaUtleVxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBhdXRoRW5kcG9pbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwcml2YXRlXCIsXG4gICAgICB1cmw6IGF1dGhFbmRwb2ludFxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGF1dGhFbmRwb2ludCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgICBjYWxsYmFjazogYXV0aEVuZHBvaW50XG4gICAgfTtcbiAgfSBlbHNlIGlmIChhdXRoRW5kcG9pbnQgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlIGBhdXRoRW5kcG9pbnRgIG9wdGlvbiBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudEF1dGhFbmRwb2ludFwiXG4gICAgKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJJbnZhbGlkIExpdmVibG9ja3MgY2xpZW50IG9wdGlvbnMuIFBsZWFzZSBwcm92aWRlIGVpdGhlciBhIGBwdWJsaWNBcGlLZXlgIG9yIGBhdXRoRW5kcG9pbnRgIG9wdGlvbi4gVGhleSBjYW5ub3QgYm90aCBiZSBlbXB0eS4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50XCJcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQXV0aEVuZHBvaW50KGZldGNoMiwgZW5kcG9pbnQsIGJvZHkpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2gyKGVuZHBvaW50LCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgfSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgY29uc3QgcmVhc29uID0gYCR7KGF3YWl0IHJlcy50ZXh0KCkpLnRyaW0oKSB8fCBcInJlYXNvbiBub3QgcHJvdmlkZWQgaW4gYXV0aCByZXNwb25zZVwifSAoJHtyZXMuc3RhdHVzfSByZXR1cm5lZCBieSBQT1NUICR7ZW5kcG9pbnR9KWA7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSB8fCByZXMuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoYFVuYXV0aG9yaXplZDogJHtyZWFzb259YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZTogJHtyZWFzb259YCk7XG4gICAgfVxuICB9XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhIEpTT04gcmVzcG9uc2Ugd2hlbiBkb2luZyBhIFBPU1QgcmVxdWVzdCBvbiBcIiR7ZW5kcG9pbnR9XCIuICR7U3RyaW5nKFxuICAgICAgICBlclxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkgfHwgdHlwZW9mIGRhdGEudG9rZW4gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBKU09OIHJlc3BvbnNlIG9mIHRoZSBmb3JtIFxcYHsgdG9rZW46IFwiLi4uXCIgfVxcYCB3aGVuIGRvaW5nIGEgUE9TVCByZXF1ZXN0IG9uIFwiJHtlbmRwb2ludH1cIiwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBkYXRhXG4gICAgICApfWBcbiAgICApO1xuICB9XG4gIGNvbnN0IHsgdG9rZW4gfSA9IGRhdGE7XG4gIHJldHVybiB7IHRva2VuIH07XG59XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBERUZBVUxUX0JBU0VfVVJMID0gXCJodHRwczovL2FwaS5saXZlYmxvY2tzLmlvXCI7XG5cbi8vIHNyYy9pbnRlcm5hbC50c1xudmFyIGtJbnRlcm5hbCA9IFN5bWJvbCgpO1xuXG4vLyBzcmMvZGV2dG9vbHMvYnJpZGdlLnRzXG52YXIgX2JyaWRnZUFjdGl2ZSA9IGZhbHNlO1xuZnVuY3Rpb24gYWN0aXZhdGVCcmlkZ2UoYWxsb3dlZCkge1xuICBfYnJpZGdlQWN0aXZlID0gYWxsb3dlZDtcbn1cbmZ1bmN0aW9uIHNlbmRUb1BhbmVsKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZ1bGxNc2cgPSB7XG4gICAgLi4ubWVzc2FnZSxcbiAgICBzb3VyY2U6IFwibGl2ZWJsb2Nrcy1kZXZ0b29scy1jbGllbnRcIlxuICB9O1xuICBpZiAoIShvcHRpb25zPy5mb3JjZSB8fCBfYnJpZGdlQWN0aXZlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cucG9zdE1lc3NhZ2UoZnVsbE1zZywgXCIqXCIpO1xufVxudmFyIGV2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhPy5zb3VyY2UgPT09IFwibGl2ZWJsb2Nrcy1kZXZ0b29scy1wYW5lbFwiKSB7XG4gICAgICBldmVudFNvdXJjZS5ub3RpZnkoZXZlbnQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICB9XG4gIH0pO1xufVxudmFyIG9uTWVzc2FnZUZyb21QYW5lbCA9IGV2ZW50U291cmNlLm9ic2VydmFibGU7XG5cbi8vIHNyYy9kZXZ0b29scy9pbmRleC50c1xudmFyIFZFUlNJT04gPSBQS0dfVkVSU0lPTiB8fCBcImRldlwiO1xudmFyIF9kZXZ0b29sc1NldHVwSGFzUnVuID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cERldlRvb2xzKGdldEFsbFJvb21zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoX2RldnRvb2xzU2V0dXBIYXNSdW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgX2RldnRvb2xzU2V0dXBIYXNSdW4gPSB0cnVlO1xuICBvbk1lc3NhZ2VGcm9tUGFuZWwuc3Vic2NyaWJlKChtc2cpID0+IHtcbiAgICBzd2l0Y2ggKG1zZy5tc2cpIHtcbiAgICAgIGNhc2UgXCJjb25uZWN0XCI6IHtcbiAgICAgICAgYWN0aXZhdGVCcmlkZ2UodHJ1ZSk7XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbUlkIG9mIGdldEFsbFJvb21zKCkpIHtcbiAgICAgICAgICBzZW5kVG9QYW5lbCh7XG4gICAgICAgICAgICBtc2c6IFwicm9vbTo6YXZhaWxhYmxlXCIsXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICBjbGllbnRWZXJzaW9uOiBWRVJTSU9OXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VuZFRvUGFuZWwoeyBtc2c6IFwid2FrZS11cC1kZXZ0b29sc1wiIH0sIHsgZm9yY2U6IHRydWUgfSk7XG59XG52YXIgdW5zdWJzQnlSb29tSWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gc3RvcFN5bmNTdHJlYW0ocm9vbUlkKSB7XG4gIGNvbnN0IHVuc3VicyA9IHVuc3Vic0J5Um9vbUlkLmdldChyb29tSWQpID8/IFtdO1xuICB1bnN1YnNCeVJvb21JZC5kZWxldGUocm9vbUlkKTtcbiAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICB1bnN1YigpO1xuICB9XG59XG5mdW5jdGlvbiBzdGFydFN5bmNTdHJlYW0ocm9vbSkge1xuICBzdG9wU3luY1N0cmVhbShyb29tLmlkKTtcbiAgZnVsbFN5bmMocm9vbSk7XG4gIHVuc3Vic0J5Um9vbUlkLnNldChyb29tLmlkLCBbXG4gICAgLy8gV2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlc1xuICAgIHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNDb25uZWN0aW9uKHJvb20pKSxcbiAgICAvLyBXaGVuIHN0b3JhZ2UgaW5pdGlhbGl6ZXMsIHNlbmQgdGhlIHVwZGF0ZVxuICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2UoKCkgPT4gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSBzdG9yYWdlIHVwZGF0ZXMsIHNlbmQgdGhlIG5ldyBzdG9yYWdlIHJvb3RcbiAgICByb29tLmV2ZW50cy5zdG9yYWdlLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIFwibWVcIiBvciBcIm90aGVyc1wiIHVwZGF0ZXMsIHNlbmQgdGhlIG5ldyB2YWx1ZXMgYWNjb3JkaW5nbHlcbiAgICByb29tLmV2ZW50cy5zZWxmLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY01lKHJvb20pKSxcbiAgICByb29tLmV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKCgpID0+IHBhcnRpYWxTeW5jT3RoZXJzKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSB5ZG9jIGlzIHVwZGF0ZWQsIGZvcndhcmQgdGhlIHVwZGF0ZVxuICAgIHJvb20uZXZlbnRzLnlkb2Muc3Vic2NyaWJlKCh1cGRhdGUpID0+IHN5bmNZZG9jVXBkYXRlKHJvb20sIHVwZGF0ZSkpLFxuICAgIC8vIEFueSB0aW1lIGEgY3VzdG9tIHJvb20gZXZlbnQgaXMgcmVjZWl2ZWQsIGZvcndhcmQgaXRcbiAgICByb29tLmV2ZW50cy5jdXN0b21FdmVudC5zdWJzY3JpYmUoXG4gICAgICAoZXZlbnREYXRhKSA9PiBmb3J3YXJkRXZlbnQocm9vbSwgZXZlbnREYXRhKVxuICAgIClcbiAgXSk7XG59XG5mdW5jdGlvbiBzeW5jWWRvY1VwZGF0ZShyb29tLCB1cGRhdGUpIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjp5ZG9jXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHVwZGF0ZVxuICB9KTtcbn1cbnZhciBsb2FkZWRBdCA9IERhdGUubm93KCk7XG52YXIgZXZlbnRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIG5leHRFdmVudElkKCkge1xuICByZXR1cm4gYGV2ZW50LSR7bG9hZGVkQXR9LSR7ZXZlbnRDb3VudGVyKyt9YDtcbn1cbmZ1bmN0aW9uIGZvcndhcmRFdmVudChyb29tLCBldmVudERhdGEpIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpldmVudHM6OmN1c3RvbS1ldmVudFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBldmVudDoge1xuICAgICAgdHlwZTogXCJDdXN0b21FdmVudFwiLFxuICAgICAgaWQ6IG5leHRFdmVudElkKCksXG4gICAgICBrZXk6IFwiRXZlbnRcIixcbiAgICAgIGNvbm5lY3Rpb25JZDogZXZlbnREYXRhLmNvbm5lY3Rpb25JZCxcbiAgICAgIHBheWxvYWQ6IGV2ZW50RGF0YS5ldmVudFxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY0Nvbm5lY3Rpb24ocm9vbSkge1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgc3RhdHVzOiByb29tLmdldFN0YXR1cygpXG4gIH0pO1xufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pIHtcbiAgY29uc3Qgcm9vdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCk7XG4gIGlmIChyb290KSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIHN0b3JhZ2U6IHJvb3QudG9UcmVlTm9kZShcInJvb3RcIikucGF5bG9hZFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJ0aWFsU3luY01lKHJvb20pIHtcbiAgY29uc3QgbWUgPSByb29tW2tJbnRlcm5hbF0uZ2V0U2VsZl9mb3JEZXZUb29scygpO1xuICBpZiAobWUpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgbWVcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNPdGhlcnMocm9vbSkge1xuICBjb25zdCBvdGhlcnMgPSByb29tW2tJbnRlcm5hbF0uZ2V0T3RoZXJzX2ZvckRldlRvb2xzKCk7XG4gIGlmIChvdGhlcnMpIHtcbiAgICBzZW5kVG9QYW5lbCh7XG4gICAgICBtc2c6IFwicm9vbTo6c3luYzo6cGFydGlhbFwiLFxuICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgb3RoZXJzXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZ1bGxTeW5jKHJvb20pIHtcbiAgY29uc3Qgcm9vdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCk7XG4gIGNvbnN0IG1lID0gcm9vbVtrSW50ZXJuYWxdLmdldFNlbGZfZm9yRGV2VG9vbHMoKTtcbiAgY29uc3Qgb3RoZXJzID0gcm9vbVtrSW50ZXJuYWxdLmdldE90aGVyc19mb3JEZXZUb29scygpO1xuICByb29tLmZldGNoWURvYyhcIlwiKTtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjpmdWxsXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHN0YXR1czogcm9vbS5nZXRTdGF0dXMoKSxcbiAgICBzdG9yYWdlOiByb290Py50b1RyZWVOb2RlKFwicm9vdFwiKS5wYXlsb2FkID8/IG51bGwsXG4gICAgbWUsXG4gICAgb3RoZXJzXG4gIH0pO1xufVxudmFyIHJvb21DaGFubmVsTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCkge1xuICBjb25zdCBsaXN0ZW5lciA9IHJvb21DaGFubmVsTGlzdGVuZXJzLmdldChyb29tSWQpO1xuICByb29tQ2hhbm5lbExpc3RlbmVycy5kZWxldGUocm9vbUlkKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgbGlzdGVuZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gbGlua0RldlRvb2xzKHJvb21JZCwgcm9vbSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2VuZFRvUGFuZWwoeyBtc2c6IFwicm9vbTo6YXZhaWxhYmxlXCIsIHJvb21JZCwgY2xpZW50VmVyc2lvbjogVkVSU0lPTiB9KTtcbiAgc3RvcFJvb21DaGFubmVsTGlzdGVuZXIocm9vbUlkKTtcbiAgcm9vbUNoYW5uZWxMaXN0ZW5lcnMuc2V0KFxuICAgIHJvb21JZCxcbiAgICAvLyBSZXR1cm5zIHRoZSB1bnN1YnNjcmliZSBjYWxsYmFjaywgdGhhdCB3ZSBzdG9yZSBpbiB0aGVcbiAgICAvLyByb29tQ2hhbm5lbExpc3RlbmVycyByZWdpc3RyeVxuICAgIG9uTWVzc2FnZUZyb21QYW5lbC5zdWJzY3JpYmUoKG1zZykgPT4ge1xuICAgICAgc3dpdGNoIChtc2cubXNnKSB7XG4gICAgICAgIGNhc2UgXCJyb29tOjpzdWJzY3JpYmVcIjoge1xuICAgICAgICAgIGlmIChtc2cucm9vbUlkID09PSByb29tSWQpIHtcbiAgICAgICAgICAgIHN0YXJ0U3luY1N0cmVhbShyb29tKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJvb206OnVuc3Vic2NyaWJlXCI6IHtcbiAgICAgICAgICBpZiAobXNnLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICAgICAgICBzdG9wU3luY1N0cmVhbShyb29tSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiB1bmxpbmtEZXZUb29scyhyb29tSWQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0b3BTeW5jU3RyZWFtKHJvb21JZCk7XG4gIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCk7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6dW5hdmFpbGFibGVcIixcbiAgICByb29tSWRcbiAgfSk7XG59XG5cbi8vIHNyYy9saWIvc3RyaW5naWZ5LnRzXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqZWN0LCAuLi5hcmdzKSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiIHx8IG9iamVjdCA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqZWN0LCAuLi5hcmdzKTtcbiAgfVxuICBjb25zdCBzb3J0ZWRPYmplY3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLnNvcnQoKS5yZWR1Y2UoXG4gICAgKHNvcnRlZE9iamVjdDIsIGtleSkgPT4ge1xuICAgICAgc29ydGVkT2JqZWN0MltrZXldID0gb2JqZWN0W2tleV07XG4gICAgICByZXR1cm4gc29ydGVkT2JqZWN0MjtcbiAgICB9LFxuICAgIHt9XG4gICk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzb3J0ZWRPYmplY3QsIC4uLmFyZ3MpO1xufVxuXG4vLyBzcmMvbGliL2JhdGNoLnRzXG52YXIgREVGQVVMVF9TSVpFID0gNTA7XG52YXIgREVGQVVMVF9ERUxBWSA9IDEwMDtcbnZhciBub29wID0gKCkgPT4ge1xufTtcbnZhciBCYXRjaENhbGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLnJlc29sdmUgPSBub29wO1xuICAgIHRoaXMucmVqZWN0ID0gbm9vcDtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShub29wKTtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICB9XG59O1xudmFyIEJhdGNoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLmVycm9yID0gZmFsc2U7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnM/LnNpemUgPz8gREVGQVVMVF9TSVpFO1xuICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zPy5kZWxheSA/PyBERUZBVUxUX0RFTEFZO1xuICB9XG4gIGNsZWFyRGVsYXlUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLmRlbGF5VGltZW91dElkICE9PSB2b2lkIDApIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZW91dElkKTtcbiAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHNjaGVkdWxlKCkge1xuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gdGhpcy5zaXplKSB7XG4gICAgICB2b2lkIHRoaXMuZmx1c2goKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmNsZWFyRGVsYXlUaW1lb3V0KCk7XG4gICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB2b2lkIHRoaXMuZmx1c2goKSwgdGhpcy5kZWxheSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZsdXNoKCkge1xuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYWxscyA9IHRoaXMucXVldWUuc3BsaWNlKDApO1xuICAgIGNvbnN0IGFyZ3MgPSBjYWxscy5tYXAoKGNhbGwpID0+IGNhbGwuYXJncyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmNhbGxiYWNrKGFyZ3MpO1xuICAgICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgICAgY2FsbHMuZm9yRWFjaCgoY2FsbCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0cz8uW2luZGV4XTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgY2FsbC5yZWplY3QocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNhbGwucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgICAgICBjYWxsLnJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBCYXRjaCBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheSBvZiB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIG51bWJlciBvZiBjYWxscyBpbiB0aGUgYmF0Y2guIEV4cGVjdGVkICR7Y2FsbHMubGVuZ3RofSwgYnV0IGdvdCAke3Jlc3VsdHMubGVuZ3RofS5gXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGwucmVqZWN0KG5ldyBFcnJvcihcIkJhdGNoIGNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5LlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSB0cnVlO1xuICAgICAgY2FsbHMuZm9yRWFjaCgoY2FsbCkgPT4ge1xuICAgICAgICBjYWxsLnJlamVjdChlcnJvcjMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCguLi5hcmdzKSB7XG4gICAgY29uc3QgZXhpc3RpbmdDYWxsID0gdGhpcy5xdWV1ZS5maW5kKFxuICAgICAgKGNhbGwyKSA9PiBzdHJpbmdpZnkoY2FsbDIuYXJncykgPT09IHN0cmluZ2lmeShhcmdzKVxuICAgICk7XG4gICAgaWYgKGV4aXN0aW5nQ2FsbCkge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nQ2FsbC5wcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBjYWxsID0gbmV3IEJhdGNoQ2FsbChhcmdzKTtcbiAgICBjYWxsLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjYWxsLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgY2FsbC5yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKGNhbGwpO1xuICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICByZXR1cm4gY2FsbC5wcm9taXNlO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLmVycm9yID0gZmFsc2U7XG4gICAgdGhpcy5jbGVhckRlbGF5VGltZW91dCgpO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlQmF0Y2hTdG9yZShjYWxsYmFjaywgb3B0aW9ucykge1xuICBjb25zdCBiYXRjaCA9IG5ldyBCYXRjaChjYWxsYmFjaywgb3B0aW9ucyk7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgZXZlbnRTb3VyY2UyID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGZ1bmN0aW9uIGdldENhY2hlS2V5KGFyZ3MpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5KGFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIHNldFN0YXRlQW5kTm90aWZ5KGNhY2hlS2V5LCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgfVxuICAgIGV2ZW50U291cmNlMi5ub3RpZnkoc3RhdGUpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldCguLi5hcmdzKSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShhcmdzKTtcbiAgICBpZiAoY2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgc2V0U3RhdGVBbmROb3RpZnkoY2FjaGVLZXksIHsgaXNMb2FkaW5nOiB0cnVlIH0pO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmF0Y2guZ2V0KC4uLmFyZ3MpO1xuICAgICAgc2V0U3RhdGVBbmROb3RpZnkoY2FjaGVLZXksIHsgaXNMb2FkaW5nOiBmYWxzZSwgZGF0YTogcmVzdWx0IH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yMykge1xuICAgICAgc2V0U3RhdGVBbmROb3RpZnkoY2FjaGVLZXksIHtcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yM1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXRlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KGFyZ3MpO1xuICAgIHJldHVybiBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZXZlbnRTb3VyY2UyLFxuICAgIGdldCxcbiAgICBnZXRTdGF0ZVxuICB9O1xufVxuXG4vLyBzcmMvbGliL2NyZWF0ZS1zdG9yZS50c1xuZnVuY3Rpb24gY3JlYXRlU3RvcmUoaW5pdGlhbFN0YXRlKSB7XG4gIGxldCBzdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgY29uc3Qgc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGZ1bmN0aW9uIHNldChjYWxsYmFjaykge1xuICAgIGNvbnN0IG5ld1N0YXRlID0gY2FsbGJhY2soc3RhdGUpO1xuICAgIGlmIChzdGF0ZSA9PT0gbmV3U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICBmb3IgKGNvbnN0IHN1YnNjcmliZXIgb2Ygc3Vic2NyaWJlcnMpIHtcbiAgICAgIHN1YnNjcmliZXIoc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICBzdWJzY3JpYmVycy5hZGQoY2FsbGJhY2spO1xuICAgIGNhbGxiYWNrKHN0YXRlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaWJlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0LFxuICAgIHNldCxcbiAgICBzdWJzY3JpYmVcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9kZXByZWNhdGlvbi50c1xudmFyIF9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5mdW5jdGlvbiBkZXByZWNhdGUobWVzc2FnZSwga2V5ID0gbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFfZW1pdHRlZERlcHJlY2F0aW9uV2FybmluZ3MuaGFzKGtleSkpIHtcbiAgICAgIF9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncy5hZGQoa2V5KTtcbiAgICAgIGVycm9yV2l0aFRpdGxlKFwiRGVwcmVjYXRpb24gd2FybmluZ1wiLCBtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZUlmKGNvbmRpdGlvbiwgbWVzc2FnZSwga2V5ID0gbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgZGVwcmVjYXRlKG1lc3NhZ2UsIGtleSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0aHJvd1VzYWdlRXJyb3IobWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgdXNhZ2VFcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB1c2FnZUVycm9yLm5hbWUgPSBcIlVzYWdlIGVycm9yXCI7XG4gICAgZXJyb3JXaXRoVGl0bGUoXCJVc2FnZSBlcnJvclwiLCBtZXNzYWdlKTtcbiAgICB0aHJvdyB1c2FnZUVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcklmKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgdGhyb3dVc2FnZUVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvY29udmVydC1wbGFpbi1kYXRhLnRzXG5mdW5jdGlvbiBjb252ZXJ0VG9Db21tZW50RGF0YShkYXRhKSB7XG4gIGNvbnN0IGVkaXRlZEF0ID0gZGF0YS5lZGl0ZWRBdCA/IG5ldyBEYXRlKGRhdGEuZWRpdGVkQXQpIDogdm9pZCAwO1xuICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gIGNvbnN0IHJlYWN0aW9ucyA9IGRhdGEucmVhY3Rpb25zLm1hcCgocmVhY3Rpb24pID0+ICh7XG4gICAgLi4ucmVhY3Rpb24sXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShyZWFjdGlvbi5jcmVhdGVkQXQpXG4gIH0pKTtcbiAgaWYgKGRhdGEuYm9keSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgcmVhY3Rpb25zLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgZWRpdGVkQXRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRlbGV0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuZGVsZXRlZEF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIHJlYWN0aW9ucyxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGVkaXRlZEF0LFxuICAgICAgZGVsZXRlZEF0XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gY29udmVydFRvVGhyZWFkRGF0YShkYXRhKSB7XG4gIGNvbnN0IHVwZGF0ZWRBdCA9IGRhdGEudXBkYXRlZEF0ID8gbmV3IERhdGUoZGF0YS51cGRhdGVkQXQpIDogdm9pZCAwO1xuICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gIGNvbnN0IGNvbW1lbnRzID0gZGF0YS5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpXG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBjcmVhdGVkQXQsXG4gICAgdXBkYXRlZEF0LFxuICAgIGNvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEoZGF0YSkge1xuICBjb25zdCBub3RpZmllZEF0ID0gbmV3IERhdGUoZGF0YS5ub3RpZmllZEF0KTtcbiAgY29uc3QgcmVhZEF0ID0gZGF0YS5yZWFkQXQgPyBuZXcgRGF0ZShkYXRhLnJlYWRBdCkgOiBudWxsO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgbm90aWZpZWRBdCxcbiAgICByZWFkQXRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8oZGF0YSkge1xuICBjb25zdCBkZWxldGVkQXQgPSBuZXcgRGF0ZShkYXRhLmRlbGV0ZWRBdCk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBkZWxldGVkQXRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGVsZXRlSW5mbyhkYXRhKSB7XG4gIGNvbnN0IGRlbGV0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuZGVsZXRlZEF0KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGRlbGV0ZWRBdFxuICB9O1xufVxuXG4vLyBzcmMvbGliL3VybC50c1xuZnVuY3Rpb24gdG9VUkxTZWFyY2hQYXJhbXMocGFyYW1zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1cmxqb2luKGJhc2VVcmwsIHBhdGgsIHBhcmFtcykge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhdGgsIGJhc2VVcmwpO1xuICBpZiAocGFyYW1zICE9PSB2b2lkIDApIHtcbiAgICB1cmwuc2VhcmNoID0gKHBhcmFtcyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyA/IHBhcmFtcyA6IHRvVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHVybC50b1N0cmluZygpO1xufVxuXG4vLyBzcmMvbm90aWZpY2F0aW9ucy50c1xudmFyIE1BUktfSU5CT1hfTk9USUZJQ0FUSU9OU19BU19SRUFEX0JBVENIX0RFTEFZID0gNTA7XG5mdW5jdGlvbiBjcmVhdGVOb3RpZmljYXRpb25zQXBpKHtcbiAgYmFzZVVybCxcbiAgYXV0aE1hbmFnZXIsXG4gIGN1cnJlbnRVc2VySWRTdG9yZSxcbiAgZmV0Y2hlclxufSkge1xuICBhc3luYyBmdW5jdGlvbiBmZXRjaEpzb24oZW5kcG9pbnQsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCJcbiAgICB9KTtcbiAgICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwic2VjcmV0XCIgJiYgYXV0aFZhbHVlLnRva2VuLnBhcnNlZC5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLykge1xuICAgICAgY29uc3QgdXNlcklkID0gYXV0aFZhbHVlLnRva2VuLnBhcnNlZC51aWQ7XG4gICAgICBjdXJyZW50VXNlcklkU3RvcmUuc2V0KCgpID0+IHVzZXJJZCk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IHVybGpvaW4oYmFzZVVybCwgYC92Mi9jJHtlbmRwb2ludH1gLCBwYXJhbXMpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hlcih1cmwudG9TdHJpbmcoKSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2dldEF1dGhCZWFyZXJIZWFkZXJGcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSl9YFxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDYwMCkge1xuICAgICAgICBsZXQgZXJyb3IzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgTm90aWZpY2F0aW9uc0FwaUVycm9yKFxuICAgICAgICAgICAgZXJyb3JCb2R5Lm1lc3NhZ2UsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBlcnJvckJvZHlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgTm90aWZpY2F0aW9uc0FwaUVycm9yKFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGJvZHkgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0SW5ib3hOb3RpZmljYXRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgZmV0Y2hKc29uKFwiL2luYm94LW5vdGlmaWNhdGlvbnNcIiwgdm9pZCAwLCB7XG4gICAgICBsaW1pdDogb3B0aW9ucz8ubGltaXQsXG4gICAgICBzaW5jZTogb3B0aW9ucz8uc2luY2U/LnRvSVNPU3RyaW5nKClcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdGhyZWFkczoganNvbi50aHJlYWRzLm1hcCgodGhyZWFkKSA9PiBjb252ZXJ0VG9UaHJlYWREYXRhKHRocmVhZCkpLFxuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgIChub3RpZmljYXRpb24pID0+IGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShub3RpZmljYXRpb24pXG4gICAgICApLFxuICAgICAgZGVsZXRlZFRocmVhZHM6IGpzb24uZGVsZXRlZFRocmVhZHMubWFwKFxuICAgICAgICAoaW5mbykgPT4gY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbyhpbmZvKVxuICAgICAgKSxcbiAgICAgIGRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnM6IGpzb24uZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucy5tYXAoXG4gICAgICAgIChpbmZvKSA9PiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm8oaW5mbylcbiAgICAgICksXG4gICAgICBtZXRhOiB7XG4gICAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCgpIHtcbiAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBmZXRjaEpzb24oXCIvaW5ib3gtbm90aWZpY2F0aW9ucy9jb3VudFwiKTtcbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCgpIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXCIvaW5ib3gtbm90aWZpY2F0aW9ucy9yZWFkXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpbmJveE5vdGlmaWNhdGlvbklkczogXCJhbGxcIiB9KVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZHMpIHtcbiAgICBhd2FpdCBmZXRjaEpzb24oXCIvaW5ib3gtbm90aWZpY2F0aW9ucy9yZWFkXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpbmJveE5vdGlmaWNhdGlvbklkcyB9KVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGJhdGNoZWRNYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkID0gbmV3IEJhdGNoKFxuICAgIGFzeW5jIChiYXRjaGVkSW5ib3hOb3RpZmljYXRpb25JZHMpID0+IHtcbiAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9uSWRzID0gYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzLmZsYXQoKTtcbiAgICAgIGF3YWl0IG1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZHMpO1xuICAgICAgcmV0dXJuIGluYm94Tm90aWZpY2F0aW9uSWRzO1xuICAgIH0sXG4gICAgeyBkZWxheTogTUFSS19JTkJPWF9OT1RJRklDQVRJT05TX0FTX1JFQURfQkFUQ0hfREVMQVkgfVxuICApO1xuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICAgIGF3YWl0IGJhdGNoZWRNYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLmdldChpbmJveE5vdGlmaWNhdGlvbklkKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZFxuICB9O1xufVxuXG4vLyBzcmMvbGliL3Bvc2l0aW9uLnRzXG52YXIgTUlOX0NPREUgPSAzMjtcbnZhciBNQVhfQ09ERSA9IDEyNjtcbnZhciBOVU1fRElHSVRTID0gTUFYX0NPREUgLSBNSU5fQ09ERSArIDE7XG52YXIgWkVSTyA9IG50aERpZ2l0KDApO1xudmFyIE9ORSA9IG50aERpZ2l0KDEpO1xudmFyIFpFUk9fTklORSA9IFpFUk8gKyBudGhEaWdpdCgtMSk7XG5mdW5jdGlvbiBudGhEaWdpdChuKSB7XG4gIGNvbnN0IGNvZGUgPSBNSU5fQ09ERSArIChuIDwgMCA/IE5VTV9ESUdJVFMgKyBuIDogbik7XG4gIGlmIChjb2RlIDwgTUlOX0NPREUgfHwgY29kZSA+IE1BWF9DT0RFKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG4gdmFsdWU6ICR7bn1gKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbn1cbmZ1bmN0aW9uIG1ha2VQb3NpdGlvbih4LCB5KSB7XG4gIGlmICh4ICE9PSB2b2lkIDAgJiYgeSAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGJldHdlZW4oeCwgeSk7XG4gIH0gZWxzZSBpZiAoeCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGFmdGVyKHgpO1xuICB9IGVsc2UgaWYgKHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZWZvcmUoeSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE9ORTtcbiAgfVxufVxuZnVuY3Rpb24gYmVmb3JlKHBvcykge1xuICBjb25zdCBsYXN0SW5kZXggPSBwb3MubGVuZ3RoIC0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGFzdEluZGV4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gcG9zLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPD0gTUlOX0NPREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gbGFzdEluZGV4KSB7XG4gICAgICBpZiAoY29kZSA9PT0gTUlOX0NPREUgKyAxKSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgWkVST19OSU5FO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSArIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT05FO1xufVxuZnVuY3Rpb24gYWZ0ZXIocG9zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IHBvcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gcG9zLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPj0gTUFYX0NPREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSArIDEpO1xuICB9XG4gIHJldHVybiBwb3MgKyBPTkU7XG59XG5mdW5jdGlvbiBiZXR3ZWVuKGxvLCBoaSkge1xuICBpZiAobG8gPCBoaSkge1xuICAgIHJldHVybiBfYmV0d2VlbihsbywgaGkpO1xuICB9IGVsc2UgaWYgKGxvID4gaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4oaGksIGxvKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSB2YWx1ZSBiZXR3ZWVuIHR3byBlcXVhbCBwb3NpdGlvbnNcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9iZXR3ZWVuKGxvLCBoaSkge1xuICBsZXQgaW5kZXggPSAwO1xuICBjb25zdCBsb0xlbiA9IGxvLmxlbmd0aDtcbiAgY29uc3QgaGlMZW4gPSBoaS5sZW5ndGg7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbG9Db2RlID0gaW5kZXggPCBsb0xlbiA/IGxvLmNoYXJDb2RlQXQoaW5kZXgpIDogTUlOX0NPREU7XG4gICAgY29uc3QgaGlDb2RlID0gaW5kZXggPCBoaUxlbiA/IGhpLmNoYXJDb2RlQXQoaW5kZXgpIDogTUFYX0NPREU7XG4gICAgaWYgKGxvQ29kZSA9PT0gaGlDb2RlKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChoaUNvZGUgLSBsb0NvZGUgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBpbmRleCArIDE7XG4gICAgICBsZXQgcHJlZml4ID0gbG8uc3Vic3RyaW5nKDAsIHNpemUpO1xuICAgICAgaWYgKHByZWZpeC5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgIHByZWZpeCArPSBaRVJPLnJlcGVhdChzaXplIC0gcHJlZml4Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdWZmaXggPSBsby5zdWJzdHJpbmcoc2l6ZSk7XG4gICAgICBjb25zdCBuaW5lcyA9IFwiXCI7XG4gICAgICByZXR1cm4gcHJlZml4ICsgX2JldHdlZW4oc3VmZml4LCBuaW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0YWtlTihsbywgaW5kZXgpICsgU3RyaW5nLmZyb21DaGFyQ29kZShoaUNvZGUgKyBsb0NvZGUgPj4gMSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0YWtlTihwb3MsIG4pIHtcbiAgcmV0dXJuIG4gPCBwb3MubGVuZ3RoID8gcG9zLnN1YnN0cmluZygwLCBuKSA6IHBvcyArIFpFUk8ucmVwZWF0KG4gLSBwb3MubGVuZ3RoKTtcbn1cbnZhciBNSU5fTk9OX1pFUk9fQ09ERSA9IE1JTl9DT0RFICsgMTtcbmZ1bmN0aW9uIGlzUG9zKHN0cikge1xuICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxhc3RJZHggPSBzdHIubGVuZ3RoIC0gMTtcbiAgY29uc3QgbGFzdCA9IHN0ci5jaGFyQ29kZUF0KGxhc3RJZHgpO1xuICBpZiAobGFzdCA8IE1JTl9OT05fWkVST19DT0RFIHx8IGxhc3QgPiBNQVhfQ09ERSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJZHg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1BvcyhzdHIpIHtcbiAgY29uc3QgY29kZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgY29kZXMucHVzaChjb2RlIDwgTUlOX0NPREUgPyBNSU5fQ09ERSA6IGNvZGUgPiBNQVhfQ09ERSA/IE1BWF9DT0RFIDogY29kZSk7XG4gIH1cbiAgd2hpbGUgKGNvZGVzLmxlbmd0aCA+IDAgJiYgY29kZXNbY29kZXMubGVuZ3RoIC0gMV0gPT09IE1JTl9DT0RFKSB7XG4gICAgY29kZXMubGVuZ3RoLS07XG4gIH1cbiAgcmV0dXJuIGNvZGVzLmxlbmd0aCA+IDAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmNvZGVzKSA6IChcbiAgICAvLyBFZGdlIGNhc2U6IHRoZSBzdHIgd2FzIGEgMC1vbmx5IHN0cmluZywgd2hpY2ggaXMgaW52YWxpZC4gRGVmYXVsdCBiYWNrIHRvIC4xXG4gICAgT05FXG4gICk7XG59XG5mdW5jdGlvbiBhc1BvcyhzdHIpIHtcbiAgcmV0dXJuIGlzUG9zKHN0cikgPyBzdHIgOiBjb252ZXJ0VG9Qb3Moc3RyKTtcbn1cblxuLy8gc3JjL3Byb3RvY29sL09wLnRzXG52YXIgT3BDb2RlID0gLyogQF9fUFVSRV9fICovICgoT3BDb2RlMikgPT4ge1xuICBPcENvZGUyW09wQ29kZTJbXCJJTklUXCJdID0gMF0gPSBcIklOSVRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiU0VUX1BBUkVOVF9LRVlcIl0gPSAxXSA9IFwiU0VUX1BBUkVOVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX0xJU1RcIl0gPSAyXSA9IFwiQ1JFQVRFX0xJU1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiVVBEQVRFX09CSkVDVFwiXSA9IDNdID0gXCJVUERBVEVfT0JKRUNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9PQkpFQ1RcIl0gPSA0XSA9IFwiQ1JFQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJERUxFVEVfQ1JEVFwiXSA9IDVdID0gXCJERUxFVEVfQ1JEVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJERUxFVEVfT0JKRUNUX0tFWVwiXSA9IDZdID0gXCJERUxFVEVfT0JKRUNUX0tFWVwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfTUFQXCJdID0gN10gPSBcIkNSRUFURV9NQVBcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX1JFR0lTVEVSXCJdID0gOF0gPSBcIkNSRUFURV9SRUdJU1RFUlwiO1xuICByZXR1cm4gT3BDb2RlMjtcbn0pKE9wQ29kZSB8fCB7fSk7XG5mdW5jdGlvbiBhY2tPcChvcElkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICBpZDogXCJBQ0tcIixcbiAgICAvLyAoSClBQ0tcbiAgICBvcElkXG4gIH07XG59XG5mdW5jdGlvbiBpc0Fja09wKG9wKSB7XG4gIHJldHVybiBvcC50eXBlID09PSA1IC8qIERFTEVURV9DUkRUICovICYmIG9wLmlkID09PSBcIkFDS1wiO1xufVxuXG4vLyBzcmMvY3JkdHMvQWJzdHJhY3RDcmR0LnRzXG5mdW5jdGlvbiBjcmR0QXNMaXZlTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBIYXNQYXJlbnQobm9kZSwga2V5LCBwb3MgPSBhc1BvcyhrZXkpKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJIYXNQYXJlbnRcIiwgbm9kZSwga2V5LCBwb3MgfSk7XG59XG52YXIgTm9QYXJlbnQgPSBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJOb1BhcmVudFwiIH0pO1xuZnVuY3Rpb24gT3JwaGFuZWQob2xkS2V5LCBvbGRQb3MgPSBhc1BvcyhvbGRLZXkpKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJPcnBoYW5lZFwiLCBvbGRLZXksIG9sZFBvcyB9KTtcbn1cbnZhciBBYnN0cmFjdENyZHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wYXJlbnQgPSBOb1BhcmVudDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9nZXRQYXJlbnRLZXlPclRocm93KCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQua2V5O1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkS2V5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wYXJlbnRQb3MoKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wb3M7XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IGtleSBpcyBtaXNzaW5nXCIpO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRQb3M7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3Bvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wb29sO1xuICB9XG4gIGdldCByb29tSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wb29sID8gdGhpcy5fX3Bvb2wucm9vbUlkIDogbnVsbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pZDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfcGFyZW50S2V5KCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQua2V5O1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRLZXk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHkob3AsIF9pc0xvY2FsKSB7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlIDUgLyogREVMRVRFX0NSRFQgKi86IHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZS5fZGV0YWNoQ2hpbGQoY3JkdEFzTGl2ZU5vZGUodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zZXRQYXJlbnRMaW5rKG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQubm9kZSAhPT0gbmV3UGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcGFyZW50OiBub2RlIGFscmVhZHkgaGFzIGEgcGFyZW50XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3BhcmVudCA9IEhhc1BhcmVudChuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBIYXNQYXJlbnQobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9faWQgfHwgdGhpcy5fX3Bvb2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhdHRhY2ggbm9kZTogYWxyZWFkeSBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgcG9vbC5hZGROb2RlKGlkLCBjcmR0QXNMaXZlTm9kZSh0aGlzKSk7XG4gICAgdGhpcy5fX2lkID0gaWQ7XG4gICAgdGhpcy5fX3Bvb2wgPSBwb29sO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBpZiAodGhpcy5fX3Bvb2wgJiYgdGhpcy5fX2lkKSB7XG4gICAgICB0aGlzLl9fcG9vbC5kZWxldGVOb2RlKHRoaXMuX19pZCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOiB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IE9ycGhhbmVkKHRoaXMucGFyZW50LmtleSwgdGhpcy5wYXJlbnQucG9zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjoge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBOb1BhcmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjoge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICAgIHRoaXMuX19wb29sID0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQ2xlYXIgdGhlIEltbXV0YWJsZSBjYWNoZSwgc28gdGhhdCB0aGUgbmV4dCBjYWxsIHRvIGAudG9JbW11dGFibGUoKWAgd2lsbFxuICAgKiByZWNvbXB1dGUgdGhlIGVxdWl2YWxlbnQgSW1tdXRhYmxlIHZhbHVlIGFnYWluLiAgQ2FsbCB0aGlzIGFmdGVyIGV2ZXJ5XG4gICAqIG11dGF0aW9uIHRvIHRoZSBMaXZlIG5vZGUuXG4gICAqL1xuICBpbnZhbGlkYXRlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRJbW11dGFibGUgIT09IHZvaWQgMCB8fCB0aGlzLl9jYWNoZWRUcmVlTm9kZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9jYWNoZWRJbW11dGFibGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZSA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIFJldHVybiBhbiBzbmFwc2hvdCBvZiB0aGlzIExpdmUgdHJlZSBmb3IgdXNlIGluIERldlRvb2xzLlxuICAgKi9cbiAgdG9UcmVlTm9kZShrZXkpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkVHJlZU5vZGUgPT09IHZvaWQgMCB8fCB0aGlzLl9jYWNoZWRUcmVlTm9kZUtleSAhPT0ga2V5KSB7XG4gICAgICB0aGlzLl9jYWNoZWRUcmVlTm9kZUtleSA9IGtleTtcbiAgICAgIHRoaXMuX2NhY2hlZFRyZWVOb2RlID0gdGhpcy5fdG9UcmVlTm9kZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkVHJlZU5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpbW11dGFibGUgc25hcHNob3Qgb2YgdGhpcyBMaXZlIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICovXG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRJbW11dGFibGUgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY2FjaGVkSW1tdXRhYmxlID0gdGhpcy5fdG9JbW11dGFibGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZEltbXV0YWJsZTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3RvY29sL1NlcmlhbGl6ZWRDcmR0LnRzXG52YXIgQ3JkdFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChDcmR0VHlwZTIpID0+IHtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIk9CSkVDVFwiXSA9IDBdID0gXCJPQkpFQ1RcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIkxJU1RcIl0gPSAxXSA9IFwiTElTVFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiTUFQXCJdID0gMl0gPSBcIk1BUFwiO1xuICBDcmR0VHlwZTJbQ3JkdFR5cGUyW1wiUkVHSVNURVJcIl0gPSAzXSA9IFwiUkVHSVNURVJcIjtcbiAgcmV0dXJuIENyZHRUeXBlMjtcbn0pKENyZHRUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGlzUm9vdENyZHQoY3JkdCkge1xuICByZXR1cm4gY3JkdC50eXBlID09PSAwIC8qIE9CSkVDVCAqLyAmJiAhaXNDaGlsZENyZHQoY3JkdCk7XG59XG5mdW5jdGlvbiBpc0NoaWxkQ3JkdChjcmR0KSB7XG4gIHJldHVybiBjcmR0LnBhcmVudElkICE9PSB2b2lkIDAgJiYgY3JkdC5wYXJlbnRLZXkgIT09IHZvaWQgMDtcbn1cblxuLy8gc3JjL2xpYi9uYW5vaWQudHNcbmZ1bmN0aW9uIG5hbm9pZChsZW5ndGggPSA3KSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSwuLztbXX4hQCMkJSYqKClfKz0tXCI7XG4gIGNvbnN0IGxlbiA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgcmV0dXJuIEFycmF5LmZyb20oXG4gICAgeyBsZW5ndGggfSxcbiAgICAoKSA9PiBhbHBoYWJldC5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuKSlcbiAgKS5qb2luKFwiXCIpO1xufVxuXG4vLyBzcmMvY3JkdHMvTGl2ZVJlZ2lzdGVyLnRzXG52YXIgTGl2ZVJlZ2lzdGVyID0gY2xhc3MgX0xpdmVSZWdpc3RlciBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWQsIGl0ZW1dLCBfcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IHJlZ2lzdGVyID0gbmV3IF9MaXZlUmVnaXN0ZXIoaXRlbS5kYXRhKTtcbiAgICByZWdpc3Rlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICByZXR1cm4gcmVnaXN0ZXI7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IHNlcmlhbGl6ZSByZWdpc3RlciBpZiBwYXJlbnRJZCBvciBwYXJlbnRLZXkgaXMgdW5kZWZpbmVkXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IDggLyogQ1JFQVRFX1JFR0lTVEVSICovLFxuICAgICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgICBwYXJlbnRJZCxcbiAgICAgICAgcGFyZW50S2V5LFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlUmVnaXN0ZXIgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAzIC8qIFJFR0lTVEVSICovLFxuICAgICAgcGFyZW50SWQ6IG5uKHRoaXMucGFyZW50Lm5vZGUuX2lkLCBcIlBhcmVudCBub2RlIGV4cGVjdGVkIHRvIGhhdmUgSURcIiksXG4gICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleSxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoQ2hpbGQoX29wKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoX2NyZHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSnNvblwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogdGhpcy5fZGF0YVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIGRlZXBDbG9uZSh0aGlzLmRhdGEpO1xuICB9XG59O1xuXG4vLyBzcmMvY3JkdHMvTGl2ZUxpc3QudHNcbmZ1bmN0aW9uIGNvbXBhcmVOb2RlUG9zaXRpb24oaXRlbUEsIGl0ZW1CKSB7XG4gIGNvbnN0IHBvc0EgPSBpdGVtQS5fcGFyZW50UG9zO1xuICBjb25zdCBwb3NCID0gaXRlbUIuX3BhcmVudFBvcztcbiAgcmV0dXJuIHBvc0EgPT09IHBvc0IgPyAwIDogcG9zQSA8IHBvc0IgPyAtMSA6IDE7XG59XG52YXIgTGl2ZUxpc3QgPSBjbGFzcyBfTGl2ZUxpc3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICBjb25zdHJ1Y3RvcihpdGVtcyA9IFtdKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICB0aGlzLl91bmFja25vd2xlZGdlZFNldHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBwb3NpdGlvbiA9IHZvaWQgMDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gbWFrZVBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IG5vZGUgPSBsc29uVG9MaXZlTm9kZShpdGVtKTtcbiAgICAgIG5vZGUuX3NldFBhcmVudExpbmsodGhpcywgbmV3UG9zaXRpb24pO1xuICAgICAgdGhpcy5faXRlbXMucHVzaChub2RlKTtcbiAgICAgIHBvc2l0aW9uID0gbmV3UG9zaXRpb247XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbGlzdCA9IG5ldyBfTGl2ZUxpc3QoKTtcbiAgICBsaXN0Ll9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWQyLCBjcmR0XSBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGQgPSBkZXNlcmlhbGl6ZShbaWQyLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXN0LCBjcmR0LnBhcmVudEtleSk7XG4gICAgICBsaXN0Ll9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGUgcmVzdWx0aW5nIG9wcyB3aWxsIGJlIHNlbnQgdG8gdGhlIHNlcnZlciBpZiB0aGV5IGhhdmUgYW4gJ29wSWQnXG4gICAqIHNvIHdlIG11dGF0ZSBfdW5hY2tub3dsZWRnZWRTZXRzIHRvIGF2b2lkIHBvdGVudGlhbCBmbGlja2VyaW5nXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZlYmxvY2tzL2xpdmVibG9ja3MvcHVsbC8xMTc3XG4gICAqXG4gICAqIFRoaXMgaXMgcXVpdGUgdW5pbnR1aXRpdmUgYW5kIHNob3VsZCBkaXNhcHBlYXIgYXMgc29vbiBhc1xuICAgKiB3ZSBpbnRyb2R1Y2UgYW4gZXhwbGljaXQgTGl2ZUxpc3QuU2V0IG9wZXJhdGlvblxuICAgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBpdGVtIGlzIG5vdCBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgY29uc3QgcGFyZW50S2V5MiA9IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICAgIGNvbnN0IGNoaWxkT3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgaXRlbS5fdG9PcHModGhpcy5faWQsIHBhcmVudEtleTIsIHBvb2wpLFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgICBjb25zdCBjaGlsZE9wSWQgPSBjaGlsZE9wc1swXS5vcElkO1xuICAgICAgaWYgKGNoaWxkT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQocGFyZW50S2V5MiwgY2hpbGRPcElkKTtcbiAgICAgIH1cbiAgICAgIG9wcy5wdXNoKC4uLmNoaWxkT3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEFkZHMgYSBuZXcgaXRlbSBpbnRvIHRoZSBzb3J0ZWQgbGlzdCwgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24uXG4gICAqL1xuICBfaW5zZXJ0QW5kU29ydChpdGVtKSB7XG4gICAgdGhpcy5faXRlbXMucHVzaChpdGVtKTtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zb3J0SXRlbXMoKSB7XG4gICAgdGhpcy5faXRlbXMuc29ydChjb21wYXJlTm9kZVBvc2l0aW9uKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9pbmRleE9mUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMuZmluZEluZGV4KFxuICAgICAgKGl0ZW0pID0+IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSA9PT0gcG9zaXRpb25cbiAgICApO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIHN1cGVyLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgaXRlbS5fYXR0YWNoKHBvb2wuZ2VuZXJhdGVJZCgpLCBwb29sKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoKCkge1xuICAgIHN1cGVyLl9kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVNldFJlbW90ZShvcCkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleToga2V5IH0gPSBvcDtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNvbnN0IGRlbGV0ZWRJZCA9IG9wLmRlbGV0ZWRJZDtcbiAgICBjb25zdCBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgY29uc3QgaXRlbVdpdGhTYW1lUG9zaXRpb24gPSB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dO1xuICAgICAgaWYgKGl0ZW1XaXRoU2FtZVBvc2l0aW9uLl9pZCA9PT0gZGVsZXRlZElkKSB7XG4gICAgICAgIGl0ZW1XaXRoU2FtZVBvc2l0aW9uLl9kZXRhY2goKTtcbiAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXSA9IGNoaWxkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIHNldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgY2hpbGQpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuYWRkKGl0ZW1XaXRoU2FtZVBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXSA9IGNoaWxkO1xuICAgICAgICBjb25zdCBkZWx0YSA9IFtcbiAgICAgICAgICBzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIGNoaWxkKVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBkZWxldGVEZWx0YTIgPSB0aGlzLl9kZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICAgIG9wLmRlbGV0ZWRJZFxuICAgICAgICApO1xuICAgICAgICBpZiAoZGVsZXRlRGVsdGEyKSB7XG4gICAgICAgICAgZGVsdGEucHVzaChkZWxldGVEZWx0YTIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSBbXTtcbiAgICAgIGNvbnN0IGRlbGV0ZURlbHRhMiA9IHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oXG4gICAgICAgIG9wLmRlbGV0ZWRJZFxuICAgICAgKTtcbiAgICAgIGlmIChkZWxldGVEZWx0YTIpIHtcbiAgICAgICAgdXBkYXRlcy5wdXNoKGRlbGV0ZURlbHRhMik7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIHVwZGF0ZXMucHVzaChpbnNlcnREZWx0YSh0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KSwgY2hpbGQpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJldmVyc2U6IFtdLFxuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCB1cGRhdGVzKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRBY2sob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YSA9IFtdO1xuICAgIGNvbnN0IGRlbGV0ZWREZWx0YSA9IHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24ob3AuZGVsZXRlZElkKTtcbiAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICBkZWx0YS5wdXNoKGRlbGV0ZWREZWx0YSk7XG4gICAgfVxuICAgIGNvbnN0IHVuYWNrbm93bGVkZ2VkT3BJZCA9IHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5nZXQob3AucGFyZW50S2V5KTtcbiAgICBpZiAodW5hY2tub3dsZWRnZWRPcElkICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh1bmFja25vd2xlZGdlZE9wSWQgIT09IG9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIGRlbHRhLmxlbmd0aCA9PT0gMCA/IHsgbW9kaWZpZWQ6IGZhbHNlIH0gOiB7IG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSwgcmV2ZXJzZTogW10gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5kZWxldGUob3AucGFyZW50S2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy5faXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5faWQgPT09IG9wLmlkKTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW0uX3BhcmVudEtleSA9PT0gb3AucGFyZW50S2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChcbiAgICAgICAgICB0aGlzLl9pdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb25dXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIDEpO1xuICAgICAgICBkZWx0YS5wdXNoKGRlbGV0ZURlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbikpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoZXhpc3RpbmdJdGVtKTtcbiAgICAgIGV4aXN0aW5nSXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBvcC5wYXJlbnRLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoZXhpc3RpbmdJdGVtKTtcbiAgICAgIGlmIChuZXdJbmRleCAhPT0gcHJldmlvdXNJbmRleCkge1xuICAgICAgICBkZWx0YS5wdXNoKG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgZXhpc3RpbmdJdGVtKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZGVsdGEubGVuZ3RoID4gMCA/IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpIDogZmFsc2UsXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcnBoYW4gPSB0aGlzLl9wb29sLmdldE5vZGUob3AuaWQpO1xuICAgICAgaWYgKG9ycGhhbiAmJiB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhvcnBoYW4pKSB7XG4gICAgICAgIG9ycGhhbi5fc2V0UGFyZW50TGluayh0aGlzLCBvcC5wYXJlbnRLZXkpO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShvcnBoYW4pO1xuICAgICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG9ycGhhbik7XG4gICAgICAgIGNvbnN0IHJlY3JlYXRlZEl0ZW1JbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2Yob3JwaGFuKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpdGVtIGF0IHRoaXMgcG9zaXRpb24sIHVwZGF0ZSBpcyBhIHNldCwgZWxzZSBpdCdzIGFuIGluc2VydFxuICAgICAgICAgICAgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID09PSAtMSA/IGluc2VydERlbHRhKHJlY3JlYXRlZEl0ZW1JbmRleCwgb3JwaGFuKSA6IHNldERlbHRhKHJlY3JlYXRlZEl0ZW1JbmRleCwgb3JwaGFuKSxcbiAgICAgICAgICAgIC4uLmRlbHRhXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXdJdGVtLCBuZXdJbmRleCB9ID0gdGhpcy5fY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQoXG4gICAgICAgICAgb3AsXG4gICAgICAgICAgb3AucGFyZW50S2V5XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGlzIHBvc2l0aW9uLCB1cGRhdGUgaXMgYSBzZXQsIGVsc2UgaXQncyBhbiBpbnNlcnRcbiAgICAgICAgICAgIGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9PT0gLTEgPyBpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSkgOiBzZXREZWx0YShuZXdJbmRleCwgbmV3SXRlbSksXG4gICAgICAgICAgICAuLi5kZWx0YVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1cGRhdGUgZGVsdGEgb2YgdGhlIGRlbGV0aW9uIG9yIG51bGxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihkZWxldGVkSWQpIHtcbiAgICBpZiAoZGVsZXRlZElkID09PSB2b2lkIDAgfHwgdGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGVsZXRlZEl0ZW0gPSB0aGlzLl9wb29sLmdldE5vZGUoZGVsZXRlZElkKTtcbiAgICBpZiAoZGVsZXRlZEl0ZW0gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RldGFjaENoaWxkKGRlbGV0ZWRJdGVtKTtcbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubW9kaWZpZWQudXBkYXRlc1swXTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseVJlbW90ZUluc2VydChvcCkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGFzUG9zKG9wLnBhcmVudEtleSk7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9zaGlmdEl0ZW1Qb3NpdGlvbihleGlzdGluZ0l0ZW1JbmRleCwga2V5KTtcbiAgICB9XG4gICAgY29uc3QgeyBuZXdJdGVtLCBuZXdJbmRleCB9ID0gdGhpcy5fY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQob3AsIGtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgbmV3SXRlbSldKSxcbiAgICAgIHJldmVyc2U6IFtdXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseUluc2VydEFjayhvcCkge1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uX2lkID09PSBvcC5pZCk7XG4gICAgY29uc3Qga2V5ID0gYXNQb3Mob3AucGFyZW50S2V5KTtcbiAgICBjb25zdCBpdGVtSW5kZXhBdFBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbSkge1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbS5fcGFyZW50S2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG9sZFBvc2l0aW9uSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGV4aXN0aW5nSXRlbSk7XG4gICAgICAgIGlmIChpdGVtSW5kZXhBdFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX3NoaWZ0SXRlbVBvc2l0aW9uKGl0ZW1JbmRleEF0UG9zaXRpb24sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhpc3RpbmdJdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgICAgICBpZiAobmV3SW5kZXggPT09IG9sZFBvc2l0aW9uSW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIG1vdmVEZWx0YShvbGRQb3NpdGlvbkluZGV4LCBuZXdJbmRleCwgZXhpc3RpbmdJdGVtKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9ycGhhbiA9IG5uKHRoaXMuX3Bvb2wpLmdldE5vZGUob3AuaWQpO1xuICAgICAgaWYgKG9ycGhhbiAmJiB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhvcnBoYW4pKSB7XG4gICAgICAgIG9ycGhhbi5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShvcnBoYW4pO1xuICAgICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG9ycGhhbik7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBvcnBoYW4pXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpdGVtSW5kZXhBdFBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX3NoaWZ0SXRlbVBvc2l0aW9uKGl0ZW1JbmRleEF0UG9zaXRpb24sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXdJdGVtLCBuZXdJbmRleCB9ID0gdGhpcy5fY3JlYXRlQXR0YWNoSXRlbUFuZFNvcnQob3AsIGtleSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBuZXdJdGVtKV0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5SW5zZXJ0VW5kb1JlZG8ob3ApIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2w/LmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBjaGlsZC5fYXR0YWNoKGlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGxldCBuZXdLZXkgPSBrZXk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgYmVmb3JlMiA9IHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XT8uX3BhcmVudFBvcztcbiAgICAgIGNvbnN0IGFmdGVyMiA9IHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3M7XG4gICAgICBuZXdLZXkgPSBtYWtlUG9zaXRpb24oYmVmb3JlMiwgYWZ0ZXIyKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgfVxuICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICByZXZlcnNlOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRVbmRvUmVkbyhvcCkge1xuICAgIGNvbnN0IHsgaWQsIHBhcmVudEtleToga2V5IH0gPSBvcDtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbD8uZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIHRoaXMuX3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQoa2V5LCBubihvcC5vcElkKSk7XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZUtleSA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGNoaWxkLl9hdHRhY2goaWQsIG5uKHRoaXMuX3Bvb2wpKTtcbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNvbnN0IG5ld0tleSA9IGtleTtcbiAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZUtleSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVLZXldO1xuICAgICAgZXhpc3RpbmdJdGVtLl9kZXRhY2goKTtcbiAgICAgIHRoaXMuX2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVLZXldID0gY2hpbGQ7XG4gICAgICBjb25zdCByZXZlcnNlID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgZXhpc3RpbmdJdGVtLl90b09wcyhubih0aGlzLl9pZCksIGtleSwgdGhpcy5fcG9vbCksXG4gICAgICAgIG9wLmlkXG4gICAgICApO1xuICAgICAgY29uc3QgZGVsdGEgPSBbc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZUtleSwgY2hpbGQpXTtcbiAgICAgIGNvbnN0IGRlbGV0ZWREZWx0YSA9IHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24oXG4gICAgICAgIG9wLmRlbGV0ZWRJZFxuICAgICAgKTtcbiAgICAgIGlmIChkZWxldGVkRGVsdGEpIHtcbiAgICAgICAgZGVsdGEucHVzaChkZWxldGVkRGVsdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpLFxuICAgICAgICByZXZlcnNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIHRoaXMuX2RldGFjaEl0ZW1Bc3NvY2lhdGVkVG9TZXRPcGVyYXRpb24ob3AuZGVsZXRlZElkKTtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXZlcnNlOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKG5ld0luZGV4LCBjaGlsZCldKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoQ2hpbGQob3AsIHNvdXJjZSkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKG9wLmludGVudCA9PT0gXCJzZXRcIikge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlTZXRSZW1vdGUob3ApO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5U2V0QWNrKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2FwcGx5U2V0VW5kb1JlZG8ob3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9hcHBseVJlbW90ZUluc2VydChvcCk7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlJbnNlcnRBY2sob3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXBwbHlJbnNlcnRVbmRvUmVkbyhvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXN1bHQubW9kaWZpZWQgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKG5uKHRoaXMuX2lkKSwgcGFyZW50S2V5LCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IGluZGV4VG9EZWxldGUgPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChpbmRleFRvRGVsZXRlID09PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4VG9EZWxldGUsIDEpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbZGVsZXRlRGVsdGEoaW5kZXhUb0RlbGV0ZSldKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRDaGlsZEtleVJlbW90ZShuZXdLZXksIGNoaWxkKSB7XG4gICAgaWYgKHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKGNoaWxkKSkge1xuICAgICAgdGhpcy5faW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0tleSA9IGNoaWxkLl9wYXJlbnRLZXk7XG4gICAgaWYgKG5ld0tleSA9PT0gcHJldmlvdXNLZXkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKG5ld0luZGV4ID09PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICk7XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKG5ld0luZGV4ID09PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5U2V0Q2hpbGRLZXlBY2sobmV3S2V5LCBjaGlsZCkge1xuICAgIGNvbnN0IHByZXZpb3VzS2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgaWYgKHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKGNoaWxkKSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICAgIHRoaXMuX2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKGNoaWxkKTtcbiAgICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdLl9zZXRQYXJlbnRMaW5rKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5ld0tleSA9PT0gcHJldmlvdXNLZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlTZXRDaGlsZEtleVVuZG9SZWRvKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGNvbnN0IHByZXZpb3VzSW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgIGlmIChleGlzdGluZ0l0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy5faXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICk7XG4gICAgfVxuICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAocHJldmlvdXNJbmRleCA9PT0gbmV3SW5kZXgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFttb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKV0pLFxuICAgICAgcmV2ZXJzZTogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICBpZDogbm4oY2hpbGQuX2lkKSxcbiAgICAgICAgICBwYXJlbnRLZXk6IHByZXZpb3VzS2V5XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NldENoaWxkS2V5KG5ld0tleSwgY2hpbGQsIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleVJlbW90ZShuZXdLZXksIGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTZXRDaGlsZEtleVVuZG9SZWRvKG5ld0tleSwgY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlTGlzdCBpZiBwYXJlbnQgaXMgbWlzc2luZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IDEgLyogTElTVCAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMuXG4gICAqL1xuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb25lIGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgTGl2ZUxpc3QuXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGUgZW5kIG9mIHRoZSBMaXZlTGlzdC5cbiAgICovXG4gIHB1c2goZWxlbWVudCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KGVsZW1lbnQsIHRoaXMubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBvbmUgZWxlbWVudCBhdCBhIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0LlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHlvdSB3YW50IHRvIGluc2VydCB0aGUgZWxlbWVudC5cbiAgICovXG4gIGluc2VydChlbGVtZW50LCBpbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGluc2VydCBsaXN0IGl0ZW0gYXQgaW5kZXggXCJcdTAwMWQke2luZGV4fVwiLiBpbmRleCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAke3RoaXMuX2l0ZW1zLmxlbmd0aH1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBiZWZvcmUyID0gdGhpcy5faXRlbXNbaW5kZXggLSAxXSA/IHRoaXMuX2l0ZW1zW2luZGV4IC0gMV0uX3BhcmVudFBvcyA6IHZvaWQgMDtcbiAgICBjb25zdCBhZnRlcjIgPSB0aGlzLl9pdGVtc1tpbmRleF0gPyB0aGlzLl9pdGVtc1tpbmRleF0uX3BhcmVudFBvcyA6IHZvaWQgMDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihiZWZvcmUyLCBhZnRlcjIpO1xuICAgIGNvbnN0IHZhbHVlID0gbHNvblRvTGl2ZU5vZGUoZWxlbWVudCk7XG4gICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywgcG9zaXRpb24pO1xuICAgIHRoaXMuX2luc2VydEFuZFNvcnQodmFsdWUpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgdmFsdWUuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICB2YWx1ZS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB0aGlzLl9wb29sKSxcbiAgICAgICAgW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgICBbdGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW2luc2VydERlbHRhKGluZGV4LCB2YWx1ZSldKV1cbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBNb3ZlIG9uZSBlbGVtZW50IGZyb20gb25lIGluZGV4IHRvIGFub3RoZXIuXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gbW92ZVxuICAgKiBAcGFyYW0gdGFyZ2V0SW5kZXggVGhlIGluZGV4IHdoZXJlIHRoZSBlbGVtZW50IHNob3VsZCBiZSBhZnRlciBtb3ZpbmcuXG4gICAqL1xuICBtb3ZlKGluZGV4LCB0YXJnZXRJbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggY2Fubm90IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwidGFyZ2V0SW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBjYW5ub3QgYmUgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBsaXN0IGxlbmd0aFwiKTtcbiAgICB9XG4gICAgbGV0IGJlZm9yZVBvc2l0aW9uID0gbnVsbDtcbiAgICBsZXQgYWZ0ZXJQb3NpdGlvbiA9IG51bGw7XG4gICAgaWYgKGluZGV4IDwgdGFyZ2V0SW5kZXgpIHtcbiAgICAgIGFmdGVyUG9zaXRpb24gPSB0YXJnZXRJbmRleCA9PT0gdGhpcy5faXRlbXMubGVuZ3RoIC0gMSA/IHZvaWQgMCA6IHRoaXMuX2l0ZW1zW3RhcmdldEluZGV4ICsgMV0uX3BhcmVudFBvcztcbiAgICAgIGJlZm9yZVBvc2l0aW9uID0gdGhpcy5faXRlbXNbdGFyZ2V0SW5kZXhdLl9wYXJlbnRQb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyUG9zaXRpb24gPSB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleF0uX3BhcmVudFBvcztcbiAgICAgIGJlZm9yZVBvc2l0aW9uID0gdGFyZ2V0SW5kZXggPT09IDAgPyB2b2lkIDAgOiB0aGlzLl9pdGVtc1t0YXJnZXRJbmRleCAtIDFdLl9wYXJlbnRQb3M7XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKGJlZm9yZVBvc2l0aW9uLCBhZnRlclBvc2l0aW9uKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuICAgIGNvbnN0IHByZXZpb3VzUG9zaXRpb24gPSBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgaXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbdGhpcy5faWQsIG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShpbmRleCwgdGFyZ2V0SW5kZXgsIGl0ZW0pXSldXG4gICAgICBdKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgICAgaWQ6IG5uKGl0ZW0uX2lkKSxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKCksXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHBvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBTRVRfUEFSRU5UX0tFWSAqLyxcbiAgICAgICAgICAgIGlkOiBubihpdGVtLl9pZCksXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHByZXZpb3VzUG9zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbiBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShpbmRleCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBkZWxldGUgbGlzdCBpdGVtIGF0IGluZGV4IFwiJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGggLSAxfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG4gICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCkge1xuICAgICAgY29uc3QgY2hpbGRSZWNvcmRJZCA9IGl0ZW0uX2lkO1xuICAgICAgaWYgKGNoaWxkUmVjb3JkSWQpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBzdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgbm4odGhpcy5faWQpLFxuICAgICAgICAgIG1ha2VVcGRhdGUodGhpcywgW2RlbGV0ZURlbHRhKGluZGV4KV0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgICAgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZDogY2hpbGRSZWNvcmRJZCxcbiAgICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgaXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBpdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCkpLFxuICAgICAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wpIHtcbiAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgY29uc3QgcmV2ZXJzZU9wcyA9IFtdO1xuICAgICAgY29uc3QgdXBkYXRlRGVsdGEgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xuICAgICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICAgICAgY29uc3QgY2hpbGRJZCA9IGl0ZW0uX2lkO1xuICAgICAgICBpZiAoY2hpbGRJZCkge1xuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgICAgICAgICBpZDogY2hpbGRJZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXZlcnNlT3BzLnB1c2goXG4gICAgICAgICAgICAuLi5pdGVtLl90b09wcyhubih0aGlzLl9pZCksIGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHVwZGF0ZURlbHRhLnB1c2goZGVsZXRlRGVsdGEoMCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQobm4odGhpcy5faWQpLCBtYWtlVXBkYXRlKHRoaXMsIHVwZGF0ZURlbHRhKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcbiAgICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICB9XG4gIHNldChpbmRleCwgaXRlbSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzZXQgbGlzdCBpdGVtIGF0IGluZGV4IFwiXHUwMDFkJHtpbmRleH1cIi4gaW5kZXggc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLl9pdGVtcy5sZW5ndGggLSAxfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGV4aXN0aW5nSXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpO1xuICAgIGNvbnN0IGV4aXN0aW5nSWQgPSBleGlzdGluZ0l0ZW0uX2lkO1xuICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgY29uc3QgdmFsdWUgPSBsc29uVG9MaXZlTm9kZShpdGVtKTtcbiAgICB2YWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy5faXRlbXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCk7XG4gICAgICB2YWx1ZS5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwgbWFrZVVwZGF0ZSh0aGlzLCBbc2V0RGVsdGEoaW5kZXgsIHZhbHVlKV0pKTtcbiAgICAgIGNvbnN0IG9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIHZhbHVlLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHRoaXMuX3Bvb2wpLFxuICAgICAgICBleGlzdGluZ0lkXG4gICAgICApO1xuICAgICAgdGhpcy5fdW5hY2tub3dsZWRnZWRTZXRzLnNldChwb3NpdGlvbiwgbm4ob3BzWzBdLm9wSWQpKTtcbiAgICAgIGNvbnN0IHJldmVyc2VPcHMgPSBIQUNLX2FkZEludGVudEFuZERlbGV0ZWRJZFRvT3BlcmF0aW9uKFxuICAgICAgICBleGlzdGluZ0l0ZW0uX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdm9pZCAwKSxcbiAgICAgICAgaWRcbiAgICAgICk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKG9wcywgcmV2ZXJzZU9wcywgc3RvcmFnZVVwZGF0ZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBBcnJheSBvZiBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBMaXZlTGlzdC5cbiAgICovXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLm1hcChcbiAgICAgIChlbnRyeSkgPT4gbGl2ZU5vZGVUb0xzb24oZW50cnkpXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXlxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRklYTUUhIFRoaXMgaXNuJ3Qgc2FmZS5cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIGFsbCBlbGVtZW50cyBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGZvciBlYWNoIGVsZW1lbnQsIHRha2luZyB0d28gYXJndW1lbnRzICh0aGUgZWxlbWVudCBhbmQgaXRzIGluZGV4KS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgZm9yIGV2ZXJ5IGVsZW1lbnQuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBldmVyeShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZXZlcnkocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBlbGVtZW50IG9mIHRoZSBMaXZlTGlzdC4gUmV0dXJuIGEgdmFsdWUgdGhhdCBjb2VyY2VzIHRvIHRydWUgdG8ga2VlcCB0aGUgZWxlbWVudCwgb3IgdG8gZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QuXG4gICAqL1xuICBmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZpbHRlcihwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZS5cbiAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi4gT3RoZXJ3aXNlLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBmaW5kKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maW5kKHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBMaXZlTGlzdCB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgdW50aWwgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgaW5kaWNhdGluZyB0aGF0IHRoZSBzYXRpc2Z5aW5nIGVsZW1lbnQgd2FzIGZvdW5kLlxuICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHRoYXQgcGFzc2VzIHRoZSB0ZXN0LiBPdGhlcndpc2UsIC0xLlxuICAgKi9cbiAgZmluZEluZGV4KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maW5kSW5kZXgocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqIEBwYXJhbSBjYWxsYmFja2ZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCBlbGVtZW50LlxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFja2ZuKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZvckVhY2goY2FsbGJhY2tmbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9uIHRoZSBlbGVtZW50IHRvIGdldC5cbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVOb2RlVG9Mc29uKHRoaXMuX2l0ZW1zW2luZGV4XSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIExpdmVMaXN0LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBsb2NhdGUuXG4gICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2ggYXQuXG4gICAqIEByZXR1cm5zIFRoZSBmaXJzdCBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3Q7IC0xIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIGluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGFzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBMaXZlTGlzdCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuIFRoZSBMaXZlTHNpdCBpcyBzZWFyY2hlZCBiYWNrd2FyZHMsIHN0YXJ0aW5nIGF0IGZyb21JbmRleC5cbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgRWxlbWVudCB0byBsb2NhdGUuXG4gICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZyBiYWNrd2FyZHMuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBwb3B1bGF0ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gZXZlcnkgZWxlbWVudC5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGZvciBldmVyeSBlbGVtZW50LlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIGVhY2ggZWxlbWVudCBiZWluZyB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICovXG4gIG1hcChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcy5tYXAoXG4gICAgICAoZW50cnksIGkpID0+IGNhbGxiYWNrKFxuICAgICAgICBsaXZlTm9kZVRvTHNvbihlbnRyeSksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXlxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgRklYTUUhIFRoaXMgaXNuJ3Qgc2FmZS5cbiAgICAgICAgaVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRlc3RzIHdoZXRoZXIgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHBhc3NlcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBhdCBsZWFzdCBvbmUgZWxlbWVudC4gT3RoZXJ3aXNlLCBmYWxzZS5cbiAgICovXG4gIHNvbWUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLnNvbWUocHJlZGljYXRlKTtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gbmV3IExpdmVMaXN0SXRlcmF0b3IodGhpcy5faXRlbXMpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpIHtcbiAgICBjb25zdCBuZXdJdGVtID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIG5ld0l0ZW0uX2F0dGFjaChvcC5pZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIG5ld0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG5ld0l0ZW0pO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgcmV0dXJuIHsgbmV3SXRlbSwgbmV3SW5kZXggfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zaGlmdEl0ZW1Qb3NpdGlvbihpbmRleCwga2V5KSB7XG4gICAgY29uc3Qgc2hpZnRlZFBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKFxuICAgICAga2V5LFxuICAgICAgdGhpcy5faXRlbXMubGVuZ3RoID4gaW5kZXggKyAxID8gdGhpcy5faXRlbXNbaW5kZXggKyAxXT8uX3BhcmVudFBvcyA6IHZvaWQgMFxuICAgICk7XG4gICAgdGhpcy5faXRlbXNbaW5kZXhdLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHNoaWZ0ZWRQb3NpdGlvbik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlTGlzdFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogdGhpcy5faXRlbXMubWFwKFxuICAgICAgICAoaXRlbSwgaW5kZXgpID0+IGl0ZW0udG9UcmVlTm9kZShpbmRleC50b1N0cmluZygpKVxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5faXRlbXMubWFwKChub2RlKSA9PiBub2RlLnRvSW1tdXRhYmxlKCkpO1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZUxpc3QodGhpcy5faXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLmNsb25lKCkpKTtcbiAgfVxufTtcbnZhciBMaXZlTGlzdEl0ZXJhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihpdGVtcykge1xuICAgIHRoaXMuX2lubmVySXRlcmF0b3IgPSBpdGVtc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9pbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24ocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4geyB2YWx1ZSB9O1xuICB9XG59O1xuZnVuY3Rpb24gbWFrZVVwZGF0ZShsaXZlTGlzdCwgZGVsdGFVcGRhdGVzKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbGl2ZUxpc3QsXG4gICAgdHlwZTogXCJMaXZlTGlzdFwiLFxuICAgIHVwZGF0ZXM6IGRlbHRhVXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gc2V0RGVsdGEoaW5kZXgsIGl0ZW0pIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleCxcbiAgICB0eXBlOiBcInNldFwiLFxuICAgIGl0ZW06IGl0ZW0gaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIgPyBpdGVtLmRhdGEgOiBpdGVtXG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVEZWx0YShpbmRleCkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwiZGVsZXRlXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGluc2VydERlbHRhKGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJpbnNlcnRcIixcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIGluZGV4LCBpdGVtKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXgsXG4gICAgdHlwZTogXCJtb3ZlXCIsXG4gICAgcHJldmlvdXNJbmRleCxcbiAgICBpdGVtOiBpdGVtIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gaXRlbS5kYXRhIDogaXRlbVxuICB9O1xufVxuZnVuY3Rpb24gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihvcHMsIGRlbGV0ZWRJZCkge1xuICByZXR1cm4gb3BzLm1hcCgob3AsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBjb25zdCBmaXJzdE9wID0gb3A7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5maXJzdE9wLFxuICAgICAgICBpbnRlbnQ6IFwic2V0XCIsXG4gICAgICAgIGRlbGV0ZWRJZFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9saWIvZnJlZXplLnRzXG52YXIgZnJlZXplID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gKFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAoeCkgPT4geFxuKSA6IE9iamVjdC5mcmVlemU7XG5cbi8vIHNyYy9jcmR0cy9MaXZlTWFwLnRzXG52YXIgTGl2ZU1hcCA9IGNsYXNzIF9MaXZlTWFwIGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgY29uc3RydWN0b3IoZW50cmllczIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudW5hY2tub3dsZWRnZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGlmIChlbnRyaWVzMikge1xuICAgICAgY29uc3QgbWFwcGVkRW50cmllcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllczIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGxzb25Ub0xpdmVOb2RlKHZhbHVlKTtcbiAgICAgICAgbm9kZS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgICBtYXBwZWRFbnRyaWVzLnB1c2goW2tleSwgbm9kZV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcChtYXBwZWRFbnRyaWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBpdGVtIGlzIG5vdCBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgIHBhcmVudElkLFxuICAgICAgcGFyZW50S2V5XG4gICAgfTtcbiAgICBvcHMucHVzaChvcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBvcHMucHVzaCguLi52YWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSwgcG9vbCkpO1xuICAgIH1cbiAgICByZXR1cm4gb3BzO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBfaXRlbV0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgX0xpdmVNYXAoKTtcbiAgICBtYXAuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRUb0NoaWxkcmVuLmdldChpZCk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkMiwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemUoW2lkMiwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsobWFwLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICBtYXAuX21hcC5zZXQoY3JkdC5wYXJlbnRLZXksIGNoaWxkKTtcbiAgICAgIG1hcC5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIHN1cGVyLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGZvciAoY29uc3QgW19rZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fYXR0YWNoKHBvb2wuZ2VuZXJhdGVJZCgpLCBwb29sKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXksIG9wSWQgfSA9IG9wO1xuICAgIGNvbnN0IGtleSA9IHBhcmVudEtleTtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbC5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgIGNvbnN0IGxhc3RVcGRhdGVPcElkID0gdGhpcy51bmFja25vd2xlZGdlZFNldC5nZXQoa2V5KTtcbiAgICAgIGlmIChsYXN0VXBkYXRlT3BJZCA9PT0gb3BJZCkge1xuICAgICAgICB0aGlzLnVuYWNrbm93bGVkZ2VkU2V0LmRlbGV0ZShrZXkpO1xuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH0gZWxzZSBpZiAobGFzdFVwZGF0ZU9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgIHRoaXMudW5hY2tub3dsZWRnZWRTZXQuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKHByZXZpb3VzVmFsdWUpIHtcbiAgICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICAgIHJldmVyc2UgPSBwcmV2aW91c1ZhbHVlLl90b09wcyh0aGlzSWQsIGtleSk7XG4gICAgICBwcmV2aW91c1ZhbHVlLl9kZXRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ZXJzZSA9IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dO1xuICAgIH1cbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIHRoaXMuX21hcC5zZXQoa2V5LCBjaGlsZCk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9LFxuICAgICAgcmV2ZXJzZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX21hcC52YWx1ZXMoKSkge1xuICAgICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAodmFsdWUgPT09IGNoaWxkKSB7XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNoaWxkLl9kZXRhY2goKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlID0ge1xuICAgICAgbm9kZTogdGhpcyxcbiAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgdXBkYXRlczogeyBbcGFyZW50S2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgIH07XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IHN0b3JhZ2VVcGRhdGUsIHJldmVyc2UgfTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLnBhcmVudC50eXBlICE9PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIExpdmVNYXAgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAyIC8qIE1BUCAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGUgTGl2ZU1hcC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LCBvciB1bmRlZmluZWQgaWYgdGhlIGtleSBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgTGl2ZU1hcC5cbiAgICovXG4gIGdldChrZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVOb2RlVG9Mc29uKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIGFuIGVsZW1lbnQgd2l0aCBhIHNwZWNpZmllZCBrZXkgYW5kIGEgdmFsdWUuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBhZGQuIFNob3VsZCBiZSBhIHN0cmluZy5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB0byBhZGQuIFNob3VsZCBiZSBzZXJpYWxpemFibGUgdG8gSlNPTi5cbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IGxzb25Ub0xpdmVOb2RlKHZhbHVlKTtcbiAgICBpdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgdGhpcy5fbWFwLnNldChrZXksIGl0ZW0pO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgaXRlbS5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBvcHMgPSBpdGVtLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgIHRoaXMudW5hY2tub3dsZWRnZWRTZXQuc2V0KGtleSwgbm4ob3BzWzBdLm9wSWQpKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXMuX2lkLCBrZXksIHRoaXMuX3Bvb2wpLFxuICAgICAgICBvbGRWYWx1ZSA/IG9sZFZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5KSA6IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dLFxuICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgTGl2ZU1hcC5cbiAgICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuc2l6ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBleGlzdHMgb3Igbm90LlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gdGVzdCBmb3IgcHJlc2VuY2UuXG4gICAqL1xuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgYnkga2V5LlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIGFuIGVsZW1lbnQgZXhpc3RlZCBhbmQgaGFzIGJlZW4gcmVtb3ZlZCwgb3IgZmFsc2UgaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgIGlmIChpdGVtID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXRlbS5fZGV0YWNoKCk7XG4gICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIGl0ZW0uX2lkKSB7XG4gICAgICBjb25zdCB0aGlzSWQgPSBubih0aGlzLl9pZCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpc0lkLCB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICAgICAgaWQ6IGl0ZW0uX2lkLFxuICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgaXRlbS5fdG9PcHModGhpc0lkLCBrZXkpLFxuICAgICAgICBzdG9yYWdlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIFtrZXksIHZhbHVlXSBwYWlycyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAgZW50cmllcygpIHtcbiAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGhpcy5fbWFwLmVudHJpZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yVmFsdWUgPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yVmFsdWUuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50cnkgPSBpdGVyYXRvclZhbHVlLnZhbHVlO1xuICAgICAgICBjb25zdCBrZXkgPSBlbnRyeVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihpdGVyYXRvclZhbHVlLnZhbHVlWzFdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogW2tleSwgdmFsdWVdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2FtZSBmdW5jdGlvbiBvYmplY3QgYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGVudHJpZXMgbWV0aG9kLlxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBrZXlzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAua2V5cygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSB2YWx1ZXMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIHZhbHVlcygpIHtcbiAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGhpcy5fbWFwLnZhbHVlcygpO1xuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3JWYWx1ZSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoaXRlcmF0b3JWYWx1ZS5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IGxpdmVOb2RlVG9Mc29uKGl0ZXJhdG9yVmFsdWUudmFsdWUpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBwZXIgZWFjaCBrZXkvdmFsdWUgcGFpciBpbiB0aGUgTWFwIG9iamVjdCwgaW4gaW5zZXJ0aW9uIG9yZGVyLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBlbnRyeSBpbiB0aGUgbWFwLlxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcykge1xuICAgICAgY2FsbGJhY2soZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlTWFwXCIsXG4gICAgICBpZDogdGhpcy5faWQgPz8gbmFub2lkKCksXG4gICAgICBrZXksXG4gICAgICBwYXlsb2FkOiBBcnJheS5mcm9tKHRoaXMuX21hcC5lbnRyaWVzKCkpLm1hcChcbiAgICAgICAgKFtrZXkyLCB2YWxdKSA9PiB2YWwudG9UcmVlTm9kZShrZXkyKVxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZS50b0ltbXV0YWJsZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVNYXAoXG4gICAgICBBcnJheS5mcm9tKHRoaXMuX21hcCkubWFwKChba2V5LCBub2RlXSkgPT4gW2tleSwgbm9kZS5jbG9uZSgpXSlcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvY3JkdHMvTGl2ZU9iamVjdC50c1xudmFyIExpdmVPYmplY3QgPSBjbGFzcyBfTGl2ZU9iamVjdCBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gIGNvbnN0cnVjdG9yKG9iaiA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBvID0gY29tcGFjdE9iamVjdChvYmopO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG8pKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ba2V5XTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKG8pKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfYnVpbGRSb290QW5kUGFyZW50VG9DaGlsZHJlbihpdGVtcykge1xuICAgIGNvbnN0IHBhcmVudFRvQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCByb290ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgaXRlbXMpIHtcbiAgICAgIGlmIChpc1Jvb3RDcmR0KGNyZHQpKSB7XG4gICAgICAgIHJvb3QgPSBbaWQsIGNyZHRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHVwbGUgPSBbaWQsIGNyZHRdO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGNyZHQucGFyZW50SWQpO1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2godHVwbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFRvQ2hpbGRyZW4uc2V0KGNyZHQucGFyZW50SWQsIFt0dXBsZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IGNhbid0IGJlIG51bGxcIik7XG4gICAgfVxuICAgIHJldHVybiBbcm9vdCwgcGFyZW50VG9DaGlsZHJlbl07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Zyb21JdGVtcyhpdGVtcywgcG9vbCkge1xuICAgIGNvbnN0IFtyb290LCBwYXJlbnRUb0NoaWxkcmVuXSA9IF9MaXZlT2JqZWN0Ll9idWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuKGl0ZW1zKTtcbiAgICByZXR1cm4gX0xpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFxuICAgICAgcm9vdCxcbiAgICAgIHBhcmVudFRvQ2hpbGRyZW4sXG4gICAgICBwb29sXG4gICAgKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b09wcyhwYXJlbnRJZCwgcGFyZW50S2V5LCBwb29sKSB7XG4gICAgaWYgKHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXJpYWxpemUgaXRlbSBpcyBub3QgYXR0YWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wSWQgPSBwb29sPy5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCBvcCA9IHtcbiAgICAgIHR5cGU6IDQgLyogQ1JFQVRFX09CSkVDVCAqLyxcbiAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgIG9wSWQsXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleSxcbiAgICAgIGRhdGE6IHt9XG4gICAgfTtcbiAgICBvcHMucHVzaChvcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgb3BzLnB1c2goLi4udmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHBvb2wpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wLmRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BzO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWQsIGl0ZW1dLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gICAgY29uc3QgbGl2ZU9iaiA9IG5ldyBfTGl2ZU9iamVjdChpdGVtLmRhdGEpO1xuICAgIGxpdmVPYmouX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgcmV0dXJuIHRoaXMuX2Rlc2VyaWFsaXplQ2hpbGRyZW4obGl2ZU9iaiwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgX2Rlc2VyaWFsaXplQ2hpbGRyZW4obGl2ZU9iaiwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQobm4obGl2ZU9iai5faWQpKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGxpdmVPYmo7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkLCBjcmR0XSBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGQgPSBkZXNlcmlhbGl6ZVRvTHNvbihbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICAgIGlmIChpc0xpdmVTdHJ1Y3R1cmUoY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKGxpdmVPYmosIGNyZHQucGFyZW50S2V5KTtcbiAgICAgIH1cbiAgICAgIGxpdmVPYmouX21hcC5zZXQoY3JkdC5wYXJlbnRLZXksIGNoaWxkKTtcbiAgICAgIGxpdmVPYmouaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbGl2ZU9iajtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCB2YWx1ZV0gb2YgdGhpcy5fbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBvcElkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9Mc29uKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbC5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gb3BJZCkge1xuICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmIChzb3VyY2UgPT09IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovKSB7XG4gICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG5uKG9wSWQpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IHZvaWQgMCkge1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSA9PT0gb3BJZCkge1xuICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUocHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgIHJldmVyc2UgPSBwcmV2aW91c1ZhbHVlLl90b09wcyh0aGlzSWQsIGtleSk7XG4gICAgICBwcmV2aW91c1ZhbHVlLl9kZXRhY2goKTtcbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFt7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzSWQsIGtleSB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZDogdGhpc0lkLFxuICAgICAgICAgIGRhdGE6IHsgW2tleV06IHByZXZpb3VzVmFsdWUgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLl9tYXAuc2V0KGtleSwgY2hpbGQpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmIChpc0xpdmVTdHJ1Y3R1cmUoY2hpbGQpKSB7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZXZlcnNlLFxuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJ1cGRhdGVcIiB9IH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaENoaWxkKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhpZCwgcGFyZW50S2V5LCB0aGlzLl9wb29sKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgICBpZiAodmFsdWUgPT09IGNoaWxkKSB7XG4gICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgICBjb25zdCBzdG9yYWdlVXBkYXRlID0ge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczoge1xuICAgICAgICAgIFtwYXJlbnRLZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IHN0b3JhZ2VVcGRhdGUsIHJldmVyc2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLl9tYXAudmFsdWVzKCkpIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBpc0xvY2FsKSB7XG4gICAgaWYgKG9wLnR5cGUgPT09IDMgLyogVVBEQVRFX09CSkVDVCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5VXBkYXRlKG9wLCBpc0xvY2FsKTtcbiAgICB9IGVsc2UgaWYgKG9wLnR5cGUgPT09IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseURlbGV0ZU9iamVjdEtleShvcCwgaXNMb2NhbCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXJpYWxpemUoKSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX21hcCkge1xuICAgICAgaWYgKCFpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIgJiYgdGhpcy5wYXJlbnQubm9kZS5faWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDAgLyogT0JKRUNUICovLFxuICAgICAgICBwYXJlbnRJZDogdGhpcy5wYXJlbnQubm9kZS5faWQsXG4gICAgICAgIHBhcmVudEtleTogdGhpcy5wYXJlbnQua2V5LFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwIC8qIE9CSkVDVCAqLyxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlVcGRhdGUob3AsIGlzTG9jYWwpIHtcbiAgICBsZXQgaXNNb2RpZmllZCA9IGZhbHNlO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHJldmVyc2UgPSBbXTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlID0ge1xuICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgaWQsXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgcmV2ZXJzZS5wdXNoKC4uLm9sZFZhbHVlLl90b09wcyhpZCwga2V5KSk7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlVXBkYXRlLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2UucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkLCBrZXkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZURlbHRhID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcC5kYXRhW2tleV07XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAgIHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wLm9wSWQpIHtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgdXBkYXRlRGVsdGFba2V5XSA9IHsgdHlwZTogXCJ1cGRhdGVcIiB9O1xuICAgICAgdGhpcy5fbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMocmV2ZXJzZVVwZGF0ZS5kYXRhKS5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldmVyc2UudW5zaGlmdChyZXZlcnNlVXBkYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTW9kaWZpZWQgPyB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczogdXBkYXRlRGVsdGFcbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfSA6IHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXBwbHlEZWxldGVPYmplY3RLZXkob3AsIGlzTG9jYWwpIHtcbiAgICBjb25zdCBrZXkgPSBvcC5rZXk7XG4gICAgaWYgKHRoaXMuX21hcC5oYXMoa2V5KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoIWlzTG9jYWwgJiYgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5nZXQoa2V5KSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgbGV0IHJldmVyc2UgPSBbXTtcbiAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgIHJldmVyc2UgPSBvbGRWYWx1ZS5fdG9PcHMoaWQsIG9wLmtleSk7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChvbGRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXZlcnNlID0gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGRhdGE6IHsgW2tleV06IG9sZFZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczogeyBbb3Aua2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIExpdmVPYmplY3QgaW50byBhIGphdmFzY3JpcHQgb2JqZWN0XG4gICAqL1xuICB0b09iamVjdCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuX21hcCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhIHByb3BlcnR5IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCBhIHZhbHVlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFkZFxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICB0aGlzLnVwZGF0ZSh7IFtrZXldOiB2YWx1ZSB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIHRoZSBMaXZlT2JqZWN0LlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldFxuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBrZXkgZnJvbSB0aGUgTGl2ZU9iamVjdFxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3Qga2V5QXNTdHJpbmcgPSBrZXk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9tYXAuZ2V0KGtleUFzU3RyaW5nKTtcbiAgICBpZiAob2xkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwIHx8IHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcmV2ZXJzZTtcbiAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIHJldmVyc2UgPSBvbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleUFzU3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBkYXRhOiB7IFtrZXlBc1N0cmluZ106IG9sZFZhbHVlIH0sXG4gICAgICAgICAgaWQ6IHRoaXMuX2lkXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuX21hcC5kZWxldGUoa2V5QXNTdHJpbmcpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIHVwZGF0ZXM6IHsgW2tleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICB9KTtcbiAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLyxcbiAgICAgICAgICBrZXk6IGtleUFzU3RyaW5nLFxuICAgICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICByZXZlcnNlLFxuICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlIHdpdGggYW4gb2JqZWN0LlxuICAgKiBAcGFyYW0gcGF0Y2ggVGhlIG9iamVjdCB1c2VkIHRvIG92ZXJyaWRlcyBwcm9wZXJ0aWVzXG4gICAqL1xuICB1cGRhdGUocGF0Y2gpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDAgfHwgdGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGl2ZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgICAgbmV3VmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3QgcmV2ZXJzZU9wcyA9IFtdO1xuICAgIGNvbnN0IG9wSWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpO1xuICAgIGNvbnN0IHVwZGF0ZWRQcm9wcyA9IHt9O1xuICAgIGNvbnN0IHJldmVyc2VVcGRhdGVPcCA9IHtcbiAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgIGRhdGE6IHt9XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVEZWx0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IHBhdGNoW2tleV07XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIHJldmVyc2VPcHMucHVzaCguLi5vbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSkpO1xuICAgICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV2ZXJzZU9wcy5wdXNoKHsgdHlwZTogNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLywgaWQ6IHRoaXMuX2lkLCBrZXkgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXZlcnNlVXBkYXRlT3AuZGF0YVtrZXldID0gb2xkVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMaXZlTm9kZShuZXdWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgbmV3VmFsdWUuX2F0dGFjaCh0aGlzLl9wb29sLmdlbmVyYXRlSWQoKSwgdGhpcy5fcG9vbCk7XG4gICAgICAgIGNvbnN0IG5ld0F0dGFjaENoaWxkT3BzID0gbmV3VmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXksIHRoaXMuX3Bvb2wpO1xuICAgICAgICBjb25zdCBjcmVhdGVDcmR0T3AgPSBuZXdBdHRhY2hDaGlsZE9wcy5maW5kKFxuICAgICAgICAgIChvcCkgPT4gb3AucGFyZW50SWQgPT09IHRoaXMuX2lkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChjcmVhdGVDcmR0T3ApIHtcbiAgICAgICAgICB0aGlzLl9wcm9wVG9MYXN0VXBkYXRlLnNldChrZXksIG5uKGNyZWF0ZUNyZHRPcC5vcElkKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3BzLnB1c2goLi4ubmV3QXR0YWNoQ2hpbGRPcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlZFByb3BzW2tleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5fcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBvcElkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCBuZXdWYWx1ZSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHVwZGF0ZURlbHRhW2tleV0gPSB7IHR5cGU6IFwidXBkYXRlXCIgfTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHJldmVyc2VVcGRhdGVPcC5kYXRhKS5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldmVyc2VPcHMudW5zaGlmdChyZXZlcnNlVXBkYXRlT3ApO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModXBkYXRlZFByb3BzKS5sZW5ndGggIT09IDApIHtcbiAgICAgIG9wcy51bnNoaWZ0KHtcbiAgICAgICAgb3BJZCxcbiAgICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgIGRhdGE6IHVwZGF0ZWRQcm9wc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBzdG9yYWdlVXBkYXRlcy5zZXQodGhpcy5faWQsIHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIHVwZGF0ZXM6IHVwZGF0ZURlbHRhXG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChvcHMsIHJldmVyc2VPcHMsIHN0b3JhZ2VVcGRhdGVzKTtcbiAgfVxuICB0b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIudG9JbW11dGFibGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHRvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvVHJlZU5vZGUoa2V5KTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b1RyZWVOb2RlKGtleSkge1xuICAgIGNvbnN0IG5vZGVJZCA9IHRoaXMuX2lkID8/IG5hbm9pZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgIGlkOiBub2RlSWQsXG4gICAgICBrZXksXG4gICAgICBwYXlsb2FkOiBBcnJheS5mcm9tKHRoaXMuX21hcC5lbnRyaWVzKCkpLm1hcChcbiAgICAgICAgKFtrZXkyLCB2YWx1ZV0pID0+IGlzTGl2ZU5vZGUodmFsdWUpID8gdmFsdWUudG9UcmVlTm9kZShrZXkyKSA6IHsgdHlwZTogXCJKc29uXCIsIGlkOiBgJHtub2RlSWR9OiR7a2V5Mn1gLCBrZXk6IGtleTIsIHBheWxvYWQ6IHZhbHVlIH1cbiAgICAgIClcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzLl9tYXApIHtcbiAgICAgIHJlc3VsdFtrZXldID0gaXNMaXZlU3RydWN0dXJlKHZhbCkgPyB2YWwudG9JbW11dGFibGUoKSA6IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IHJlc3VsdCA6IE9iamVjdC5mcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlT2JqZWN0KFxuICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBBcnJheS5mcm9tKHRoaXMuX21hcCkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgaXNMaXZlU3RydWN0dXJlKHZhbHVlKSA/IHZhbHVlLmNsb25lKCkgOiBkZWVwQ2xvbmUodmFsdWUpXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL2xpdmVibG9ja3MtaGVscGVycy50c1xuZnVuY3Rpb24gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApIHtcbiAgcmV0dXJuIGxzb25Ub0xpdmVOb2RlKGNyZWF0aW9uT3BUb0xzb24ob3ApKTtcbn1cbmZ1bmN0aW9uIGNyZWF0aW9uT3BUb0xzb24ob3ApIHtcbiAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgY2FzZSA4IC8qIENSRUFURV9SRUdJU1RFUiAqLzpcbiAgICAgIHJldHVybiBvcC5kYXRhO1xuICAgIGNhc2UgNCAvKiBDUkVBVEVfT0JKRUNUICovOlxuICAgICAgcmV0dXJuIG5ldyBMaXZlT2JqZWN0KG9wLmRhdGEpO1xuICAgIGNhc2UgNyAvKiBDUkVBVEVfTUFQICovOlxuICAgICAgcmV0dXJuIG5ldyBMaXZlTWFwKCk7XG4gICAgY2FzZSAyIC8qIENSRUFURV9MSVNUICovOlxuICAgICAgcmV0dXJuIG5ldyBMaXZlTGlzdCgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob3AsIFwiVW5rbm93biBjcmVhdGlvbiBPcFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTYW1lTm9kZU9yQ2hpbGRPZihub2RlLCBwYXJlbnQpIHtcbiAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgcmV0dXJuIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZS5wYXJlbnQubm9kZSwgcGFyZW50KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBMaXZlUmVnaXN0ZXIuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIENSRFQgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplVG9Mc29uKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgc3dpdGNoIChjcmR0LnR5cGUpIHtcbiAgICBjYXNlIDAgLyogT0JKRUNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMSAvKiBMSVNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZUxpc3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDIgLyogTUFQICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU1hcC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzoge1xuICAgICAgcmV0dXJuIGNyZHQuZGF0YTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZUxpc3QodmFsdWUpIHx8IGlzTGl2ZU1hcCh2YWx1ZSkgfHwgaXNMaXZlT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgfHwgaXNMaXZlUmVnaXN0ZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNMaXZlTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU1hcCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwO1xufVxuZnVuY3Rpb24gaXNMaXZlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVSZWdpc3Rlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXI7XG59XG5mdW5jdGlvbiBjbG9uZUxzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpID8gdmFsdWUuY2xvbmUoKSA6IGRlZXBDbG9uZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBsaXZlTm9kZVRvTHNvbihvYmopIHtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlTGlzdCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlTWFwIHx8IG9iaiBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3NlcnROZXZlcihvYmosIFwiVW5rbm93biBBYnN0cmFjdENyZHRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxzb25Ub0xpdmVOb2RlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlUmVnaXN0ZXIodmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3SXRlbXMpIHtcbiAgY29uc3Qgb3BzID0gW107XG4gIGN1cnJlbnRJdGVtcy5mb3JFYWNoKChfLCBpZCkgPT4ge1xuICAgIGlmICghbmV3SXRlbXMuZ2V0KGlkKSkge1xuICAgICAgb3BzLnB1c2goe1xuICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbmV3SXRlbXMuZm9yRWFjaCgoY3JkdCwgaWQpID0+IHtcbiAgICBjb25zdCBjdXJyZW50Q3JkdCA9IGN1cnJlbnRJdGVtcy5nZXQoaWQpO1xuICAgIGlmIChjdXJyZW50Q3JkdCkge1xuICAgICAgaWYgKGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8pIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDcmR0LnR5cGUgIT09IDAgLyogT0JKRUNUICovIHx8IEpTT04uc3RyaW5naWZ5KGNyZHQuZGF0YSkgIT09IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRDcmR0LmRhdGEpKSB7XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNyZHQucGFyZW50S2V5ICE9PSBjdXJyZW50Q3JkdC5wYXJlbnRLZXkpIHtcbiAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGFyZW50S2V5OiBubihjcmR0LnBhcmVudEtleSwgXCJQYXJlbnQga2V5IG11c3Qgbm90IGJlIG1pc3NpbmdcIilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5LFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMSVNUICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDAgLyogT0JKRUNUICovOlxuICAgICAgICAgIGlmIChjcmR0LnBhcmVudElkID09PSB2b2lkIDAgfHwgY3JkdC5wYXJlbnRLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIkludGVybmFsIGVycm9yLiBDYW5ub3Qgc2VyaWFsaXplIHN0b3JhZ2Ugcm9vdCBpbnRvIGFuIG9wZXJhdGlvblwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogTUFQICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcyhzZWNvbmQudXBkYXRlcykpIHtcbiAgICB1cGRhdGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNlY29uZCxcbiAgICB1cGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZU1hcFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlczogdXBkYXRlcy5jb25jYXQoc2Vjb25kLnVwZGF0ZXMpXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZVN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgaWYgKGZpcnN0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc2Vjb25kO1xuICB9XG4gIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVPYmplY3RcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVNYXBcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlTWFwXCIpIHtcbiAgICByZXR1cm4gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVMaXN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZUxpc3RcIikge1xuICAgIHJldHVybiBtZXJnZUxpc3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIHtcbiAgfVxuICByZXR1cm4gc2Vjb25kO1xufVxuZnVuY3Rpb24gaXNQbGFpbih2YWx1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiKSB7XG4gIGlmICghaXNQbGFpbikge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoIHx8IFwicm9vdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKCFpc1BsYWluKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShcbiAgICAgICAgbmVzdGVkVmFsdWUsXG4gICAgICAgIG5lc3RlZFBhdGhcbiAgICAgICk7XG4gICAgICBpZiAobm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9saWIvZGVidWcudHNcbmZ1bmN0aW9uIGNhcHR1cmVTdGFja1RyYWNlKG1zZywgdHJhY2VSb290KSB7XG4gIGNvbnN0IGVycm9yTGlrZSA9IHsgbmFtZTogbXNnIH07XG4gIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3JMaWtlLCB0cmFjZVJvb3QpO1xuICByZXR1cm4gZXJyb3JMaWtlLnN0YWNrO1xufVxuXG4vLyBzcmMvbGliL0pzb24udHNcbmZ1bmN0aW9uIGlzSnNvblNjYWxhcihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBkYXRhID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGlzSnNvbkFycmF5KGRhdGEpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YSk7XG59XG5mdW5jdGlvbiBpc0pzb25PYmplY3QoZGF0YSkge1xuICByZXR1cm4gIWlzSnNvblNjYWxhcihkYXRhKSAmJiAhaXNKc29uQXJyYXkoZGF0YSk7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9DbGllbnRNc2cudHNcbnZhciBDbGllbnRNc2dDb2RlID0gLyogQF9fUFVSRV9fICovICgoQ2xpZW50TXNnQ29kZTIpID0+IHtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfUFJFU0VOQ0VcIl0gPSAxMDBdID0gXCJVUERBVEVfUFJFU0VOQ0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJCUk9BRENBU1RfRVZFTlRcIl0gPSAxMDNdID0gXCJCUk9BRENBU1RfRVZFTlRcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9TVE9SQUdFXCJdID0gMjAwXSA9IFwiRkVUQ0hfU1RPUkFHRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9TVE9SQUdFXCJdID0gMjAxXSA9IFwiVVBEQVRFX1NUT1JBR0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9ZRE9DXCJdID0gMzAwXSA9IFwiRkVUQ0hfWURPQ1wiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9ZRE9DXCJdID0gMzAxXSA9IFwiVVBEQVRFX1lET0NcIjtcbiAgcmV0dXJuIENsaWVudE1zZ0NvZGUyO1xufSkoQ2xpZW50TXNnQ29kZSB8fCB7fSk7XG5cbi8vIHNyYy9yZWZzL0ltbXV0YWJsZVJlZi50c1xuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBwYXRjaCkge1xuICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICBjb25zdCBuZXdWYWx1ZSA9IHsgLi4udGFyZ2V0IH07XG4gIE9iamVjdC5rZXlzKHBhdGNoKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaztcbiAgICBjb25zdCB2YWwgPSBwYXRjaFtrZXldO1xuICAgIGlmIChuZXdWYWx1ZVtrZXldICE9PSB2YWwpIHtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBkZWxldGUgbmV3VmFsdWVba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdXBkYXRlZCA/IG5ld1ZhbHVlIDogdGFyZ2V0O1xufVxudmFyIEltbXV0YWJsZVJlZiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZXYgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgfVxuICBnZXQgZGlkSW52YWxpZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZXYub2JzZXJ2YWJsZTtcbiAgfVxuICBpbnZhbGlkYXRlKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9jYWNoZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2V2Lm5vdGlmeSgpO1xuICAgIH1cbiAgfVxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUgPz8gKHRoaXMuX2NhY2hlID0gdGhpcy5fdG9JbW11dGFibGUoKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWZzL090aGVyc1JlZi50c1xuZnVuY3Rpb24gbWFrZVVzZXIoY29ubiwgcHJlc2VuY2UpIHtcbiAgY29uc3QgeyBjb25uZWN0aW9uSWQsIGlkLCBpbmZvIH0gPSBjb25uO1xuICBjb25zdCBjYW5Xcml0ZSA9IGNhbldyaXRlU3RvcmFnZShjb25uLnNjb3Blcyk7XG4gIHJldHVybiBmcmVlemUoXG4gICAgY29tcGFjdE9iamVjdCh7XG4gICAgICBjb25uZWN0aW9uSWQsXG4gICAgICBpZCxcbiAgICAgIGluZm8sXG4gICAgICBjYW5Xcml0ZSxcbiAgICAgIGNhbkNvbW1lbnQ6IGNhbkNvbW1lbnQoY29ubi5zY29wZXMpLFxuICAgICAgaXNSZWFkT25seTogIWNhbldyaXRlLFxuICAgICAgLy8gRGVwcmVjYXRlZCwga2VwdCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eVxuICAgICAgcHJlc2VuY2VcbiAgICB9KVxuICApO1xufVxudmFyIE90aGVyc1JlZiA9IGNsYXNzIGV4dGVuZHMgSW1tdXRhYmxlUmVmIHtcbiAgLy9cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb25uZWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcHJlc2VuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl91c2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgY29ubmVjdGlvbklkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbnMua2V5cygpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHVzZXJzID0gY29tcGFjdChcbiAgICAgIEFycmF5LmZyb20odGhpcy5fcHJlc2VuY2VzLmtleXMoKSkubWFwKFxuICAgICAgICAoY29ubmVjdGlvbklkKSA9PiB0aGlzLmdldFVzZXIoTnVtYmVyKGNvbm5lY3Rpb25JZCkpXG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm4gdXNlcnM7XG4gIH1cbiAgY2xlYXJPdGhlcnMoKSB7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3ByZXNlbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fdXNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2dldFVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgY29uc3QgY29ubiA9IHRoaXMuX2Nvbm5lY3Rpb25zLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGNvbnN0IHByZXNlbmNlID0gdGhpcy5fcHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb25uICE9PSB2b2lkIDAgJiYgcHJlc2VuY2UgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBnZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IGNhY2hlZFVzZXIgPSB0aGlzLl91c2Vycy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBpZiAoY2FjaGVkVXNlcikge1xuICAgICAgcmV0dXJuIGNhY2hlZFVzZXI7XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVkVXNlciA9IHRoaXMuX2dldFVzZXIoY29ubmVjdGlvbklkKTtcbiAgICBpZiAoY29tcHV0ZWRVc2VyKSB7XG4gICAgICB0aGlzLl91c2Vycy5zZXQoY29ubmVjdGlvbklkLCBjb21wdXRlZFVzZXIpO1xuICAgICAgcmV0dXJuIGNvbXB1dGVkVXNlcjtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9pbnZhbGlkYXRlVXNlcihjb25uZWN0aW9uSWQpIHtcbiAgICBpZiAodGhpcy5fdXNlcnMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgIHRoaXMuX3VzZXJzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogUmVjb3JkcyBhIGtub3duIGNvbm5lY3Rpb24uIFRoaXMgcmVjb3JkcyB0aGUgY29ubmVjdGlvbiBJRCBhbmQgdGhlXG4gICAqIGFzc29jaWF0ZWQgbWV0YWRhdGEuXG4gICAqL1xuICBzZXRDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCwgbWV0YVVzZXJJZCwgbWV0YVVzZXJJbmZvLCBzY29wZXMpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9ucy5zZXQoXG4gICAgICBjb25uZWN0aW9uSWQsXG4gICAgICBmcmVlemUoe1xuICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgIGlkOiBtZXRhVXNlcklkLFxuICAgICAgICBpbmZvOiBtZXRhVXNlckluZm8sXG4gICAgICAgIHNjb3Blc1xuICAgICAgfSlcbiAgICApO1xuICAgIGlmICh0aGlzLl9wcmVzZW5jZXMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGEga25vd24gY29ubmVjdGlvbklkLiBSZW1vdmVzIGJvdGggdGhlIGNvbm5lY3Rpb24ncyBtZXRhZGF0YSBhbmRcbiAgICogdGhlIHByZXNlbmNlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgcmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uSWQpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9ucy5kZWxldGUoY29ubmVjdGlvbklkKTtcbiAgICB0aGlzLl9wcmVzZW5jZXMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgdGhpcy5faW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgfVxuICAvKipcbiAgICogU3RvcmVzIGEgbmV3IHVzZXIgZnJvbSBhIGZ1bGwgcHJlc2VuY2UgdXBkYXRlLiBJZiB0aGUgdXNlciBhbHJlYWR5IGV4aXN0cyxcbiAgICogaXRzIGtub3duIHByZXNlbmNlIGRhdGEgaXMgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBzZXRPdGhlcihjb25uZWN0aW9uSWQsIHByZXNlbmNlKSB7XG4gICAgdGhpcy5fcHJlc2VuY2VzLnNldChjb25uZWN0aW9uSWQsIGZyZWV6ZShjb21wYWN0T2JqZWN0KHByZXNlbmNlKSkpO1xuICAgIGlmICh0aGlzLl9jb25uZWN0aW9ucy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgdGhpcy5faW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBhdGNoZXMgdGhlIHByZXNlbmNlIGRhdGEgZm9yIGFuIGV4aXN0aW5nIFwib3RoZXJcIi4gSWYgd2UgZG9uJ3Qga25vdyB0aGVcbiAgICogaW5pdGlhbCBwcmVzZW5jZSBkYXRhIGZvciB0aGlzIHVzZXIgeWV0LCBkaXNjYXJkIHRoaXMgcGF0Y2ggYW5kIGF3YWl0IHRoZVxuICAgKiBmdWxsIC5zZXRPdGhlcigpIGNhbGwgZmlyc3QuXG4gICAqL1xuICBwYXRjaE90aGVyKGNvbm5lY3Rpb25JZCwgcGF0Y2gpIHtcbiAgICBjb25zdCBvbGRQcmVzZW5jZSA9IHRoaXMuX3ByZXNlbmNlcy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICBpZiAob2xkUHJlc2VuY2UgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdQcmVzZW5jZSA9IG1lcmdlKG9sZFByZXNlbmNlLCBwYXRjaCk7XG4gICAgaWYgKG9sZFByZXNlbmNlICE9PSBuZXdQcmVzZW5jZSkge1xuICAgICAgdGhpcy5fcHJlc2VuY2VzLnNldChjb25uZWN0aW9uSWQsIGZyZWV6ZShuZXdQcmVzZW5jZSkpO1xuICAgICAgdGhpcy5faW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9yZWZzL1BhdGNoYWJsZVJlZi50c1xudmFyIFBhdGNoYWJsZVJlZiA9IGNsYXNzIGV4dGVuZHMgSW1tdXRhYmxlUmVmIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZGF0YSA9IGZyZWV6ZShjb21wYWN0T2JqZWN0KGRhdGEpKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgY3VycmVudCBvYmplY3QuXG4gICAqL1xuICBwYXRjaChwYXRjaCkge1xuICAgIGNvbnN0IG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IG5ld0RhdGEgPSBtZXJnZShvbGREYXRhLCBwYXRjaCk7XG4gICAgaWYgKG9sZERhdGEgIT09IG5ld0RhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBmcmVlemUobmV3RGF0YSk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9yZWZzL1ZhbHVlUmVmLnRzXG52YXIgVmFsdWVSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxWYWx1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fdmFsdWUgPSBmcmVlemUoaW5pdGlhbFZhbHVlKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbiAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWUgPSBmcmVlemUobmV3VmFsdWUpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICB9XG59O1xudmFyIERlcml2ZWRSZWYgPSBjbGFzcyBleHRlbmRzIEltbXV0YWJsZVJlZiB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHRyYW5zZm9ybUZuID0gYXJncy5wb3AoKTtcbiAgICBjb25zdCBvdGhlclJlZnMgPSBhcmdzO1xuICAgIHRoaXMuX3JlZnMgPSBvdGhlclJlZnM7XG4gICAgdGhpcy5fcmVmcy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICAgIHJlZi5kaWRJbnZhbGlkYXRlLnN1YnNjcmliZSgoKSA9PiB0aGlzLmludmFsaWRhdGUoKSk7XG4gICAgfSk7XG4gICAgdGhpcy5fdHJhbnNmb3JtID0gdHJhbnNmb3JtRm47XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybShcbiAgICAgIC4uLnRoaXMuX3JlZnMubWFwKChyZWYpID0+IHJlZi5jdXJyZW50KVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9yb29tLnRzXG52YXIgTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUgPSAxMDI0ICogMTAyNCAtIDEwMjQ7XG5mdW5jdGlvbiBtYWtlSWRGYWN0b3J5KGNvbm5lY3Rpb25JZCkge1xuICBsZXQgY291bnQgPSAwO1xuICByZXR1cm4gKCkgPT4gYCR7Y29ubmVjdGlvbklkfToke2NvdW50Kyt9YDtcbn1cbmZ1bmN0aW9uIHVzZXJUb1RyZWVOb2RlKGtleSwgdXNlcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVXNlclwiLFxuICAgIGlkOiBgJHt1c2VyLmNvbm5lY3Rpb25JZH1gLFxuICAgIGtleSxcbiAgICBwYXlsb2FkOiB1c2VyXG4gIH07XG59XG5mdW5jdGlvbiBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpIHtcbiAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gIGNvbnN0IGluQmFja2dyb3VuZFNpbmNlID0geyBjdXJyZW50OiBudWxsIH07XG4gIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID8/IERhdGUubm93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBkb2M/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgIGRvYz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgfTtcbiAgcmV0dXJuIFtpbkJhY2tncm91bmRTaW5jZSwgdW5zdWJdO1xufVxudmFyIENvbW1lbnRzQXBpRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlQ29tbWVudHNBcGkocm9vbUlkLCBnZXRBdXRoVmFsdWUsIGZldGNoQ2xpZW50QXBpKSB7XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoQ29tbWVudHNBcGkoZW5kcG9pbnQsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IGF3YWl0IGdldEF1dGhWYWx1ZSgpO1xuICAgIHJldHVybiBmZXRjaENsaWVudEFwaShyb29tSWQsIGVuZHBvaW50LCBhdXRoVmFsdWUsIG9wdGlvbnMsIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hKc29uKGVuZHBvaW50LCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQ29tbWVudHNBcGkoZW5kcG9pbnQsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgIGxldCBlcnJvcjM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIGVycm9yMyA9IG5ldyBDb21tZW50c0FwaUVycm9yKFxuICAgICAgICAgICAgZXJyb3JCb2R5Lm1lc3NhZ2UsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBlcnJvckJvZHlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBlcnJvcjMgPSBuZXcgQ29tbWVudHNBcGlFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRocmVhZHMob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hDb21tZW50c0FwaShcbiAgICAgIFwiL3RocmVhZHMvc2VhcmNoXCIsXG4gICAgICB7XG4gICAgICAgIHNpbmNlOiBvcHRpb25zPy5zaW5jZT8udG9JU09TdHJpbmcoKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIC4uLm9wdGlvbnM/LnF1ZXJ5Py5tZXRhZGF0YSAmJiB7IG1ldGFkYXRhOiBvcHRpb25zLnF1ZXJ5Lm1ldGFkYXRhIH1cbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWRzOiBqc29uLmRhdGEubWFwKCh0aHJlYWQpID0+IGNvbnZlcnRUb1RocmVhZERhdGEodGhyZWFkKSksXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uczoganNvbi5pbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAgIChub3RpZmljYXRpb24pID0+IGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShub3RpZmljYXRpb24pXG4gICAgICAgICksXG4gICAgICAgIGRlbGV0ZWRUaHJlYWRzOiBqc29uLmRlbGV0ZWRUaHJlYWRzLm1hcChcbiAgICAgICAgICAoaW5mbykgPT4gY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbyhpbmZvKVxuICAgICAgICApLFxuICAgICAgICBkZWxldGVkSW5ib3hOb3RpZmljYXRpb25zOiBqc29uLmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAgIChpbmZvKSA9PiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRlbGV0ZUluZm8oaW5mbylcbiAgICAgICAgKSxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGhyZWFkczogW10sXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogW10sXG4gICAgICAgIGRlbGV0ZWRUaHJlYWRzOiBbXSxcbiAgICAgICAgZGVsZXRlZEluYm94Tm90aWZpY2F0aW9uczogW10sXG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICByZXF1ZXN0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhyZWFkcy5cIik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRocmVhZCh7IHRocmVhZElkIH0pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQ29tbWVudHNBcGkoXG4gICAgICBgL3RocmVhZC13aXRoLW5vdGlmaWNhdGlvbi8ke3RocmVhZElkfWBcbiAgICApO1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZDogY29udmVydFRvVGhyZWFkRGF0YShqc29uLnRocmVhZCksXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uOiBqc29uLmluYm94Tm90aWZpY2F0aW9uID8gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKGpzb24uaW5ib3hOb3RpZmljYXRpb24pIDogdm9pZCAwXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aHJlYWQgJHt0aHJlYWRJZH0uYCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRocmVhZCh7XG4gICAgbWV0YWRhdGEsXG4gICAgYm9keSxcbiAgICBjb21tZW50SWQsXG4gICAgdGhyZWFkSWRcbiAgfSkge1xuICAgIGNvbnN0IHRocmVhZCA9IGF3YWl0IGZldGNoSnNvbihcbiAgICAgIFwiL3RocmVhZHNcIixcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpZDogdGhyZWFkSWQsXG4gICAgICAgICAgY29tbWVudDoge1xuICAgICAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvVGhyZWFkRGF0YSh0aHJlYWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRUaHJlYWRNZXRhZGF0YSh7XG4gICAgbWV0YWRhdGEsXG4gICAgdGhyZWFkSWRcbiAgfSkge1xuICAgIHJldHVybiBhd2FpdCBmZXRjaEpzb24oXG4gICAgICBgL3RocmVhZHMvJHtlbmNvZGVVUklDb21wb25lbnQodGhyZWFkSWQpfS9tZXRhZGF0YWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZCxcbiAgICBib2R5XG4gIH0pIHtcbiAgICBjb25zdCBjb21tZW50ID0gYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vY29tbWVudHNgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgICAgYm9keVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVkaXRDb21tZW50KHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgYm9keVxuICB9KSB7XG4gICAgY29uc3QgY29tbWVudCA9IGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L2NvbW1lbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBjb21tZW50SWRcbiAgICAgICl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBib2R5XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoY29tbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ29tbWVudDIoe1xuICAgIHRocmVhZElkLFxuICAgIGNvbW1lbnRJZFxuICB9KSB7XG4gICAgYXdhaXQgZmV0Y2hKc29uKFxuICAgICAgYC90aHJlYWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRocmVhZElkKX0vY29tbWVudHMvJHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNvbW1lbnRJZFxuICAgICAgKX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZFJlYWN0aW9uMih7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGVtb2ppXG4gIH0pIHtcbiAgICBjb25zdCByZWFjdGlvbiA9IGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L2NvbW1lbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBjb21tZW50SWRcbiAgICAgICl9L3JlYWN0aW9uc2AsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtb2ppIH0pXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbihyZWFjdGlvbik7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVtb3ZlUmVhY3Rpb24yKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgZW1vamlcbiAgfSkge1xuICAgIGF3YWl0IGZldGNoSnNvbihcbiAgICAgIGAvdGhyZWFkcy8ke2VuY29kZVVSSUNvbXBvbmVudCh0aHJlYWRJZCl9L2NvbW1lbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBjb21tZW50SWRcbiAgICAgICl9L3JlYWN0aW9ucy8ke2VuY29kZVVSSUNvbXBvbmVudChlbW9qaSl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFRocmVhZHMsXG4gICAgZ2V0VGhyZWFkLFxuICAgIGNyZWF0ZVRocmVhZCxcbiAgICBlZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgY3JlYXRlQ29tbWVudCxcbiAgICBlZGl0Q29tbWVudCxcbiAgICBkZWxldGVDb21tZW50OiBkZWxldGVDb21tZW50MixcbiAgICBhZGRSZWFjdGlvbjogYWRkUmVhY3Rpb24yLFxuICAgIHJlbW92ZVJlYWN0aW9uOiByZW1vdmVSZWFjdGlvbjJcbiAgfTtcbn1cbnZhciBNQVJLX0lOQk9YX05PVElGSUNBVElPTlNfQVNfUkVBRF9CQVRDSF9ERUxBWTIgPSA1MDtcbmZ1bmN0aW9uIGNyZWF0ZVJvb20ob3B0aW9ucywgY29uZmlnKSB7XG4gIGNvbnN0IGluaXRpYWxQcmVzZW5jZSA9IHR5cGVvZiBvcHRpb25zLmluaXRpYWxQcmVzZW5jZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5pbml0aWFsUHJlc2VuY2UoY29uZmlnLnJvb21JZCkgOiBvcHRpb25zLmluaXRpYWxQcmVzZW5jZTtcbiAgY29uc3QgaW5pdGlhbFN0b3JhZ2UgPSB0eXBlb2Ygb3B0aW9ucy5pbml0aWFsU3RvcmFnZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5pbml0aWFsU3RvcmFnZShjb25maWcucm9vbUlkKSA6IG9wdGlvbnMuaW5pdGlhbFN0b3JhZ2U7XG4gIGNvbnN0IFtpbkJhY2tncm91bmRTaW5jZSwgdW5pbnN0YWxsQmdUYWJTcHldID0gaW5zdGFsbEJhY2tncm91bmRUYWJTcHkoKTtcbiAgY29uc3QgZGVsZWdhdGVzID0ge1xuICAgIC4uLmNvbmZpZy5kZWxlZ2F0ZXMsXG4gICAgLy8gQSBjb25uZWN0aW9uIGlzIGFsbG93ZWQgdG8gZ28gaW50byBcInpvbWJpZSBzdGF0ZVwiIG9ubHkgaWYgYWxsIG9mIHRoZVxuICAgIC8vIGZvbGxvd2luZyBjb25kaXRpb25zIGFwcGx5OlxuICAgIC8vXG4gICAgLy8gLSBUaGUgYGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0YCBjbGllbnQgb3B0aW9uIGlzIGNvbmZpZ3VyZWRcbiAgICAvLyAtIFRoZSBicm93c2VyIHdpbmRvdyBoYXMgYmVlbiBpbiB0aGUgYmFja2dyb3VuZCBmb3IgYXQgbGVhc3RcbiAgICAvLyAgIGBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dGAgbWlsbGlzZWNvbmRzXG4gICAgLy8gLSBUaGVyZSBhcmUgbm8gcGVuZGluZyBjaGFuZ2VzXG4gICAgLy9cbiAgICBjYW5ab21iaWUoKSB7XG4gICAgICByZXR1cm4gY29uZmlnLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ICE9PSB2b2lkIDAgJiYgaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCAhPT0gbnVsbCAmJiBEYXRlLm5vdygpID4gaW5CYWNrZ3JvdW5kU2luY2UuY3VycmVudCArIGNvbmZpZy5iYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCAmJiBnZXRTdG9yYWdlU3RhdHVzKCkgIT09IFwic3luY2hyb25pemluZ1wiO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbWFuYWdlZFNvY2tldCA9IG5ldyBNYW5hZ2VkU29ja2V0KFxuICAgIGRlbGVnYXRlcyxcbiAgICBjb25maWcuZW5hYmxlRGVidWdMb2dnaW5nXG4gICk7XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgYnVmZmVyOiB7XG4gICAgICBmbHVzaFRpbWVySUQ6IHZvaWQgMCxcbiAgICAgIGxhc3RGbHVzaGVkQXQ6IDAsXG4gICAgICBwcmVzZW5jZVVwZGF0ZXM6IChcbiAgICAgICAgLy8gUXVldWUgdXAgdGhlIGluaXRpYWwgcHJlc2VuY2UgbWVzc2FnZSBhcyBhIEZ1bGwgUHJlc2VuY2XihKIgdXBkYXRlXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImZ1bGxcIixcbiAgICAgICAgICBkYXRhOiBpbml0aWFsUHJlc2VuY2VcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgIHN0b3JhZ2VPcGVyYXRpb25zOiBbXVxuICAgIH0sXG4gICAgc3RhdGljU2Vzc2lvbkluZm86IG5ldyBWYWx1ZVJlZihudWxsKSxcbiAgICBkeW5hbWljU2Vzc2lvbkluZm86IG5ldyBWYWx1ZVJlZihudWxsKSxcbiAgICBteVByZXNlbmNlOiBuZXcgUGF0Y2hhYmxlUmVmKGluaXRpYWxQcmVzZW5jZSksXG4gICAgb3RoZXJzOiBuZXcgT3RoZXJzUmVmKCksXG4gICAgaW5pdGlhbFN0b3JhZ2UsXG4gICAgaWRGYWN0b3J5OiBudWxsLFxuICAgIC8vIFN0b3JhZ2VcbiAgICBjbG9jazogMCxcbiAgICBvcENsb2NrOiAwLFxuICAgIG5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIHJvb3Q6IHZvaWQgMCxcbiAgICB1bmRvU3RhY2s6IFtdLFxuICAgIHJlZG9TdGFjazogW10sXG4gICAgcGF1c2VkSGlzdG9yeTogbnVsbCxcbiAgICBhY3RpdmVCYXRjaDogbnVsbCxcbiAgICB1bmFja25vd2xlZGdlZE9wczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAvLyBEZWJ1Z1xuICAgIG9wU3RhY2tUcmFjZXM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkgOiB2b2lkIDBcbiAgfTtcbiAgY29uc3QgZG9Ob3RCYXRjaFVwZGF0ZXMgPSAoY2IpID0+IGNiKCk7XG4gIGNvbnN0IGJhdGNoVXBkYXRlcyA9IGNvbmZpZy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA/PyBkb05vdEJhdGNoVXBkYXRlcztcbiAgbGV0IGxhc3RUb2tlbktleTtcbiAgZnVuY3Rpb24gb25TdGF0dXNEaWRDaGFuZ2UobmV3U3RhdHVzKSB7XG4gICAgY29uc3QgYXV0aFZhbHVlID0gbWFuYWdlZFNvY2tldC5hdXRoVmFsdWU7XG4gICAgaWYgKGF1dGhWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdG9rZW5LZXkgPSBnZXRBdXRoQmVhcmVySGVhZGVyRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpO1xuICAgICAgaWYgKHRva2VuS2V5ICE9PSBsYXN0VG9rZW5LZXkpIHtcbiAgICAgICAgbGFzdFRva2VuS2V5ID0gdG9rZW5LZXk7XG4gICAgICAgIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJzZWNyZXRcIikge1xuICAgICAgICAgIGNvbnN0IHRva2VuID0gYXV0aFZhbHVlLnRva2VuLnBhcnNlZDtcbiAgICAgICAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvLnNldCh7XG4gICAgICAgICAgICB1c2VySWQ6IHRva2VuLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8gPyB0b2tlbi5pZCA6IHRva2VuLnVpZCxcbiAgICAgICAgICAgIHVzZXJJbmZvOiB0b2tlbi5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovID8gdG9rZW4uaW5mbyA6IHRva2VuLnVpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5zdGF0aWNTZXNzaW9uSW5mby5zZXQoe1xuICAgICAgICAgICAgdXNlcklkOiB2b2lkIDAsXG4gICAgICAgICAgICB1c2VySW5mbzogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGV2ZW50SHViLnN0YXR1cy5ub3RpZnkobmV3U3RhdHVzKTtcbiAgICAgIG5vdGlmeVNlbGZDaGFuZ2VkKGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICB9KTtcbiAgfVxuICBsZXQgX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZDtcbiAgbGV0IF9oYXNMb3N0Q29ubmVjdGlvbiA9IGZhbHNlO1xuICBmdW5jdGlvbiBoYW5kbGVDb25uZWN0aW9uTG9zc0V2ZW50KG5ld1N0YXR1cykge1xuICAgIGlmIChuZXdTdGF0dXMgPT09IFwicmVjb25uZWN0aW5nXCIpIHtcbiAgICAgIF9jb25uZWN0aW9uTG9zc1RpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJsb3N0XCIpO1xuICAgICAgICAgIF9oYXNMb3N0Q29ubmVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgY29udGV4dC5vdGhlcnMuY2xlYXJPdGhlcnMoKTtcbiAgICAgICAgICBub3RpZnkoeyBvdGhlcnM6IFt7IHR5cGU6IFwicmVzZXRcIiB9XSB9LCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgY29uZmlnLmxvc3RDb25uZWN0aW9uVGltZW91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dChfY29ubmVjdGlvbkxvc3NUaW1lcklkKTtcbiAgICAgIGlmIChfaGFzTG9zdENvbm5lY3Rpb24pIHtcbiAgICAgICAgaWYgKG5ld1N0YXR1cyA9PT0gXCJkaXNjb25uZWN0ZWRcIikge1xuICAgICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgICBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5ub3RpZnkoXCJmYWlsZWRcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICAgIGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm5vdGlmeShcInJlc3RvcmVkXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF9oYXNMb3N0Q29ubmVjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkRpZENvbm5lY3QoKSB7XG4gICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0ge1xuICAgICAgdHlwZTogXCJmdWxsXCIsXG4gICAgICBkYXRhOiAoXG4gICAgICAgIC8vIEJlY2F1c2UgY29udGV4dC5tZS5jdXJyZW50IGlzIGEgcmVhZG9ubHkgb2JqZWN0LCB3ZSdsbCBoYXZlIHRvXG4gICAgICAgIC8vIG1ha2UgYSBjb3B5IGhlcmUuIE90aGVyd2lzZSwgdHlwZSBlcnJvcnMgaGFwcGVuIGxhdGVyIHdoZW5cbiAgICAgICAgLy8gXCJwYXRjaGluZ1wiIG15IHByZXNlbmNlLlxuICAgICAgICB7IC4uLmNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50IH1cbiAgICAgIClcbiAgICB9O1xuICAgIGlmIChfZ2V0U3RvcmFnZSQgIT09IG51bGwpIHtcbiAgICAgIHJlZnJlc2hTdG9yYWdlKHsgZmx1c2g6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIG9uRGlkRGlzY29ubmVjdCgpIHtcbiAgICBjbGVhclRpbWVvdXQoY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEKTtcbiAgfVxuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5vbk1lc3NhZ2Uuc3Vic2NyaWJlKGhhbmRsZVNlcnZlck1lc3NhZ2UpO1xuICBtYW5hZ2VkU29ja2V0LmV2ZW50cy5zdGF0dXNEaWRDaGFuZ2Uuc3Vic2NyaWJlKG9uU3RhdHVzRGlkQ2hhbmdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShoYW5kbGVDb25uZWN0aW9uTG9zc0V2ZW50KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuZGlkQ29ubmVjdC5zdWJzY3JpYmUob25EaWRDb25uZWN0KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuZGlkRGlzY29ubmVjdC5zdWJzY3JpYmUob25EaWREaXNjb25uZWN0KTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25MaXZlYmxvY2tzRXJyb3Iuc3Vic2NyaWJlKChlcnIpID0+IHtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBlcnJvcjIoXG4gICAgICAgICAgYENvbm5lY3Rpb24gdG8gd2Vic29ja2V0IHNlcnZlciBjbG9zZWQuIFJlYXNvbjogJHtlcnIubWVzc2FnZX0gKGNvZGU6ICR7ZXJyLmNvZGV9KS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBldmVudEh1Yi5lcnJvci5ub3RpZnkoZXJyKTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IHBvb2wgPSB7XG4gICAgcm9vbUlkOiBjb25maWcucm9vbUlkLFxuICAgIGdldE5vZGU6IChpZCkgPT4gY29udGV4dC5ub2Rlcy5nZXQoaWQpLFxuICAgIGFkZE5vZGU6IChpZCwgbm9kZSkgPT4gdm9pZCBjb250ZXh0Lm5vZGVzLnNldChpZCwgbm9kZSksXG4gICAgZGVsZXRlTm9kZTogKGlkKSA9PiB2b2lkIGNvbnRleHQubm9kZXMuZGVsZXRlKGlkKSxcbiAgICBnZW5lcmF0ZUlkOiAoKSA9PiBgJHtnZXRDb25uZWN0aW9uSWQoKX06JHtjb250ZXh0LmNsb2NrKyt9YCxcbiAgICBnZW5lcmF0ZU9wSWQ6ICgpID0+IGAke2dldENvbm5lY3Rpb25JZCgpfToke2NvbnRleHQub3BDbG9jaysrfWAsXG4gICAgZGlzcGF0Y2gob3BzLCByZXZlcnNlLCBzdG9yYWdlVXBkYXRlcykge1xuICAgICAgY29uc3QgYWN0aXZlQmF0Y2ggPSBjb250ZXh0LmFjdGl2ZUJhdGNoO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zdCBzdGFja1RyYWNlID0gY2FwdHVyZVN0YWNrVHJhY2UoXCJTdG9yYWdlIG11dGF0aW9uXCIsIHRoaXMuZGlzcGF0Y2gpO1xuICAgICAgICBpZiAoc3RhY2tUcmFjZSkge1xuICAgICAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICAgICAgICBpZiAob3Aub3BJZCkge1xuICAgICAgICAgICAgICBubihjb250ZXh0Lm9wU3RhY2tUcmFjZXMpLnNldChvcC5vcElkLCBzdGFja1RyYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVCYXRjaCkge1xuICAgICAgICBhY3RpdmVCYXRjaC5vcHMucHVzaCguLi5vcHMpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdG9yYWdlVXBkYXRlcykge1xuICAgICAgICAgIGFjdGl2ZUJhdGNoLnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyhcbiAgICAgICAgICAgICAgYWN0aXZlQmF0Y2gudXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5nZXQoa2V5KSxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZUJhdGNoLnJldmVyc2VPcHMudW5zaGlmdCguLi5yZXZlcnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgYWRkVG9VbmRvU3RhY2socmV2ZXJzZSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgICAgZGlzcGF0Y2hPcHMob3BzKTtcbiAgICAgICAgICBub3RpZnkoeyBzdG9yYWdlVXBkYXRlcyB9LCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGU6ICgpID0+IHtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLmN1cnJlbnQ/LnNjb3BlcztcbiAgICAgIGlmIChzY29wZXMgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjYW5Xcml0ZSA9IGNhbldyaXRlU3RvcmFnZShzY29wZXMpO1xuICAgICAgaWYgKCFjYW5Xcml0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDYW5ub3Qgd3JpdGUgdG8gc3RvcmFnZSB3aXRoIGEgcmVhZCBvbmx5IHVzZXIsIHBsZWFzZSBlbnN1cmUgdGhlIHVzZXIgaGFzIHdyaXRlIHBlcm1pc3Npb25zXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IGV2ZW50SHViID0ge1xuICAgIGNvbm5lY3Rpb246IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIE9sZC9kZXByZWNhdGVkIEFQSVxuICAgIHN0YXR1czogbWFrZUV2ZW50U291cmNlKCksXG4gICAgLy8gTmV3L3JlY29tbWVuZGVkIEFQSVxuICAgIGxvc3RDb25uZWN0aW9uOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBjdXN0b21FdmVudDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc2VsZjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgbXlQcmVzZW5jZTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgb3RoZXJzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBlcnJvcjogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgaGlzdG9yeTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZURpZExvYWQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VTdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHlkb2M6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGNvbW1lbnRzOiBtYWtlRXZlbnRTb3VyY2UoKVxuICB9O1xuICBhc3luYyBmdW5jdGlvbiBmZXRjaENsaWVudEFwaShyb29tSWQsIGVuZHBvaW50LCBhdXRoVmFsdWUsIG9wdGlvbnMyLCBwYXJhbXMpIHtcbiAgICBjb25zdCB1cmwgPSB1cmxqb2luKFxuICAgICAgY29uZmlnLmJhc2VVcmwsXG4gICAgICBgL3YyL2Mvcm9vbXMvJHtlbmNvZGVVUklDb21wb25lbnQocm9vbUlkKX0ke2VuZHBvaW50fWAsXG4gICAgICBwYXJhbXNcbiAgICApO1xuICAgIGNvbnN0IGZldGNoZXIgPSBjb25maWcucG9seWZpbGxzPy5mZXRjaCB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZldGNoO1xuICAgIHJldHVybiBhd2FpdCBmZXRjaGVyKHVybCwge1xuICAgICAgLi4ub3B0aW9uczIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLm9wdGlvbnMyPy5oZWFkZXJzLFxuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Z2V0QXV0aEJlYXJlckhlYWRlckZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKX1gXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RyZWFtRmV0Y2goYXV0aFZhbHVlLCByb29tSWQpIHtcbiAgICByZXR1cm4gZmV0Y2hDbGllbnRBcGkocm9vbUlkLCBcIi9zdG9yYWdlXCIsIGF1dGhWYWx1ZSwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGh0dHBQb3N0VG9Sb29tKGVuZHBvaW50LCBib2R5KSB7XG4gICAgaWYgKCFtYW5hZ2VkU29ja2V0LmF1dGhWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGF1dGhvcml6ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBmZXRjaENsaWVudEFwaShjb25maWcucm9vbUlkLCBlbmRwb2ludCwgbWFuYWdlZFNvY2tldC5hdXRoVmFsdWUsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZW5kTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkUGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2VzKTtcbiAgICBjb25zdCBub25jZSA9IGNvbnRleHQuZHluYW1pY1Nlc3Npb25JbmZvLmN1cnJlbnQ/Lm5vbmNlO1xuICAgIGlmIChjb25maWcudW5zdGFibGVfZmFsbGJhY2tUb0hUVFAgJiYgbm9uY2UpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2VyaWFsaXplZFBheWxvYWQpLmxlbmd0aDtcbiAgICAgIGlmIChzaXplID4gTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUpIHtcbiAgICAgICAgdm9pZCBodHRwUG9zdFRvUm9vbShcIi9zZW5kLW1lc3NhZ2VcIiwgeyBub25jZSwgbWVzc2FnZXMgfSkudGhlbihcbiAgICAgICAgICAocmVzcCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXNwLm9rICYmIHJlc3Auc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICAgICAgbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXNzYWdlIHdhcyB0b28gbGFyZ2UgZm9yIHdlYnNvY2tldHMgYW5kIHNlbnQgb3ZlciBIVFRQIGluc3RlYWRcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG1hbmFnZWRTb2NrZXQuc2VuZChzZXJpYWxpemVkUGF5bG9hZCk7XG4gIH1cbiAgY29uc3Qgc2VsZiA9IG5ldyBEZXJpdmVkUmVmKFxuICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm8sXG4gICAgY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8sXG4gICAgY29udGV4dC5teVByZXNlbmNlLFxuICAgIChzdGF0aWNTZXNzaW9uLCBkeW5hbWljU2Vzc2lvbiwgbXlQcmVzZW5jZSkgPT4ge1xuICAgICAgaWYgKHN0YXRpY1Nlc3Npb24gPT09IG51bGwgfHwgZHluYW1pY1Nlc3Npb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjYW5Xcml0ZSA9IGNhbldyaXRlU3RvcmFnZShkeW5hbWljU2Vzc2lvbi5zY29wZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbm5lY3Rpb25JZDogZHluYW1pY1Nlc3Npb24uYWN0b3IsXG4gICAgICAgICAgaWQ6IHN0YXRpY1Nlc3Npb24udXNlcklkLFxuICAgICAgICAgIGluZm86IHN0YXRpY1Nlc3Npb24udXNlckluZm8sXG4gICAgICAgICAgcHJlc2VuY2U6IG15UHJlc2VuY2UsXG4gICAgICAgICAgY2FuV3JpdGUsXG4gICAgICAgICAgY2FuQ29tbWVudDogY2FuQ29tbWVudChkeW5hbWljU2Vzc2lvbi5zY29wZXMpLFxuICAgICAgICAgIGlzUmVhZE9ubHk6ICFjYW5Xcml0ZVxuICAgICAgICAgIC8vIERlcHJlY2F0ZWQsIGtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGxldCBfbGFzdFNlbGY7XG4gIGZ1bmN0aW9uIG5vdGlmeVNlbGZDaGFuZ2VkKGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGNvbnN0IGN1cnJTZWxmID0gc2VsZi5jdXJyZW50O1xuICAgIGlmIChjdXJyU2VsZiAhPT0gbnVsbCAmJiBjdXJyU2VsZiAhPT0gX2xhc3RTZWxmKSB7XG4gICAgICBiYXRjaGVkVXBkYXRlc1dyYXBwZXIoKCkgPT4ge1xuICAgICAgICBldmVudEh1Yi5zZWxmLm5vdGlmeShjdXJyU2VsZik7XG4gICAgICB9KTtcbiAgICAgIF9sYXN0U2VsZiA9IGN1cnJTZWxmO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZWxmQXNUcmVlTm9kZSA9IG5ldyBEZXJpdmVkUmVmKFxuICAgIHNlbGYsXG4gICAgKG1lKSA9PiBtZSAhPT0gbnVsbCA/IHVzZXJUb1RyZWVOb2RlKFwiTWVcIiwgbWUpIDogbnVsbFxuICApO1xuICBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZVJvb3RGcm9tTWVzc2FnZShtZXNzYWdlLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAobWVzc2FnZS5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yOiBjYW5ub3QgbG9hZCBzdG9yYWdlIHdpdGhvdXQgaXRlbXNcIik7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LnJvb3QgIT09IHZvaWQgMCkge1xuICAgICAgdXBkYXRlUm9vdChtZXNzYWdlLml0ZW1zLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnJvb3QgPSBMaXZlT2JqZWN0Ll9mcm9tSXRlbXMobWVzc2FnZS5pdGVtcywgcG9vbCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrU2l6ZUJlZm9yZSA9IGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0LmluaXRpYWxTdG9yYWdlKSB7XG4gICAgICBpZiAoY29udGV4dC5yb290LmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGV4dC5yb290LnNldChrZXksIGNsb25lTHNvbihjb250ZXh0LmluaXRpYWxTdG9yYWdlW2tleV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29udGV4dC51bmRvU3RhY2subGVuZ3RoID0gc3RhY2tTaXplQmVmb3JlO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVJvb3QoaXRlbXMsIGJhdGNoZWRVcGRhdGVzV3JhcHBlcikge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50SXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBub2RlXSBvZiBjb250ZXh0Lm5vZGVzKSB7XG4gICAgICBjdXJyZW50SXRlbXMuc2V0KGlkLCBub2RlLl9zZXJpYWxpemUoKSk7XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IGdldFRyZWVzRGlmZk9wZXJhdGlvbnMoY3VycmVudEl0ZW1zLCBuZXcgTWFwKGl0ZW1zKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMob3BzLCBmYWxzZSk7XG4gICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICB9XG4gIGZ1bmN0aW9uIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA+PSA1MCkge1xuICAgICAgY29udGV4dC51bmRvU3RhY2suc2hpZnQoKTtcbiAgICB9XG4gICAgY29udGV4dC51bmRvU3RhY2sucHVzaChoaXN0b3J5T3BzKTtcbiAgICBvbkhpc3RvcnlDaGFuZ2UoYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRUb1VuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBpZiAoY29udGV4dC5wYXVzZWRIaXN0b3J5ICE9PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkudW5zaGlmdCguLi5oaXN0b3J5T3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzLCBiYXRjaGVkVXBkYXRlc1dyYXBwZXIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBub3RpZnkodXBkYXRlcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSB1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzO1xuICAgIGNvbnN0IG90aGVyc1VwZGF0ZXMgPSB1cGRhdGVzLm90aGVycztcbiAgICBiYXRjaGVkVXBkYXRlc1dyYXBwZXIoKCkgPT4ge1xuICAgICAgaWYgKG90aGVyc1VwZGF0ZXMgIT09IHZvaWQgMCAmJiBvdGhlcnNVcGRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gY29udGV4dC5vdGhlcnMuY3VycmVudDtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBvdGhlcnNVcGRhdGVzKSB7XG4gICAgICAgICAgZXZlbnRIdWIub3RoZXJzLm5vdGlmeSh7IC4uLmV2ZW50LCBvdGhlcnMgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1cGRhdGVzLnByZXNlbmNlID8/IGZhbHNlKSB7XG4gICAgICAgIG5vdGlmeVNlbGZDaGFuZ2VkKGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgZXZlbnRIdWIubXlQcmVzZW5jZS5ub3RpZnkoY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0b3JhZ2VVcGRhdGVzICE9PSB2b2lkIDAgJiYgc3RvcmFnZVVwZGF0ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgdXBkYXRlczIgPSBBcnJheS5mcm9tKHN0b3JhZ2VVcGRhdGVzLnZhbHVlcygpKTtcbiAgICAgICAgZXZlbnRIdWIuc3RvcmFnZS5ub3RpZnkodXBkYXRlczIpO1xuICAgICAgfVxuICAgICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldENvbm5lY3Rpb25JZCgpIHtcbiAgICBjb25zdCBpbmZvID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8uY3VycmVudDtcbiAgICBpZiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uYWN0b3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW50ZXJuYWwuIFRyaWVkIHRvIGdldCBjb25uZWN0aW9uIGlkIGJ1dCBjb25uZWN0aW9uIHdhcyBuZXZlciBvcGVuXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5T3BzKHJhd09wcywgaXNMb2NhbCkge1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIHJldmVyc2U6IFtdLFxuICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBwcmVzZW5jZTogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZWROb2RlSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBvcHMgPSByYXdPcHMubWFwKChvcCkgPT4ge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIiAmJiAhb3Aub3BJZCkge1xuICAgICAgICByZXR1cm4geyAuLi5vcCwgb3BJZDogcG9vbC5nZW5lcmF0ZU9wSWQoKSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnN0IHJldmVyc2UgPSB7XG4gICAgICAgICAgdHlwZTogXCJwcmVzZW5jZVwiLFxuICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgICAgICByZXZlcnNlLmRhdGFba2V5XSA9IGNvbnRleHQubXlQcmVzZW5jZS5jdXJyZW50W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5teVByZXNlbmNlLnBhdGNoKG9wLmRhdGEpO1xuICAgICAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0geyB0eXBlOiBcInBhcnRpYWxcIiwgZGF0YTogb3AuZGF0YSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhW2tleV0gPSBvcC5kYXRhW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5yZXZlcnNlLnVuc2hpZnQocmV2ZXJzZSk7XG4gICAgICAgIG91dHB1dC5wcmVzZW5jZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgc291cmNlO1xuICAgICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICAgIHNvdXJjZSA9IDAgLyogVU5ET1JFRE9fUkVDT05ORUNUICovO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9wSWQgPSBubihvcC5vcElkKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBubihjb250ZXh0Lm9wU3RhY2tUcmFjZXMpLmRlbGV0ZShvcElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGVsZXRlZCA9IGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuZGVsZXRlKG9wSWQpO1xuICAgICAgICAgIHNvdXJjZSA9IGRlbGV0ZWQgPyAyIC8qIEFDSyAqLyA6IDEgLyogUkVNT1RFICovO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGx5T3BSZXN1bHQgPSBhcHBseU9wKG9wLCBzb3VyY2UpO1xuICAgICAgICBpZiAoYXBwbHlPcFJlc3VsdC5tb2RpZmllZCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVJZCA9IGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQ7XG4gICAgICAgICAgaWYgKCEobm9kZUlkICYmIGNyZWF0ZWROb2RlSWRzLmhhcyhub2RlSWQpKSkge1xuICAgICAgICAgICAgb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICAgICAgbm4oYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZCksXG4gICAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXMoXG4gICAgICAgICAgICAgICAgb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLmdldChubihhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkKSksXG4gICAgICAgICAgICAgICAgYXBwbHlPcFJlc3VsdC5tb2RpZmllZFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3V0cHV0LnJldmVyc2UudW5zaGlmdCguLi5hcHBseU9wUmVzdWx0LnJldmVyc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gMiAvKiBDUkVBVEVfTElTVCAqLyB8fCBvcC50eXBlID09PSA3IC8qIENSRUFURV9NQVAgKi8gfHwgb3AudHlwZSA9PT0gNCAvKiBDUkVBVEVfT0JKRUNUICovKSB7XG4gICAgICAgICAgICBjcmVhdGVkTm9kZUlkcy5hZGQobm4ob3AuaWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wcyxcbiAgICAgIHJldmVyc2U6IG91dHB1dC5yZXZlcnNlLFxuICAgICAgdXBkYXRlczoge1xuICAgICAgICBzdG9yYWdlVXBkYXRlczogb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLFxuICAgICAgICBwcmVzZW5jZTogb3V0cHV0LnByZXNlbmNlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAoaXNBY2tPcChvcCkpIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLzpcbiAgICAgIGNhc2UgMyAvKiBVUERBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSA1IC8qIERFTEVURV9DUkRUICovOiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjb250ZXh0Lm5vZGVzLmdldChvcC5pZCk7XG4gICAgICAgIGlmIChub2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5fYXBwbHkob3AsIHNvdXJjZSA9PT0gMCAvKiBVTkRPUkVET19SRUNPTk5FQ1QgKi8pO1xuICAgICAgfVxuICAgICAgY2FzZSAxIC8qIFNFVF9QQVJFTlRfS0VZICovOiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjb250ZXh0Lm5vZGVzLmdldChvcC5pZCk7XG4gICAgICAgIGlmIChub2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIiAmJiBpc0xpdmVMaXN0KG5vZGUucGFyZW50Lm5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Lm5vZGUuX3NldENoaWxkS2V5KFxuICAgICAgICAgICAgYXNQb3Mob3AucGFyZW50S2V5KSxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBzb3VyY2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgY2FzZSA0IC8qIENSRUFURV9PQkpFQ1QgKi86XG4gICAgICBjYXNlIDIgLyogQ1JFQVRFX0xJU1QgKi86XG4gICAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86IHtcbiAgICAgICAgaWYgKG9wLnBhcmVudElkID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gY29udGV4dC5ub2Rlcy5nZXQob3AucGFyZW50SWQpO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudE5vZGUuX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVQcmVzZW5jZShwYXRjaCwgb3B0aW9uczIpIHtcbiAgICBjb25zdCBvbGRWYWx1ZXMgPSB7fTtcbiAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7XG4gICAgICAgIHR5cGU6IFwicGFydGlhbFwiLFxuICAgICAgICBkYXRhOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGF0Y2gpIHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlVmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG92ZXJyaWRlVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhW2tleV0gPSBvdmVycmlkZVZhbHVlO1xuICAgICAgb2xkVmFsdWVzW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudFtrZXldO1xuICAgIH1cbiAgICBjb250ZXh0Lm15UHJlc2VuY2UucGF0Y2gocGF0Y2gpO1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICBpZiAob3B0aW9uczI/LmFkZFRvSGlzdG9yeSkge1xuICAgICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoLnJldmVyc2VPcHMudW5zaGlmdCh7XG4gICAgICAgICAgdHlwZTogXCJwcmVzZW5jZVwiLFxuICAgICAgICAgIGRhdGE6IG9sZFZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYWN0aXZlQmF0Y2gudXBkYXRlcy5wcmVzZW5jZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICBpZiAob3B0aW9uczI/LmFkZFRvSGlzdG9yeSkge1xuICAgICAgICAgIGFkZFRvVW5kb1N0YWNrKFxuICAgICAgICAgICAgW3sgdHlwZTogXCJwcmVzZW5jZVwiLCBkYXRhOiBvbGRWYWx1ZXMgfV0sXG4gICAgICAgICAgICBkb05vdEJhdGNoVXBkYXRlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbm90aWZ5KHsgcHJlc2VuY2U6IHRydWUgfSwgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uVXBkYXRlUHJlc2VuY2VNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS50YXJnZXRBY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBvbGRVc2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICAgIGNvbnRleHQub3RoZXJzLnNldE90aGVyKG1lc3NhZ2UuYWN0b3IsIG1lc3NhZ2UuZGF0YSk7XG4gICAgICBjb25zdCBuZXdVc2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICAgIGlmIChvbGRVc2VyID09PSB2b2lkIDAgJiYgbmV3VXNlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZW50ZXJcIiwgdXNlcjogbmV3VXNlciB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0Lm90aGVycy5wYXRjaE90aGVyKG1lc3NhZ2UuYWN0b3IsIG1lc3NhZ2UuZGF0YSksIG1lc3NhZ2U7XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSBjb250ZXh0Lm90aGVycy5nZXRVc2VyKG1lc3NhZ2UuYWN0b3IpO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxuICAgICAgICB1cGRhdGVzOiBtZXNzYWdlLmRhdGEsXG4gICAgICAgIHVzZXJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uVXNlckxlZnRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgY29udGV4dC5vdGhlcnMucmVtb3ZlQ29ubmVjdGlvbihtZXNzYWdlLmFjdG9yKTtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibGVhdmVcIiwgdXNlciB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBvblJvb21TdGF0ZU1lc3NhZ2UobWVzc2FnZSwgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm8uc2V0KHtcbiAgICAgIGFjdG9yOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgbm9uY2U6IG1lc3NhZ2Uubm9uY2UsXG4gICAgICBzY29wZXM6IG1lc3NhZ2Uuc2NvcGVzXG4gICAgfSk7XG4gICAgY29udGV4dC5pZEZhY3RvcnkgPSBtYWtlSWRGYWN0b3J5KG1lc3NhZ2UuYWN0b3IpO1xuICAgIG5vdGlmeVNlbGZDaGFuZ2VkKGJhdGNoZWRVcGRhdGVzV3JhcHBlcik7XG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uSWQgb2YgY29udGV4dC5vdGhlcnMuY29ubmVjdGlvbklkcygpKSB7XG4gICAgICBjb25zdCB1c2VyID0gbWVzc2FnZS51c2Vyc1tjb25uZWN0aW9uSWRdO1xuICAgICAgaWYgKHVzZXIgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250ZXh0Lm90aGVycy5yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG1lc3NhZ2UudXNlcnMpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLnVzZXJzW2tleV07XG4gICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSBOdW1iZXIoa2V5KTtcbiAgICAgIGNvbnRleHQub3RoZXJzLnNldENvbm5lY3Rpb24oXG4gICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgdXNlci5pZCxcbiAgICAgICAgdXNlci5pbmZvLFxuICAgICAgICB1c2VyLnNjb3Blc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJyZXNldFwiIH07XG4gIH1cbiAgZnVuY3Rpb24gY2FuVW5kbygpIHtcbiAgICByZXR1cm4gY29udGV4dC51bmRvU3RhY2subGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBjYW5SZWRvKCkge1xuICAgIHJldHVybiBjb250ZXh0LnJlZG9TdGFjay5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIG9uSGlzdG9yeUNoYW5nZShiYXRjaGVkVXBkYXRlc1dyYXBwZXIpIHtcbiAgICBiYXRjaGVkVXBkYXRlc1dyYXBwZXIoKCkgPT4ge1xuICAgICAgZXZlbnRIdWIuaGlzdG9yeS5ub3RpZnkoeyBjYW5VbmRvOiBjYW5VbmRvKCksIGNhblJlZG86IGNhblJlZG8oKSB9KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBvblVzZXJKb2luZWRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb250ZXh0Lm90aGVycy5zZXRDb25uZWN0aW9uKFxuICAgICAgbWVzc2FnZS5hY3RvcixcbiAgICAgIG1lc3NhZ2UuaWQsXG4gICAgICBtZXNzYWdlLmluZm8sXG4gICAgICBtZXNzYWdlLnNjb3Blc1xuICAgICk7XG4gICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgZGF0YTogY29udGV4dC5teVByZXNlbmNlLmN1cnJlbnQsXG4gICAgICB0YXJnZXRBY3RvcjogbWVzc2FnZS5hY3RvclxuICAgIH0pO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgcmV0dXJuIHVzZXIgPyB7IHR5cGU6IFwiZW50ZXJcIiwgdXNlciB9IDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2VydmVyTWVzc2FnZShkYXRhKSB7XG4gICAgaWYgKCFpc0pzb25PYmplY3QoZGF0YSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVNlcnZlck1lc3NhZ2VzKHRleHQpIHtcbiAgICBjb25zdCBkYXRhID0gdHJ5UGFyc2VKc29uKHRleHQpO1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoaXNKc29uQXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybiBjb21wYWN0KGRhdGEubWFwKChpdGVtKSA9PiBwYXJzZVNlcnZlck1lc3NhZ2UoaXRlbSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbXBhY3QoW3BhcnNlU2VydmVyTWVzc2FnZShkYXRhKV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhcHBseUFuZFNlbmRPcHMob2ZmbGluZU9wcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKSB7XG4gICAgaWYgKG9mZmxpbmVPcHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGNvbnN0IG9wcyA9IEFycmF5LmZyb20ob2ZmbGluZU9wcy52YWx1ZXMoKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMob3BzLCB0cnVlKTtcbiAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLyxcbiAgICAgIG9wczogcmVzdWx0Lm9wc1xuICAgIH0pO1xuICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgYmF0Y2hlZFVwZGF0ZXNXcmFwcGVyKTtcbiAgICBzZW5kTWVzc2FnZXMobWVzc2FnZXMpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVNlcnZlck1lc3NhZ2UoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBwYXJzZVNlcnZlck1lc3NhZ2VzKGV2ZW50LmRhdGEpO1xuICAgIGlmIChtZXNzYWdlcyA9PT0gbnVsbCB8fCBtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlcyA9IHtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgb3RoZXJzOiBbXVxuICAgIH07XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgIGNhc2UgMTAxIC8qIFVTRVJfSk9JTkVEICovOiB7XG4gICAgICAgICAgICBjb25zdCB1c2VySm9pbmVkVXBkYXRlID0gb25Vc2VySm9pbmVkTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICh1c2VySm9pbmVkVXBkYXRlKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2godXNlckpvaW5lZFVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovOiB7XG4gICAgICAgICAgICBjb25zdCBvdGhlcnNQcmVzZW5jZVVwZGF0ZSA9IG9uVXBkYXRlUHJlc2VuY2VNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG90aGVyc1ByZXNlbmNlVXBkYXRlKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2gob3RoZXJzUHJlc2VuY2VVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTAzIC8qIEJST0FEQ0FTVEVEX0VWRU5UICovOiB7XG4gICAgICAgICAgICBjb25zdCBvdGhlcnMgPSBjb250ZXh0Lm90aGVycy5jdXJyZW50O1xuICAgICAgICAgICAgZXZlbnRIdWIuY3VzdG9tRXZlbnQubm90aWZ5KHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgICAgICAgICB1c2VyOiBtZXNzYWdlLmFjdG9yIDwgMCA/IG51bGwgOiBvdGhlcnMuZmluZCgodSkgPT4gdS5jb25uZWN0aW9uSWQgPT09IG1lc3NhZ2UuYWN0b3IpID8/IG51bGwsXG4gICAgICAgICAgICAgIGV2ZW50OiBtZXNzYWdlLmV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwMiAvKiBVU0VSX0xFRlQgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50MiA9IG9uVXNlckxlZnRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKGV2ZW50Mikge1xuICAgICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKGV2ZW50Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAzMDAgLyogVVBEQVRFX1lET0MgKi86IHtcbiAgICAgICAgICAgIGV2ZW50SHViLnlkb2Mubm90aWZ5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTA0IC8qIFJPT01fU1RBVEUgKi86IHtcbiAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2gob25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UsIGRvTm90QmF0Y2hVcGRhdGVzKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMDAgLyogSU5JVElBTF9TVE9SQUdFX1NUQVRFICovOiB7XG4gICAgICAgICAgICBwcm9jZXNzSW5pdGlhbFN0b3JhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IGFwcGx5UmVzdWx0ID0gYXBwbHlPcHMobWVzc2FnZS5vcHMsIGZhbHNlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFwcGx5UmVzdWx0LnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgdXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIG1lcmdlU3RvcmFnZVVwZGF0ZXModXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5nZXQoa2V5KSwgdmFsdWUpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAyOTkgLyogUkVKRUNUX1NUT1JBR0VfT1AgKi86IHtcbiAgICAgICAgICAgIGVycm9yV2l0aFRpdGxlKFxuICAgICAgICAgICAgICBcIlN0b3JhZ2UgbXV0YXRpb24gcmVqZWN0aW9uIGVycm9yXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2UucmVhc29uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICBjb25zdCB0cmFjZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9wSWQgb2YgbWVzc2FnZS5vcElkcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNlID0gY29udGV4dC5vcFN0YWNrVHJhY2VzPy5nZXQob3BJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNlKSB7XG4gICAgICAgICAgICAgICAgICB0cmFjZXMuYWRkKHRyYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRyYWNlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIHdhcm5XaXRoVGl0bGUoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gY2FsbHMgY2F1c2VkIHRoZSByZWplY3RlZCBzdG9yYWdlIG11dGF0aW9uczpcIixcbiAgICAgICAgICAgICAgICAgIGBcblxuJHtBcnJheS5mcm9tKHRyYWNlcykuam9pbihcIlxcblxcblwiKX1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYFN0b3JhZ2UgbXV0YXRpb25zIHJlamVjdGVkIGJ5IHNlcnZlcjogJHttZXNzYWdlLnJlYXNvbn1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA0MDAgLyogVEhSRUFEX0NSRUFURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDEgLyogVEhSRUFEX01FVEFEQVRBX1VQREFURUQgKi86XG4gICAgICAgICAgY2FzZSA0MDUgLyogQ09NTUVOVF9SRUFDVElPTl9BRERFRCAqLzpcbiAgICAgICAgICBjYXNlIDQwNiAvKiBDT01NRU5UX1JFQUNUSU9OX1JFTU9WRUQgKi86XG4gICAgICAgICAgY2FzZSA0MDIgLyogQ09NTUVOVF9DUkVBVEVEICovOlxuICAgICAgICAgIGNhc2UgNDAzIC8qIENPTU1FTlRfRURJVEVEICovOlxuICAgICAgICAgIGNhc2UgNDA0IC8qIENPTU1FTlRfREVMRVRFRCAqLzoge1xuICAgICAgICAgICAgZXZlbnRIdWIuY29tbWVudHMubm90aWZ5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub3RpZnkodXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZsdXNoTm93T3JTb29uKCkge1xuICAgIGNvbnN0IHN0b3JhZ2VPcHMgPSBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucztcbiAgICBpZiAoc3RvcmFnZU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IG9wIG9mIHN0b3JhZ2VPcHMpIHtcbiAgICAgICAgY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5zZXQobm4ob3Aub3BJZCksIG9wKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9XG4gICAgaWYgKG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCkgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zID0gW107XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZE1pbGxpcyA9IG5vdyAtIGNvbnRleHQuYnVmZmVyLmxhc3RGbHVzaGVkQXQ7XG4gICAgaWYgKGVsYXBzZWRNaWxsaXMgPj0gY29uZmlnLnRocm90dGxlRGVsYXkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzVG9GbHVzaCA9IHNlcmlhbGl6ZUJ1ZmZlcigpO1xuICAgICAgaWYgKG1lc3NhZ2VzVG9GbHVzaC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VuZE1lc3NhZ2VzKG1lc3NhZ2VzVG9GbHVzaCk7XG4gICAgICBjb250ZXh0LmJ1ZmZlciA9IHtcbiAgICAgICAgZmx1c2hUaW1lcklEOiB2b2lkIDAsXG4gICAgICAgIGxhc3RGbHVzaGVkQXQ6IG5vdyxcbiAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICBzdG9yYWdlT3BlcmF0aW9uczogW10sXG4gICAgICAgIHByZXNlbmNlVXBkYXRlczogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5mbHVzaFRpbWVySUQgPSBzZXRUaW1lb3V0KFxuICAgICAgICBmbHVzaE5vd09yU29vbixcbiAgICAgICAgY29uZmlnLnRocm90dGxlRGVsYXkgLSBlbGFwc2VkTWlsbGlzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXJpYWxpemVCdWZmZXIoKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKFxuICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMudHlwZSA9PT0gXCJmdWxsXCIgPyB7XG4gICAgICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgICAgICAvLyBQb3B1bGF0aW5nIHRoZSBgdGFyZ2V0QWN0b3JgIGZpZWxkIHR1cm5zIHRoaXMgbWVzc2FnZSBpbnRvXG4gICAgICAgICAgLy8gYSBGdWxsIFByZXNlbmNl4oSiIHVwZGF0ZSBtZXNzYWdlIChub3QgYSBwYXRjaCksIHdoaWNoIHdpbGwgZ2V0XG4gICAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYnkgb3RoZXIgY2xpZW50cyBhcyBzdWNoLlxuICAgICAgICAgIHRhcmdldEFjdG9yOiAtMSxcbiAgICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVxuICAgICAgICB9IDoge1xuICAgICAgICAgIHR5cGU6IDEwMCAvKiBVUERBVEVfUFJFU0VOQ0UgKi8sXG4gICAgICAgICAgZGF0YTogY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzLmRhdGFcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcykge1xuICAgICAgbWVzc2FnZXMucHVzaChldmVudCk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogMjAxIC8qIFVQREFURV9TVE9SQUdFICovLFxuICAgICAgICBvcHM6IGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVlEb2ModXBkYXRlLCBndWlkKSB7XG4gICAgY29uc3QgY2xpZW50TXNnID0ge1xuICAgICAgdHlwZTogMzAxIC8qIFVQREFURV9ZRE9DICovLFxuICAgICAgdXBkYXRlLFxuICAgICAgZ3VpZFxuICAgIH07XG4gICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaChjbGllbnRNc2cpO1xuICAgIGV2ZW50SHViLnlkb2Mubm90aWZ5KGNsaWVudE1zZyk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBicm9hZGNhc3RFdmVudChldmVudCwgb3B0aW9uczIgPSB7XG4gICAgc2hvdWxkUXVldWVFdmVudElmTm90UmVhZHk6IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAobWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSAhPT0gXCJjb25uZWN0ZWRcIiAmJiAhb3B0aW9uczIuc2hvdWxkUXVldWVFdmVudElmTm90UmVhZHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5idWZmZXIubWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAxMDMgLyogQlJPQURDQVNUX0VWRU5UICovLFxuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoT3BzKG9wcykge1xuICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLnB1c2goLi4ub3BzKTtcbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGxldCBfZ2V0U3RvcmFnZSQgPSBudWxsO1xuICBsZXQgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZSA9IG51bGw7XG4gIGZ1bmN0aW9uIHByb2Nlc3NJbml0aWFsU3RvcmFnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdW5hY2tub3dsZWRnZWRPcHMgPSBuZXcgTWFwKGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMpO1xuICAgIGNyZWF0ZU9yVXBkYXRlUm9vdEZyb21NZXNzYWdlKG1lc3NhZ2UsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICBhcHBseUFuZFNlbmRPcHModW5hY2tub3dsZWRnZWRPcHMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlPy4oKTtcbiAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgZXZlbnRIdWIuc3RvcmFnZURpZExvYWQubm90aWZ5KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RyZWFtU3RvcmFnZSgpIHtcbiAgICBpZiAoIW1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0cmVhbUZldGNoKG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlLCBjb25maWcucm9vbUlkKTtcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgcHJvY2Vzc0luaXRpYWxTdG9yYWdlKHsgdHlwZTogMjAwIC8qIElOSVRJQUxfU1RPUkFHRV9TVEFURSAqLywgaXRlbXMgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaFN0b3JhZ2Uob3B0aW9uczIpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzO1xuICAgIGlmIChjb25maWcudW5zdGFibGVfc3RyZWFtRGF0YSkge1xuICAgICAgdm9pZCBzdHJlYW1TdG9yYWdlKCk7XG4gICAgfSBlbHNlIGlmICghbWVzc2FnZXMuc29tZSgobXNnKSA9PiBtc2cudHlwZSA9PT0gMjAwIC8qIEZFVENIX1NUT1JBR0UgKi8pKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKHsgdHlwZTogMjAwIC8qIEZFVENIX1NUT1JBR0UgKi8gfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zMi5mbHVzaCkge1xuICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRMb2FkaW5nU3RvcmFnZSgpIHtcbiAgICBpZiAoX2dldFN0b3JhZ2UkID09PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiB0cnVlIH0pO1xuICAgICAgX2dldFN0b3JhZ2UkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlJDtcbiAgfVxuICBmdW5jdGlvbiBnZXRTdG9yYWdlU25hcHNob3QoKSB7XG4gICAgY29uc3Qgcm9vdCA9IGNvbnRleHQucm9vdDtcbiAgICBpZiAocm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdm9pZCBzdGFydExvYWRpbmdTdG9yYWdlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmFnZSgpIHtcbiAgICBpZiAoY29udGV4dC5yb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICByb290OiBjb250ZXh0LnJvb3RcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBzdGFydExvYWRpbmdTdG9yYWdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IG5uKGNvbnRleHQucm9vdClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZldGNoWURvYyh2ZWN0b3IsIGd1aWQpIHtcbiAgICBpZiAoIWNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLmZpbmQoKG0pID0+IHtcbiAgICAgIHJldHVybiBtLnR5cGUgPT09IDMwMCAvKiBGRVRDSF9ZRE9DICovICYmIG0udmVjdG9yID09PSB2ZWN0b3IgJiYgbS5ndWlkID09PSBndWlkO1xuICAgIH0pKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5tZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogMzAwIC8qIEZFVENIX1lET0MgKi8sXG4gICAgICAgIHZlY3RvcixcbiAgICAgICAgZ3VpZFxuICAgICAgfSk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gdW5kbygpIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5kbyBpcyBub3QgYWxsb3dlZCBkdXJpbmcgYSBiYXRjaFwiKTtcbiAgICB9XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQudW5kb1N0YWNrLnBvcCgpO1xuICAgIGlmIChoaXN0b3J5T3BzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhoaXN0b3J5T3BzLCB0cnVlKTtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgbm90aWZ5KHJlc3VsdC51cGRhdGVzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICBjb250ZXh0LnJlZG9TdGFjay5wdXNoKHJlc3VsdC5yZXZlcnNlKTtcbiAgICAgIG9uSGlzdG9yeUNoYW5nZShkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcCBvZiByZXN1bHQub3BzKSB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLnB1c2gob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIHJlZG8oKSB7XG4gICAgaWYgKGNvbnRleHQuYWN0aXZlQmF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJlZG8gaXMgbm90IGFsbG93ZWQgZHVyaW5nIGEgYmF0Y2hcIik7XG4gICAgfVxuICAgIGNvbnN0IGhpc3RvcnlPcHMgPSBjb250ZXh0LnJlZG9TdGFjay5wb3AoKTtcbiAgICBpZiAoaGlzdG9yeU9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwbHlPcHMoaGlzdG9yeU9wcywgdHJ1ZSk7XG4gICAgYmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcywgZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgICAgY29udGV4dC51bmRvU3RhY2sucHVzaChyZXN1bHQucmV2ZXJzZSk7XG4gICAgICBvbkhpc3RvcnlDaGFuZ2UoZG9Ob3RCYXRjaFVwZGF0ZXMpO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPSAwO1xuICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gYmF0Y2goY2FsbGJhY2spIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGxldCByZXR1cm5WYWx1ZSA9IHZvaWQgMDtcbiAgICBiYXRjaFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgY29udGV4dC5hY3RpdmVCYXRjaCA9IHtcbiAgICAgICAgb3BzOiBbXSxcbiAgICAgICAgdXBkYXRlczoge1xuICAgICAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICAgIHByZXNlbmNlOiBmYWxzZSxcbiAgICAgICAgICBvdGhlcnM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2VPcHM6IFtdXG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29uc3QgY3VycmVudEJhdGNoID0gY29udGV4dC5hY3RpdmVCYXRjaDtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaCA9IG51bGw7XG4gICAgICAgIGlmIChjdXJyZW50QmF0Y2gucmV2ZXJzZU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYWRkVG9VbmRvU3RhY2soY3VycmVudEJhdGNoLnJldmVyc2VPcHMsIGRvTm90QmF0Y2hVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEJhdGNoLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEJhdGNoLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGlzcGF0Y2hPcHMoY3VycmVudEJhdGNoLm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgbm90aWZ5KGN1cnJlbnRCYXRjaC51cGRhdGVzLCBkb05vdEJhdGNoVXBkYXRlcyk7XG4gICAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHBhdXNlSGlzdG9yeSgpIHtcbiAgICBpZiAoY29udGV4dC5wYXVzZWRIaXN0b3J5ID09PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBbXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVzdW1lSGlzdG9yeSgpIHtcbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC5wYXVzZWRIaXN0b3J5O1xuICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeSA9IG51bGw7XG4gICAgaWYgKGhpc3RvcnlPcHMgIT09IG51bGwgJiYgaGlzdG9yeU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICBfYWRkVG9SZWFsVW5kb1N0YWNrKGhpc3RvcnlPcHMsIGJhdGNoVXBkYXRlcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFN0b3JhZ2VTdGF0dXMoKSB7XG4gICAgaWYgKGNvbnRleHQucm9vdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gX2dldFN0b3JhZ2UkID09PSBudWxsID8gXCJub3QtbG9hZGVkXCIgOiBcImxvYWRpbmdcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbnRleHQudW5hY2tub3dsZWRnZWRPcHMuc2l6ZSA9PT0gMCA/IFwic3luY2hyb25pemVkXCIgOiBcInN5bmNocm9uaXppbmdcIjtcbiAgICB9XG4gIH1cbiAgbGV0IF9sYXN0U3RvcmFnZVN0YXR1cyA9IGdldFN0b3JhZ2VTdGF0dXMoKTtcbiAgZnVuY3Rpb24gbm90aWZ5U3RvcmFnZVN0YXR1cygpIHtcbiAgICBjb25zdCBzdG9yYWdlU3RhdHVzID0gZ2V0U3RvcmFnZVN0YXR1cygpO1xuICAgIGlmIChfbGFzdFN0b3JhZ2VTdGF0dXMgIT09IHN0b3JhZ2VTdGF0dXMpIHtcbiAgICAgIF9sYXN0U3RvcmFnZVN0YXR1cyA9IHN0b3JhZ2VTdGF0dXM7XG4gICAgICBldmVudEh1Yi5zdG9yYWdlU3RhdHVzLm5vdGlmeShzdG9yYWdlU3RhdHVzKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb3RoZXJzX2ZvckRldlRvb2xzID0gbmV3IERlcml2ZWRSZWYoXG4gICAgY29udGV4dC5vdGhlcnMsXG4gICAgKG90aGVycykgPT4gb3RoZXJzLm1hcCgob3RoZXIsIGluZGV4KSA9PiB1c2VyVG9UcmVlTm9kZShgT3RoZXIgJHtpbmRleH1gLCBvdGhlcikpXG4gICk7XG4gIGNvbnN0IGV2ZW50cyA9IHtcbiAgICBzdGF0dXM6IGV2ZW50SHViLnN0YXR1cy5vYnNlcnZhYmxlLFxuICAgIGxvc3RDb25uZWN0aW9uOiBldmVudEh1Yi5sb3N0Q29ubmVjdGlvbi5vYnNlcnZhYmxlLFxuICAgIGN1c3RvbUV2ZW50OiBldmVudEh1Yi5jdXN0b21FdmVudC5vYnNlcnZhYmxlLFxuICAgIG90aGVyczogZXZlbnRIdWIub3RoZXJzLm9ic2VydmFibGUsXG4gICAgc2VsZjogZXZlbnRIdWIuc2VsZi5vYnNlcnZhYmxlLFxuICAgIG15UHJlc2VuY2U6IGV2ZW50SHViLm15UHJlc2VuY2Uub2JzZXJ2YWJsZSxcbiAgICBlcnJvcjogZXZlbnRIdWIuZXJyb3Iub2JzZXJ2YWJsZSxcbiAgICBzdG9yYWdlOiBldmVudEh1Yi5zdG9yYWdlLm9ic2VydmFibGUsXG4gICAgaGlzdG9yeTogZXZlbnRIdWIuaGlzdG9yeS5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VEaWRMb2FkOiBldmVudEh1Yi5zdG9yYWdlRGlkTG9hZC5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VTdGF0dXM6IGV2ZW50SHViLnN0b3JhZ2VTdGF0dXMub2JzZXJ2YWJsZSxcbiAgICB5ZG9jOiBldmVudEh1Yi55ZG9jLm9ic2VydmFibGUsXG4gICAgY29tbWVudHM6IGV2ZW50SHViLmNvbW1lbnRzLm9ic2VydmFibGVcbiAgfTtcbiAgY29uc3QgY29tbWVudHNBcGkgPSBjcmVhdGVDb21tZW50c0FwaShcbiAgICBjb25maWcucm9vbUlkLFxuICAgIGRlbGVnYXRlcy5hdXRoZW50aWNhdGUsXG4gICAgZmV0Y2hDbGllbnRBcGlcbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hOb3RpZmljYXRpb25zSnNvbihlbmRwb2ludCwgb3B0aW9uczIpIHtcbiAgICBjb25zdCBhdXRoVmFsdWUgPSBhd2FpdCBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENsaWVudEFwaShcbiAgICAgIGNvbmZpZy5yb29tSWQsXG4gICAgICBlbmRwb2ludCxcbiAgICAgIGF1dGhWYWx1ZSxcbiAgICAgIG9wdGlvbnMyXG4gICAgKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgbGV0IGVycm9yMztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIGVycm9yQm9keS5tZXNzYWdlLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3JCb2R5XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3IzID0gbmV3IE5vdGlmaWNhdGlvbnNBcGlFcnJvcihcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgdHJ5IHtcbiAgICAgIGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBib2R5ID0ge307XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGZ1bmN0aW9uIGdldFJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpIHtcbiAgICByZXR1cm4gZmV0Y2hOb3RpZmljYXRpb25zSnNvbihcbiAgICAgIFwiL25vdGlmaWNhdGlvbi1zZXR0aW5nc1wiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gZmV0Y2hOb3RpZmljYXRpb25zSnNvbihcbiAgICAgIFwiL25vdGlmaWNhdGlvbi1zZXR0aW5nc1wiLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShzZXR0aW5ncyksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKSB7XG4gICAgYXdhaXQgZmV0Y2hOb3RpZmljYXRpb25zSnNvbihcIi9pbmJveC1ub3RpZmljYXRpb25zL3JlYWRcIiwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGluYm94Tm90aWZpY2F0aW9uSWRzIH0pXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYmF0Y2hlZE1hcmtJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQgPSBuZXcgQmF0Y2goXG4gICAgYXN5bmMgKGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcykgPT4ge1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb25JZHMgPSBiYXRjaGVkSW5ib3hOb3RpZmljYXRpb25JZHMuZmxhdCgpO1xuICAgICAgYXdhaXQgbWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkcyk7XG4gICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25JZHM7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBNQVJLX0lOQk9YX05PVElGSUNBVElPTlNfQVNfUkVBRF9CQVRDSF9ERUxBWTIgfVxuICApO1xuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICAgIGF3YWl0IGJhdGNoZWRNYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLmdldChpbmJveE5vdGlmaWNhdGlvbklkKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIFtrSW50ZXJuYWxdOiB7XG4gICAgICAgIGdldCBwcmVzZW5jZUJ1ZmZlcigpIHtcbiAgICAgICAgICByZXR1cm4gZGVlcENsb25lKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcz8uZGF0YSA/PyBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGdldCB1bmRvU3RhY2soKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZXBDbG9uZShjb250ZXh0LnVuZG9TdGFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBnZXQgbm9kZUNvdW50KCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Lm5vZGVzLnNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAvLyBTdXBwb3J0IGZvciB0aGUgTGl2ZWJsb2NrcyBicm93c2VyIGV4dGVuc2lvblxuICAgICAgICBnZXRTZWxmX2ZvckRldlRvb2xzOiAoKSA9PiBzZWxmQXNUcmVlTm9kZS5jdXJyZW50LFxuICAgICAgICBnZXRPdGhlcnNfZm9yRGV2VG9vbHM6ICgpID0+IG90aGVyc19mb3JEZXZUb29scy5jdXJyZW50LFxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgc2ltdWxhdGU6IHtcbiAgICAgICAgICAvLyBUaGVzZSBleGlzdCBvbmx5IGZvciBvdXIgRTJFIHRlc3RpbmcgYXBwXG4gICAgICAgICAgZXhwbGljaXRDbG9zZTogKGV2ZW50KSA9PiBtYW5hZ2VkU29ja2V0Ll9wcml2YXRlU2VuZE1hY2hpbmVFdmVudCh7IHR5cGU6IFwiRVhQTElDSVRfU09DS0VUX0NMT1NFXCIsIGV2ZW50IH0pLFxuICAgICAgICAgIHJhd1NlbmQ6IChkYXRhKSA9PiBtYW5hZ2VkU29ja2V0LnNlbmQoZGF0YSlcbiAgICAgICAgfSxcbiAgICAgICAgY29tbWVudHM6IHtcbiAgICAgICAgICAuLi5jb21tZW50c0FwaVxuICAgICAgICB9LFxuICAgICAgICBub3RpZmljYXRpb25zOiB7XG4gICAgICAgICAgZ2V0Um9vbU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgICAgIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICAgICAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlkOiBjb25maWcucm9vbUlkLFxuICAgICAgc3Vic2NyaWJlOiBtYWtlQ2xhc3NpY1N1YnNjcmliZUZuKGV2ZW50cyksXG4gICAgICBjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LmNvbm5lY3QoKSxcbiAgICAgIHJlY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKSxcbiAgICAgIGRpc2Nvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQuZGlzY29ubmVjdCgpLFxuICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICB1bmluc3RhbGxCZ1RhYlNweSgpO1xuICAgICAgICBtYW5hZ2VkU29ja2V0LmRlc3Ryb3koKTtcbiAgICAgIH0sXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgdXBkYXRlUHJlc2VuY2UsXG4gICAgICB1cGRhdGVZRG9jLFxuICAgICAgYnJvYWRjYXN0RXZlbnQsXG4gICAgICAvLyBTdG9yYWdlXG4gICAgICBiYXRjaCxcbiAgICAgIGhpc3Rvcnk6IHtcbiAgICAgICAgdW5kbyxcbiAgICAgICAgcmVkbyxcbiAgICAgICAgY2FuVW5kbyxcbiAgICAgICAgY2FuUmVkbyxcbiAgICAgICAgY2xlYXIsXG4gICAgICAgIHBhdXNlOiBwYXVzZUhpc3RvcnksXG4gICAgICAgIHJlc3VtZTogcmVzdW1lSGlzdG9yeVxuICAgICAgfSxcbiAgICAgIGZldGNoWURvYyxcbiAgICAgIGdldFN0b3JhZ2UsXG4gICAgICBnZXRTdG9yYWdlU25hcHNob3QsXG4gICAgICBnZXRTdG9yYWdlU3RhdHVzLFxuICAgICAgZXZlbnRzLFxuICAgICAgLy8gQ29yZVxuICAgICAgZ2V0U3RhdHVzOiAoKSA9PiBtYW5hZ2VkU29ja2V0LmdldFN0YXR1cygpLFxuICAgICAgZ2V0Q29ubmVjdGlvblN0YXRlOiAoKSA9PiBtYW5hZ2VkU29ja2V0LmdldExlZ2FjeVN0YXR1cygpLFxuICAgICAgZ2V0U2VsZjogKCkgPT4gc2VsZi5jdXJyZW50LFxuICAgICAgLy8gUHJlc2VuY2VcbiAgICAgIGdldFByZXNlbmNlOiAoKSA9PiBjb250ZXh0Lm15UHJlc2VuY2UuY3VycmVudCxcbiAgICAgIGdldE90aGVyczogKCkgPT4gY29udGV4dC5vdGhlcnMuY3VycmVudFxuICAgIH0sXG4gICAgLy8gRXhwbGljdGx5IG1ha2UgdGhlIGludGVybmFsIGZpZWxkIG5vbi1lbnVtZXJhYmxlLCB0byBhdm9pZCBhZ2dyZXNzaXZlXG4gICAgLy8gZnJlZXppbmcgd2hlbiB1c2VkIHdpdGggSW1tZXJcbiAgICBrSW50ZXJuYWwsXG4gICAgeyBlbnVtZXJhYmxlOiBmYWxzZSB9XG4gICk7XG59XG5mdW5jdGlvbiBtYWtlQ2xhc3NpY1N1YnNjcmliZUZuKGV2ZW50cykge1xuICBmdW5jdGlvbiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVEZWVwbHkobm9kZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2Uuc3Vic2NyaWJlKCh1cGRhdGVzKSA9PiB7XG4gICAgICBjb25zdCByZWxhdGVkVXBkYXRlcyA9IHVwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAodXBkYXRlKSA9PiBpc1NhbWVOb2RlT3JDaGlsZE9mKHVwZGF0ZS5ub2RlLCBub2RlKVxuICAgICAgKTtcbiAgICAgIGlmIChyZWxhdGVkVXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlbGF0ZWRVcGRhdGVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVTaGFsbG93bHkobm9kZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2Uuc3Vic2NyaWJlKCh1cGRhdGVzKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICAgIGlmICh1cGRhdGUubm9kZS5faWQgPT09IG5vZGUuX2lkKSB7XG4gICAgICAgICAgY2FsbGJhY2sodXBkYXRlLm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZpcnN0LCBzZWNvbmQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGZpcnN0ID09PSBcInN0cmluZ1wiICYmIGlzUm9vbUV2ZW50TmFtZShmaXJzdCkpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBjYWxsYmFjayBmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgc3dpdGNoIChmaXJzdCkge1xuICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm15LXByZXNlbmNlXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5teVByZXNlbmNlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJvdGhlcnNcIjoge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2s7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvdGhlcnMsIC4uLmludGVybmFsRXZlbnQgfSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIGNiKG90aGVycywgaW50ZXJuYWxFdmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5lcnJvci5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwiY29ubmVjdGlvblwiOiB7XG4gICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoXG4gICAgICAgICAgICAoc3RhdHVzKSA9PiBjYihuZXdUb0xlZ2FjeVN0YXR1cyhzdGF0dXMpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInN0YXR1c1wiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuc3RhdHVzLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIGNhc2UgXCJsb3N0LWNvbm5lY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmxvc3RDb25uZWN0aW9uLnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcImhpc3RvcnlcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmhpc3Rvcnkuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcInN0b3JhZ2Utc3RhdHVzXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlU3RhdHVzLnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoXG4gICAgICAgICAgICBmaXJzdCxcbiAgICAgICAgICAgIGBcIiR7U3RyaW5nKGZpcnN0KX1cIiBpcyBub3QgYSB2YWxpZCBldmVudCBuYW1lYFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWNvbmQgPT09IHZvaWQgMCB8fCB0eXBlb2YgZmlyc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDYWxsYmFjayA9IGZpcnN0O1xuICAgICAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2Uuc3Vic2NyaWJlKHN0b3JhZ2VDYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc3BlY2lmeSBhIGxpc3RlbmVyIGNhbGxiYWNrXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNMaXZlTm9kZShmaXJzdCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBmaXJzdDtcbiAgICAgIGlmIChvcHRpb25zPy5pc0RlZXApIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNhbGxiYWNrID0gc2Vjb25kO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlRGVlcGx5KG5vZGUsIHN0b3JhZ2VDYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlQ2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVTaGFsbG93bHkobm9kZSwgbm9kZUNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCR7U3RyaW5nKGZpcnN0KX0gaXMgbm90IGEgdmFsdWUgdGhhdCBjYW4gYmUgc3Vic2NyaWJlZCB0by5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc3Vic2NyaWJlO1xufVxuZnVuY3Rpb24gaXNSb29tRXZlbnROYW1lKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gXCJteS1wcmVzZW5jZVwiIHx8IHZhbHVlID09PSBcIm90aGVyc1wiIHx8IHZhbHVlID09PSBcImV2ZW50XCIgfHwgdmFsdWUgPT09IFwiZXJyb3JcIiB8fCB2YWx1ZSA9PT0gXCJoaXN0b3J5XCIgfHwgdmFsdWUgPT09IFwic3RhdHVzXCIgfHwgdmFsdWUgPT09IFwic3RvcmFnZS1zdGF0dXNcIiB8fCB2YWx1ZSA9PT0gXCJsb3N0LWNvbm5lY3Rpb25cIiB8fCB2YWx1ZSA9PT0gXCJjb25uZWN0aW9uXCI7XG59XG5mdW5jdGlvbiBtYWtlQXV0aERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGF1dGhNYW5hZ2VyKSB7XG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgcmV0dXJuIGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcInJvb206cmVhZFwiLCByb29tSWQgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tKHJvb21JZCwgYmFzZVVybCwgV2ViU29ja2V0UG9seWZpbGwpIHtcbiAgcmV0dXJuIChhdXRoVmFsdWUpID0+IHtcbiAgICBjb25zdCB3cyA9IFdlYlNvY2tldFBvbHlmaWxsID8/ICh0eXBlb2YgV2ViU29ja2V0ID09PSBcInVuZGVmaW5lZFwiID8gdm9pZCAwIDogV2ViU29ja2V0KTtcbiAgICBpZiAod3MgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgXCJUbyB1c2UgTGl2ZWJsb2NrcyBjbGllbnQgaW4gYSBub24tRE9NIGVudmlyb25tZW50LCB5b3UgbmVlZCB0byBwcm92aWRlIGEgV2ViU29ja2V0IHBvbHlmaWxsLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgIHVybC5wcm90b2NvbCA9IHVybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiID8gXCJ3c1wiIDogXCJ3c3NcIjtcbiAgICB1cmwucGF0aG5hbWUgPSBcIi92N1wiO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwicm9vbUlkXCIsIHJvb21JZCk7XG4gICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInRva1wiLCBhdXRoVmFsdWUudG9rZW4ucmF3KTtcbiAgICB9IGVsc2UgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInB1YmtleVwiLCBhdXRoVmFsdWUucHVibGljQXBpS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKGF1dGhWYWx1ZSwgXCJVbmhhbmRsZWQgY2FzZVwiKTtcbiAgICB9XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ2ZXJzaW9uXCIsIFBLR19WRVJTSU9OIHx8IFwiZGV2XCIpO1xuICAgIHJldHVybiBuZXcgd3ModXJsLnRvU3RyaW5nKCkpO1xuICB9O1xufVxuXG4vLyBzcmMvc3RvcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFN0b3JlKCkge1xuICBjb25zdCBzdG9yZSA9IGNyZWF0ZVN0b3JlKHtcbiAgICB0aHJlYWRzOiB7fSxcbiAgICBxdWVyaWVzOiB7fSxcbiAgICBvcHRpbWlzdGljVXBkYXRlczogW10sXG4gICAgaW5ib3hOb3RpZmljYXRpb25zOiB7fSxcbiAgICBub3RpZmljYXRpb25TZXR0aW5nczoge31cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uc3RvcmUsXG4gICAgZGVsZXRlVGhyZWFkKHRocmVhZElkKSB7XG4gICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgdGhyZWFkczogZGVsZXRlS2V5SW1tdXRhYmxlKHN0YXRlLnRocmVhZHMsIHRocmVhZElkKSxcbiAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHN0YXRlLmluYm94Tm90aWZpY2F0aW9ucykuZmlsdGVyKFxuICAgICAgICAgICAgICAoW19pZCwgbm90aWZpY2F0aW9uXSkgPT4gbm90aWZpY2F0aW9uLnRocmVhZElkICE9PSB0aHJlYWRJZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlVGhyZWFkQW5kTm90aWZpY2F0aW9uKHRocmVhZCwgaW5ib3hOb3RpZmljYXRpb24pIHtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSBzdGF0ZS50aHJlYWRzW3RocmVhZC5pZF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgdGhyZWFkczogZXhpc3RpbmdUaHJlYWQgPT09IHZvaWQgMCB8fCBjb21wYXJlVGhyZWFkcyh0aHJlYWQsIGV4aXN0aW5nVGhyZWFkKSA9PT0gMSA/IHsgLi4uc3RhdGUudGhyZWFkcywgW3RocmVhZC5pZF06IHRocmVhZCB9IDogc3RhdGUudGhyZWFkcyxcbiAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IGluYm94Tm90aWZpY2F0aW9uID09PSB2b2lkIDAgPyBzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMgOiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICBbaW5ib3hOb3RpZmljYXRpb24uaWRdOiBpbmJveE5vdGlmaWNhdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnModGhyZWFkcywgaW5ib3hOb3RpZmljYXRpb25zLCBkZWxldGVkVGhyZWFkcywgZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucywgcXVlcnlLZXkpIHtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICB0aHJlYWRzOiBhcHBseVRocmVhZFVwZGF0ZXMoc3RhdGUudGhyZWFkcywge1xuICAgICAgICAgIG5ld1RocmVhZHM6IHRocmVhZHMsXG4gICAgICAgICAgZGVsZXRlZFRocmVhZHNcbiAgICAgICAgfSksXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogYXBwbHlOb3RpZmljYXRpb25zVXBkYXRlcyhcbiAgICAgICAgICBzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmV3SW5ib3hOb3RpZmljYXRpb25zOiBpbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgICBkZWxldGVkTm90aWZpY2F0aW9uczogZGVsZXRlZEluYm94Tm90aWZpY2F0aW9uc1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcXVlcmllczogcXVlcnlLZXkgIT09IHZvaWQgMCA/IHtcbiAgICAgICAgICAuLi5zdGF0ZS5xdWVyaWVzLFxuICAgICAgICAgIFtxdWVyeUtleV06IHtcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0gOiBzdGF0ZS5xdWVyaWVzXG4gICAgICB9KSk7XG4gICAgfSxcbiAgICB1cGRhdGVSb29tSW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyhyb29tSWQsIHNldHRpbmdzLCBxdWVyeUtleSkge1xuICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIG5vdGlmaWNhdGlvblNldHRpbmdzOiB7XG4gICAgICAgICAgLi4uc3RhdGUubm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgICAgICAgW3Jvb21JZF06IHNldHRpbmdzXG4gICAgICAgIH0sXG4gICAgICAgIHF1ZXJpZXM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5xdWVyaWVzLFxuICAgICAgICAgIFtxdWVyeUtleV06IHtcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIHB1c2hPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGUpIHtcbiAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogWy4uLnN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLCBvcHRpbWlzdGljVXBkYXRlXVxuICAgICAgfSkpO1xuICAgIH0sXG4gICAgc2V0UXVlcnlTdGF0ZShxdWVyeUtleSwgcXVlcnlTdGF0ZSkge1xuICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHF1ZXJpZXM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5xdWVyaWVzLFxuICAgICAgICAgIFtxdWVyeUtleV06IHF1ZXJ5U3RhdGVcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUtleUltbXV0YWJsZShyZWNvcmQsIGtleSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlY29yZCwga2V5KSkge1xuICAgIGNvbnN0IHsgW2tleV06IF90b0RlbGV0ZSwgLi4ucmVzdCB9ID0gcmVjb3JkO1xuICAgIHJldHVybiByZXN0O1xuICB9XG4gIHJldHVybiByZWNvcmQ7XG59XG5mdW5jdGlvbiBjb21wYXJlVGhyZWFkcyh0aHJlYWQxLCB0aHJlYWQyKSB7XG4gIGlmICh0aHJlYWQxLnVwZGF0ZWRBdCAmJiB0aHJlYWQyLnVwZGF0ZWRBdCkge1xuICAgIHJldHVybiB0aHJlYWQxLnVwZGF0ZWRBdCA+IHRocmVhZDIudXBkYXRlZEF0ID8gMSA6IHRocmVhZDEudXBkYXRlZEF0IDwgdGhyZWFkMi51cGRhdGVkQXQgPyAtMSA6IDA7XG4gIH0gZWxzZSBpZiAodGhyZWFkMS51cGRhdGVkQXQgfHwgdGhyZWFkMi51cGRhdGVkQXQpIHtcbiAgICByZXR1cm4gdGhyZWFkMS51cGRhdGVkQXQgPyAxIDogLTE7XG4gIH1cbiAgaWYgKHRocmVhZDEuY3JlYXRlZEF0ID4gdGhyZWFkMi5jcmVhdGVkQXQpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmICh0aHJlYWQxLmNyZWF0ZWRBdCA8IHRocmVhZDIuY3JlYXRlZEF0KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gYXBwbHlPcHRpbWlzdGljVXBkYXRlcyhzdGF0ZSkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgdGhyZWFkczoge1xuICAgICAgLi4uc3RhdGUudGhyZWFkc1xuICAgIH0sXG4gICAgaW5ib3hOb3RpZmljYXRpb25zOiB7XG4gICAgICAuLi5zdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnNcbiAgICB9LFxuICAgIG5vdGlmaWNhdGlvblNldHRpbmdzOiB7XG4gICAgICAuLi5zdGF0ZS5ub3RpZmljYXRpb25TZXR0aW5nc1xuICAgIH1cbiAgfTtcbiAgZm9yIChjb25zdCBvcHRpbWlzdGljVXBkYXRlIG9mIHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzKSB7XG4gICAgc3dpdGNoIChvcHRpbWlzdGljVXBkYXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJjcmVhdGUtdGhyZWFkXCI6IHtcbiAgICAgICAgcmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWQuaWRdID0gb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImVkaXQtdGhyZWFkLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gcmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyZWFkLnVwZGF0ZWRBdCAhPT0gdm9pZCAwICYmIHRocmVhZC51cGRhdGVkQXQgPiBvcHRpbWlzdGljVXBkYXRlLnVwZGF0ZWRBdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSB7XG4gICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgIHVwZGF0ZWRBdDogb3B0aW1pc3RpY1VwZGF0ZS51cGRhdGVkQXQsXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIC4uLnRocmVhZC5tZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLm9wdGltaXN0aWNVcGRhdGUubWV0YWRhdGFcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImNyZWF0ZS1jb21tZW50XCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gcmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50LnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnRocmVhZHNbdGhyZWFkLmlkXSA9IHVwc2VydENvbW1lbnQoXG4gICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbiA9IE9iamVjdC52YWx1ZXMocmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucykuZmluZChcbiAgICAgICAgICAobm90aWZpY2F0aW9uKSA9PiBub3RpZmljYXRpb24udGhyZWFkSWQgPT09IHRocmVhZC5pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoaW5ib3hOb3RpZmljYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNbaW5ib3hOb3RpZmljYXRpb24uaWRdID0ge1xuICAgICAgICAgIC4uLmluYm94Tm90aWZpY2F0aW9uLFxuICAgICAgICAgIG5vdGlmaWVkQXQ6IG9wdGltaXN0aWNVcGRhdGUuY29tbWVudC5jcmVhdGVkQXQsXG4gICAgICAgICAgcmVhZEF0OiBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQuY3JlYXRlZEF0XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImVkaXQtY29tbWVudFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUuY29tbWVudC50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSB1cHNlcnRDb21tZW50KFxuICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGVsZXRlLWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSByZXN1bHQudGhyZWFkc1tvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkXTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnRocmVhZHNbdGhyZWFkLmlkXSA9IGRlbGV0ZUNvbW1lbnQoXG4gICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudElkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuZGVsZXRlZEF0XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImFkZC1yZWFjdGlvblwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHJlc3VsdC50aHJlYWRzW29wdGltaXN0aWNVcGRhdGUudGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudGhyZWFkc1t0aHJlYWQuaWRdID0gYWRkUmVhY3Rpb24oXG4gICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudElkLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUucmVhY3Rpb25cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwicmVtb3ZlLXJlYWN0aW9uXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gcmVzdWx0LnRocmVhZHNbb3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC50aHJlYWRzW3RocmVhZC5pZF0gPSByZW1vdmVSZWFjdGlvbihcbiAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50SWQsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5lbW9qaSxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLnVzZXJJZCxcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLnJlbW92ZWRBdFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXJrLWluYm94LW5vdGlmaWNhdGlvbi1hcy1yZWFkXCI6IHtcbiAgICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9uc1tvcHRpbWlzdGljVXBkYXRlLmluYm94Tm90aWZpY2F0aW9uSWRdID0ge1xuICAgICAgICAgIC4uLnN0YXRlLmluYm94Tm90aWZpY2F0aW9uc1tvcHRpbWlzdGljVXBkYXRlLmluYm94Tm90aWZpY2F0aW9uSWRdLFxuICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5yZWFkQXRcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay1pbmJveC1ub3RpZmljYXRpb25zLWFzLXJlYWRcIjoge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIGluIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zW2lkXSA9IHtcbiAgICAgICAgICAgIC4uLnJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNbaWRdLFxuICAgICAgICAgICAgcmVhZEF0OiBvcHRpbWlzdGljVXBkYXRlLnJlYWRBdFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidXBkYXRlLW5vdGlmaWNhdGlvbi1zZXR0aW5nc1wiOiB7XG4gICAgICAgIHJlc3VsdC5ub3RpZmljYXRpb25TZXR0aW5nc1tvcHRpbWlzdGljVXBkYXRlLnJvb21JZF0gPSB7XG4gICAgICAgICAgLi4ucmVzdWx0Lm5vdGlmaWNhdGlvblNldHRpbmdzW29wdGltaXN0aWNVcGRhdGUucm9vbUlkXSxcbiAgICAgICAgICAuLi5vcHRpbWlzdGljVXBkYXRlLnNldHRpbmdzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhcHBseVRocmVhZFVwZGF0ZXMoZXhpc3RpbmdUaHJlYWRzLCB1cGRhdGVzKSB7XG4gIGNvbnN0IHVwZGF0ZWRUaHJlYWRzID0geyAuLi5leGlzdGluZ1RocmVhZHMgfTtcbiAgdXBkYXRlcy5uZXdUaHJlYWRzLmZvckVhY2goKHRocmVhZCkgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gdXBkYXRlZFRocmVhZHNbdGhyZWFkLmlkXTtcbiAgICBpZiAoZXhpc3RpbmdUaHJlYWQpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmVUaHJlYWRzKGV4aXN0aW5nVGhyZWFkLCB0aHJlYWQpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gMSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVkVGhyZWFkc1t0aHJlYWQuaWRdID0gdGhyZWFkO1xuICB9KTtcbiAgdXBkYXRlcy5kZWxldGVkVGhyZWFkcy5mb3JFYWNoKCh7IGlkLCBkZWxldGVkQXQgfSkgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gdXBkYXRlZFRocmVhZHNbaWRdO1xuICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGV4aXN0aW5nVGhyZWFkLmRlbGV0ZWRBdCA9IGRlbGV0ZWRBdDtcbiAgICBleGlzdGluZ1RocmVhZC51cGRhdGVkQXQgPSBkZWxldGVkQXQ7XG4gICAgZXhpc3RpbmdUaHJlYWQuY29tbWVudHMgPSBbXTtcbiAgfSk7XG4gIHJldHVybiB1cGRhdGVkVGhyZWFkcztcbn1cbmZ1bmN0aW9uIGFwcGx5Tm90aWZpY2F0aW9uc1VwZGF0ZXMoZXhpc3RpbmdJbmJveE5vdGlmaWNhdGlvbnMsIHVwZGF0ZXMpIHtcbiAgY29uc3QgdXBkYXRlZEluYm94Tm90aWZpY2F0aW9ucyA9IHsgLi4uZXhpc3RpbmdJbmJveE5vdGlmaWNhdGlvbnMgfTtcbiAgdXBkYXRlcy5uZXdJbmJveE5vdGlmaWNhdGlvbnMuZm9yRWFjaCgobm90aWZpY2F0aW9uKSA9PiB7XG4gICAgY29uc3QgZXhpc3RpbmdOb3RpZmljYXRpb24gPSB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zW25vdGlmaWNhdGlvbi5pZF07XG4gICAgaWYgKGV4aXN0aW5nTm90aWZpY2F0aW9uKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJlSW5ib3hOb3RpZmljYXRpb25zKFxuICAgICAgICBleGlzdGluZ05vdGlmaWNhdGlvbixcbiAgICAgICAgbm90aWZpY2F0aW9uXG4gICAgICApO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gMSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zW25vdGlmaWNhdGlvbi5pZF0gPSBub3RpZmljYXRpb247XG4gIH0pO1xuICB1cGRhdGVzLmRlbGV0ZWROb3RpZmljYXRpb25zLmZvckVhY2goXG4gICAgKHsgaWQgfSkgPT4gZGVsZXRlIHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnNbaWRdXG4gICk7XG4gIHJldHVybiB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zO1xufVxuZnVuY3Rpb24gY29tcGFyZUluYm94Tm90aWZpY2F0aW9ucyhpbmJveE5vdGlmaWNhdGlvbkEsIGluYm94Tm90aWZpY2F0aW9uQikge1xuICBpZiAoaW5ib3hOb3RpZmljYXRpb25BLm5vdGlmaWVkQXQgPiBpbmJveE5vdGlmaWNhdGlvbkIubm90aWZpZWRBdCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5ub3RpZmllZEF0IDwgaW5ib3hOb3RpZmljYXRpb25CLm5vdGlmaWVkQXQpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgJiYgaW5ib3hOb3RpZmljYXRpb25CLnJlYWRBdCkge1xuICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0ID4gaW5ib3hOb3RpZmljYXRpb25CLnJlYWRBdCA/IDEgOiBpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0IDwgaW5ib3hOb3RpZmljYXRpb25CLnJlYWRBdCA/IC0xIDogMDtcbiAgfSBlbHNlIGlmIChpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0IHx8IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQpIHtcbiAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA/IDEgOiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHVwc2VydENvbW1lbnQodGhyZWFkLCBjb21tZW50KSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChjb21tZW50LnRocmVhZElkICE9PSB0aHJlYWQuaWQpIHtcbiAgICB3YXJuKFxuICAgICAgYENvbW1lbnQgJHtjb21tZW50LmlkfSBkb2VzIG5vdCBiZWxvbmcgdG8gdGhyZWFkICR7dGhyZWFkLmlkfWBcbiAgICApO1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGV4aXN0aW5nQ29tbWVudDIpID0+IGV4aXN0aW5nQ29tbWVudDIuaWQgPT09IGNvbW1lbnQuaWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgdXBkYXRlZEF0ID0gbmV3IERhdGUoXG4gICAgICBNYXRoLm1heCh0aHJlYWQudXBkYXRlZEF0Py5nZXRUaW1lKCkgfHwgMCwgY29tbWVudC5jcmVhdGVkQXQuZ2V0VGltZSgpKVxuICAgICk7XG4gICAgY29uc3QgdXBkYXRlZFRocmVhZCA9IHtcbiAgICAgIC4uLnRocmVhZCxcbiAgICAgIHVwZGF0ZWRBdCxcbiAgICAgIGNvbW1lbnRzOiBbLi4udGhyZWFkLmNvbW1lbnRzLCBjb21tZW50XVxuICAgIH07XG4gICAgcmV0dXJuIHVwZGF0ZWRUaHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5lZGl0ZWRBdCA9PT0gdm9pZCAwIHx8IGNvbW1lbnQuZWRpdGVkQXQgPT09IHZvaWQgMCB8fCBleGlzdGluZ0NvbW1lbnQuZWRpdGVkQXQgPD0gY29tbWVudC5lZGl0ZWRBdCkge1xuICAgIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgICAoZXhpc3RpbmdDb21tZW50MikgPT4gZXhpc3RpbmdDb21tZW50Mi5pZCA9PT0gY29tbWVudC5pZCA/IGNvbW1lbnQgOiBleGlzdGluZ0NvbW1lbnQyXG4gICAgKTtcbiAgICBjb25zdCB1cGRhdGVkVGhyZWFkID0ge1xuICAgICAgLi4udGhyZWFkLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgdGhyZWFkLnVwZGF0ZWRBdD8uZ2V0VGltZSgpIHx8IDAsXG4gICAgICAgICAgY29tbWVudC5lZGl0ZWRBdD8uZ2V0VGltZSgpIHx8IGNvbW1lbnQuY3JlYXRlZEF0LmdldFRpbWUoKVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICAgIH07XG4gICAgcmV0dXJuIHVwZGF0ZWRUaHJlYWQ7XG4gIH1cbiAgcmV0dXJuIHRocmVhZDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNvbW1lbnQodGhyZWFkLCBjb21tZW50SWQsIGRlbGV0ZWRBdCkge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCBleGlzdGluZ0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkXG4gICk7XG4gIGlmIChleGlzdGluZ0NvbW1lbnQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgdXBkYXRlZENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkID8ge1xuICAgICAgLi4uY29tbWVudCxcbiAgICAgIGRlbGV0ZWRBdCxcbiAgICAgIGJvZHk6IHZvaWQgMFxuICAgIH0gOiBjb21tZW50XG4gICk7XG4gIGlmICghdXBkYXRlZENvbW1lbnRzLnNvbWUoKGNvbW1lbnQpID0+IGNvbW1lbnQuZGVsZXRlZEF0ID09PSB2b2lkIDApKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRocmVhZCxcbiAgICAgIGRlbGV0ZWRBdCxcbiAgICAgIHVwZGF0ZWRBdDogZGVsZXRlZEF0LFxuICAgICAgY29tbWVudHM6IFtdXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnRocmVhZCxcbiAgICB1cGRhdGVkQXQ6IGRlbGV0ZWRBdCxcbiAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBhZGRSZWFjdGlvbih0aHJlYWQsIGNvbW1lbnRJZCwgcmVhY3Rpb24pIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICByZWFjdGlvbnM6IHVwc2VydFJlYWN0aW9uKGNvbW1lbnQucmVhY3Rpb25zLCByZWFjdGlvbilcbiAgICB9IDogY29tbWVudFxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLnRocmVhZCxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKFxuICAgICAgTWF0aC5tYXgocmVhY3Rpb24uY3JlYXRlZEF0LmdldFRpbWUoKSwgdGhyZWFkLnVwZGF0ZWRBdD8uZ2V0VGltZSgpIHx8IDApXG4gICAgKSxcbiAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiByZW1vdmVSZWFjdGlvbih0aHJlYWQsIGNvbW1lbnRJZCwgZW1vamksIHVzZXJJZCwgcmVtb3ZlZEF0KSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29tbWVudCA9IHRocmVhZC5jb21tZW50cy5maW5kKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCB1cGRhdGVkQ29tbWVudHMgPSB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWQgPyB7XG4gICAgICAuLi5jb21tZW50LFxuICAgICAgcmVhY3Rpb25zOiBjb21tZW50LnJlYWN0aW9ucy5tYXAoXG4gICAgICAgIChyZWFjdGlvbikgPT4gcmVhY3Rpb24uZW1vamkgPT09IGVtb2ppID8ge1xuICAgICAgICAgIC4uLnJlYWN0aW9uLFxuICAgICAgICAgIHVzZXJzOiByZWFjdGlvbi51c2Vycy5maWx0ZXIoKHVzZXIpID0+IHVzZXIuaWQgIT09IHVzZXJJZClcbiAgICAgICAgfSA6IHJlYWN0aW9uXG4gICAgICApLmZpbHRlcigocmVhY3Rpb24pID0+IHJlYWN0aW9uLnVzZXJzLmxlbmd0aCA+IDApXG4gICAgICAvLyBSZW1vdmUgcmVhY3Rpb25zIHdpdGggbm8gdXNlcnMgbGVmdFxuICAgIH0gOiBjb21tZW50XG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4udGhyZWFkLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoXG4gICAgICBNYXRoLm1heChyZW1vdmVkQXQuZ2V0VGltZSgpLCB0aHJlYWQudXBkYXRlZEF0Py5nZXRUaW1lKCkgfHwgMClcbiAgICApLFxuICAgIGNvbW1lbnRzOiB1cGRhdGVkQ29tbWVudHNcbiAgfTtcbn1cbmZ1bmN0aW9uIHVwc2VydFJlYWN0aW9uKHJlYWN0aW9ucywgcmVhY3Rpb24pIHtcbiAgY29uc3QgZXhpc3RpbmdSZWFjdGlvbiA9IHJlYWN0aW9ucy5maW5kKFxuICAgIChleGlzdGluZ1JlYWN0aW9uMikgPT4gZXhpc3RpbmdSZWFjdGlvbjIuZW1vamkgPT09IHJlYWN0aW9uLmVtb2ppXG4gICk7XG4gIGlmIChleGlzdGluZ1JlYWN0aW9uID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gW1xuICAgICAgLi4ucmVhY3Rpb25zLFxuICAgICAge1xuICAgICAgICBlbW9qaTogcmVhY3Rpb24uZW1vamksXG4gICAgICAgIGNyZWF0ZWRBdDogcmVhY3Rpb24uY3JlYXRlZEF0LFxuICAgICAgICB1c2VyczogW3sgaWQ6IHJlYWN0aW9uLnVzZXJJZCB9XVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgaWYgKGV4aXN0aW5nUmVhY3Rpb24udXNlcnMuc29tZSgodXNlcikgPT4gdXNlci5pZCA9PT0gcmVhY3Rpb24udXNlcklkKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gcmVhY3Rpb25zLm1hcChcbiAgICAgIChleGlzdGluZ1JlYWN0aW9uMikgPT4gZXhpc3RpbmdSZWFjdGlvbjIuZW1vamkgPT09IHJlYWN0aW9uLmVtb2ppID8ge1xuICAgICAgICAuLi5leGlzdGluZ1JlYWN0aW9uMixcbiAgICAgICAgdXNlcnM6IFsuLi5leGlzdGluZ1JlYWN0aW9uMi51c2VycywgeyBpZDogcmVhY3Rpb24udXNlcklkIH1dXG4gICAgICB9IDogZXhpc3RpbmdSZWFjdGlvbjJcbiAgICApO1xuICB9XG4gIHJldHVybiByZWFjdGlvbnM7XG59XG5cbi8vIHNyYy9jbGllbnQudHNcbnZhciBNSU5fVEhST1RUTEUgPSAxNjtcbnZhciBNQVhfVEhST1RUTEUgPSAxZTM7XG52YXIgREVGQVVMVF9USFJPVFRMRSA9IDEwMDtcbnZhciBNSU5fQkFDS0dST1VORF9LRUVQX0FMSVZFX1RJTUVPVVQgPSAxNWUzO1xudmFyIE1JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDIwMDtcbnZhciBSRUNPTU1FTkRFRF9NSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAxZTM7XG52YXIgTUFYX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gM2U0O1xudmFyIERFRkFVTFRfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSA1ZTM7XG52YXIgUkVTT0xWRV9VU0VSU19CQVRDSF9ERUxBWSA9IDUwO1xudmFyIFJFU09MVkVfUk9PTVNfSU5GT19CQVRDSF9ERUxBWSA9IDUwO1xuZnVuY3Rpb24gZ2V0QmFzZVVybChiYXNlVXJsKSB7XG4gIGJhc2VVcmwgfHwgKGJhc2VVcmwgPSBwcm9jZXNzLmVudi5MSVZFQkxPQ0tTX0JBU0VfVVJMIHx8IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0xJVkVCTE9DS1NfQkFTRV9VUkwgfHwgcHJvY2Vzcy5lbnYuVklURV9MSVZFQkxPQ0tTX0JBU0VfVVJMIHx8IHZvaWQgMCk7XG4gIGlmICh0eXBlb2YgYmFzZVVybCA9PT0gXCJzdHJpbmdcIiAmJiBiYXNlVXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgcmV0dXJuIGJhc2VVcmw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERFRkFVTFRfQkFTRV9VUkw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEF1dGhCZWFyZXJIZWFkZXJGcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSkge1xuICBpZiAoYXV0aFZhbHVlLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICByZXR1cm4gYXV0aFZhbHVlLnB1YmxpY0FwaUtleTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXV0aFZhbHVlLnRva2VuLnJhdztcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50KG9wdGlvbnMpIHtcbiAgY29uc3QgY2xpZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIGNvbnN0IHRocm90dGxlRGVsYXkgPSBnZXRUaHJvdHRsZShjbGllbnRPcHRpb25zLnRocm90dGxlID8/IERFRkFVTFRfVEhST1RUTEUpO1xuICBjb25zdCBsb3N0Q29ubmVjdGlvblRpbWVvdXQgPSBnZXRMb3N0Q29ubmVjdGlvblRpbWVvdXQoXG4gICAgY2xpZW50T3B0aW9ucy5sb3N0Q29ubmVjdGlvblRpbWVvdXQgPz8gREVGQVVMVF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVFxuICApO1xuICBjb25zdCBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCA9IGdldEJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0KFxuICAgIGNsaWVudE9wdGlvbnMuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRcbiAgKTtcbiAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwoY2xpZW50T3B0aW9ucy5iYXNlVXJsKTtcbiAgY29uc3QgYXV0aE1hbmFnZXIgPSBjcmVhdGVBdXRoTWFuYWdlcihvcHRpb25zKTtcbiAgY29uc3Qgcm9vbXNCeUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gdGVhcmRvd25Sb29tKHJvb20pIHtcbiAgICB1bmxpbmtEZXZUb29scyhyb29tLmlkKTtcbiAgICByb29tc0J5SWQuZGVsZXRlKHJvb20uaWQpO1xuICAgIHJvb20uZGVzdHJveSgpO1xuICB9XG4gIGZ1bmN0aW9uIGxlYXNlUm9vbShpbmZvKSB7XG4gICAgY29uc3QgbGVhdmUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzZWxmID0gbGVhdmU7XG4gICAgICBpZiAoIWluZm8udW5zdWJzLmRlbGV0ZShzZWxmKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiVGhpcyBsZWF2ZSBmdW5jdGlvbiB3YXMgYWxyZWFkeSBjYWxsZWQuIENhbGxpbmcgaXQgbW9yZSB0aGFuIG9uY2UgaGFzIG5vIGVmZmVjdC5cIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluZm8udW5zdWJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0ZWFyZG93blJvb20oaW5mby5yb29tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaW5mby51bnN1YnMuYWRkKGxlYXZlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vbTogaW5mby5yb29tLFxuICAgICAgbGVhdmVcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGVudGVyUm9vbShyb29tSWQsIG9wdGlvbnMyKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSByb29tc0J5SWQuZ2V0KHJvb21JZCk7XG4gICAgaWYgKGV4aXN0aW5nICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsZWFzZVJvb20oZXhpc3RpbmcpO1xuICAgIH1cbiAgICBkZXByZWNhdGVJZihcbiAgICAgIG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZSA9PT0gbnVsbCB8fCBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2UgPT09IHZvaWQgMCxcbiAgICAgIFwiUGxlYXNlIHByb3ZpZGUgYW4gaW5pdGlhbCBwcmVzZW5jZSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgdXNlciB3aGVuIGVudGVyaW5nIHRoZSByb29tLlwiXG4gICAgKTtcbiAgICBjb25zdCBuZXdSb29tID0gY3JlYXRlUm9vbShcbiAgICAgIHtcbiAgICAgICAgaW5pdGlhbFByZXNlbmNlOiBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2UgPz8ge30sXG4gICAgICAgIGluaXRpYWxTdG9yYWdlOiBvcHRpb25zMi5pbml0aWFsU3RvcmFnZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcm9vbUlkLFxuICAgICAgICB0aHJvdHRsZURlbGF5LFxuICAgICAgICBsb3N0Q29ubmVjdGlvblRpbWVvdXQsXG4gICAgICAgIGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0LFxuICAgICAgICBwb2x5ZmlsbHM6IGNsaWVudE9wdGlvbnMucG9seWZpbGxzLFxuICAgICAgICBkZWxlZ2F0ZXM6IGNsaWVudE9wdGlvbnMubW9ja2VkRGVsZWdhdGVzID8/IHtcbiAgICAgICAgICBjcmVhdGVTb2NrZXQ6IG1ha2VDcmVhdGVTb2NrZXREZWxlZ2F0ZUZvclJvb20oXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICBiYXNlVXJsLFxuICAgICAgICAgICAgY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LldlYlNvY2tldFxuICAgICAgICAgICksXG4gICAgICAgICAgYXV0aGVudGljYXRlOiBtYWtlQXV0aERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGF1dGhNYW5hZ2VyKVxuICAgICAgICB9LFxuICAgICAgICBlbmFibGVEZWJ1Z0xvZ2dpbmc6IGNsaWVudE9wdGlvbnMuZW5hYmxlRGVidWdMb2dnaW5nLFxuICAgICAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogb3B0aW9uczI/LnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLFxuICAgICAgICBiYXNlVXJsLFxuICAgICAgICB1bnN0YWJsZV9mYWxsYmFja1RvSFRUUDogISFjbGllbnRPcHRpb25zLnVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQLFxuICAgICAgICB1bnN0YWJsZV9zdHJlYW1EYXRhOiAhIWNsaWVudE9wdGlvbnMudW5zdGFibGVfc3RyZWFtRGF0YVxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgbmV3Um9vbUluZm8gPSB7XG4gICAgICByb29tOiBuZXdSb29tLFxuICAgICAgdW5zdWJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgfTtcbiAgICByb29tc0J5SWQuc2V0KHJvb21JZCwgbmV3Um9vbUluZm8pO1xuICAgIHNldHVwRGV2VG9vbHMoKCkgPT4gQXJyYXkuZnJvbShyb29tc0J5SWQua2V5cygpKSk7XG4gICAgbGlua0RldlRvb2xzKHJvb21JZCwgbmV3Um9vbSk7XG4gICAgY29uc3Qgc2hvdWxkQ29ubmVjdCA9IG9wdGlvbnMyLmF1dG9Db25uZWN0ID8/IG9wdGlvbnMyLnNob3VsZEluaXRpYWxseUNvbm5lY3QgPz8gdHJ1ZTtcbiAgICBpZiAoc2hvdWxkQ29ubmVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBhdG9iID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChjbGllbnRPcHRpb25zLnBvbHlmaWxscz8uYXRvYiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJZb3UgbmVlZCB0byBwb2x5ZmlsbCBhdG9iIHRvIHVzZSB0aGUgY2xpZW50IGluIHlvdXIgZW52aXJvbm1lbnQuIFBsZWFzZSBmb2xsb3cgdGhlIGluc3RydWN0aW9ucyBhdCBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvbGl2ZWJsb2Nrcy1jbGllbnQvYXRvYi1wb2x5ZmlsbFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWwuYXRvYiA9IGNsaWVudE9wdGlvbnMucG9seWZpbGxzLmF0b2I7XG4gICAgICB9XG4gICAgICBuZXdSb29tLmNvbm5lY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlYXNlUm9vbShuZXdSb29tSW5mbyk7XG4gIH1cbiAgZnVuY3Rpb24gZW50ZXIocm9vbUlkLCBvcHRpb25zMikge1xuICAgIGNvbnN0IHsgcm9vbSwgbGVhdmU6IF8gfSA9IGVudGVyUm9vbShyb29tSWQsIG9wdGlvbnMyKTtcbiAgICByZXR1cm4gcm9vbTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSb29tKHJvb21JZCkge1xuICAgIGNvbnN0IHJvb20gPSByb29tc0J5SWQuZ2V0KHJvb21JZCk/LnJvb207XG4gICAgcmV0dXJuIHJvb20gPyByb29tIDogbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBmb3JjZUxlYXZlKHJvb21JZCkge1xuICAgIGNvbnN0IHVuc3VicyA9IHJvb21zQnlJZC5nZXQocm9vbUlkKT8udW5zdWJzID8/IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICAgIHVuc3ViKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxvZ291dCgpIHtcbiAgICBhdXRoTWFuYWdlci5yZXNldCgpO1xuICAgIGZvciAoY29uc3QgeyByb29tIH0gb2Ygcm9vbXNCeUlkLnZhbHVlcygpKSB7XG4gICAgICBpZiAoIWlzSWRsZShyb29tLmdldFN0YXR1cygpKSkge1xuICAgICAgICByb29tLnJlY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBjdXJyZW50VXNlcklkU3RvcmUgPSBjcmVhdGVTdG9yZShudWxsKTtcbiAgY29uc3Qge1xuICAgIGdldEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZFxuICB9ID0gY3JlYXRlTm90aWZpY2F0aW9uc0FwaSh7XG4gICAgYmFzZVVybCxcbiAgICBmZXRjaGVyOiBjbGllbnRPcHRpb25zLnBvbHlmaWxscz8uZmV0Y2ggfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmZXRjaCxcbiAgICBhdXRoTWFuYWdlcixcbiAgICBjdXJyZW50VXNlcklkU3RvcmVcbiAgfSk7XG4gIGNvbnN0IGNhY2hlU3RvcmUgPSBjcmVhdGVDbGllbnRTdG9yZSgpO1xuICBjb25zdCByZXNvbHZlVXNlcnMgPSBjbGllbnRPcHRpb25zLnJlc29sdmVVc2VycztcbiAgY29uc3Qgd2FybklmTm9SZXNvbHZlVXNlcnMgPSBjcmVhdGVEZXZlbG9wbWVudFdhcm5pbmcoXG4gICAgKCkgPT4gIXJlc29sdmVVc2VycyxcbiAgICBcIlNldCB0aGUgcmVzb2x2ZVVzZXJzIG9wdGlvbiBpbiBjcmVhdGVDbGllbnQgdG8gc3BlY2lmeSB1c2VyIGluZm8uXCJcbiAgKTtcbiAgY29uc3QgdXNlcnNTdG9yZSA9IGNyZWF0ZUJhdGNoU3RvcmUoXG4gICAgYXN5bmMgKGJhdGNoZWRVc2VySWRzKSA9PiB7XG4gICAgICBjb25zdCB1c2VySWRzID0gYmF0Y2hlZFVzZXJJZHMuZmxhdCgpO1xuICAgICAgY29uc3QgdXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnM/Lih7IHVzZXJJZHMgfSk7XG4gICAgICB3YXJuSWZOb1Jlc29sdmVVc2VycygpO1xuICAgICAgcmV0dXJuIHVzZXJzID8/IHVzZXJJZHMubWFwKCgpID0+IHZvaWQgMCk7XG4gICAgfSxcbiAgICB7IGRlbGF5OiBSRVNPTFZFX1VTRVJTX0JBVENIX0RFTEFZIH1cbiAgKTtcbiAgY29uc3QgcmVzb2x2ZVJvb21zSW5mbyA9IGNsaWVudE9wdGlvbnMucmVzb2x2ZVJvb21zSW5mbztcbiAgY29uc3Qgd2FybklmTm9SZXNvbHZlUm9vbXNJbmZvID0gY3JlYXRlRGV2ZWxvcG1lbnRXYXJuaW5nKFxuICAgICgpID0+ICFyZXNvbHZlUm9vbXNJbmZvLFxuICAgIFwiU2V0IHRoZSByZXNvbHZlUm9vbXNJbmZvIG9wdGlvbiBpbiBjcmVhdGVDbGllbnQgdG8gc3BlY2lmeSByb29tIGluZm8uXCJcbiAgKTtcbiAgY29uc3Qgcm9vbXNJbmZvU3RvcmUgPSBjcmVhdGVCYXRjaFN0b3JlKFxuICAgIGFzeW5jIChiYXRjaGVkUm9vbUlkcykgPT4ge1xuICAgICAgY29uc3Qgcm9vbUlkcyA9IGJhdGNoZWRSb29tSWRzLmZsYXQoKTtcbiAgICAgIGNvbnN0IHJvb21zSW5mbyA9IGF3YWl0IHJlc29sdmVSb29tc0luZm8/Lih7IHJvb21JZHMgfSk7XG4gICAgICB3YXJuSWZOb1Jlc29sdmVSb29tc0luZm8oKTtcbiAgICAgIHJldHVybiByb29tc0luZm8gPz8gcm9vbUlkcy5tYXAoKCkgPT4gdm9pZCAwKTtcbiAgICB9LFxuICAgIHsgZGVsYXk6IFJFU09MVkVfUk9PTVNfSU5GT19CQVRDSF9ERUxBWSB9XG4gICk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAge1xuICAgICAgbG9nb3V0LFxuICAgICAgLy8gT2xkLCBkZXByZWNhdGVkIEFQSXNcbiAgICAgIGVudGVyLFxuICAgICAgZ2V0Um9vbSxcbiAgICAgIGxlYXZlOiBmb3JjZUxlYXZlLFxuICAgICAgLy8gTmV3LCBwcmVmZXJyZWQgQVBJXG4gICAgICBlbnRlclJvb20sXG4gICAgICAvLyBJbnRlcm5hbFxuICAgICAgW2tJbnRlcm5hbF06IHtcbiAgICAgICAgbm90aWZpY2F0aW9uczoge1xuICAgICAgICAgIGdldEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICAgICAgICBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgICAgICAgIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZFxuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50VXNlcklkU3RvcmUsXG4gICAgICAgIHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnM6IGNsaWVudE9wdGlvbnMucmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyxcbiAgICAgICAgY2FjaGVTdG9yZSxcbiAgICAgICAgdXNlcnNTdG9yZSxcbiAgICAgICAgcm9vbXNJbmZvU3RvcmUsXG4gICAgICAgIGdldFJvb21JZHMoKSB7XG4gICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocm9vbXNCeUlkLmtleXMoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGtJbnRlcm5hbCxcbiAgICB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH1cbiAgKTtcbn1cbnZhciBOb3RpZmljYXRpb25zQXBpRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG59O1xuZnVuY3Rpb24gY2hlY2tCb3VuZHMob3B0aW9uLCB2YWx1ZSwgbWluLCBtYXgsIHJlY29tbWVuZGVkTWluKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIgfHwgdmFsdWUgPCBtaW4gfHwgbWF4ICE9PSB2b2lkIDAgJiYgdmFsdWUgPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBtYXggIT09IHZvaWQgMCA/IGAke29wdGlvbn0gc2hvdWxkIGJlIGJldHdlZW4gJHtyZWNvbW1lbmRlZE1pbiA/PyBtaW59IGFuZCAke21heH0uYCA6IGAke29wdGlvbn0gc2hvdWxkIGJlIGF0IGxlYXN0ICR7cmVjb21tZW5kZWRNaW4gPz8gbWlufS5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMClcbiAgICByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dFwiLFxuICAgIHZhbHVlLFxuICAgIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVFxuICApO1xufVxuZnVuY3Rpb24gZ2V0VGhyb3R0bGUodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm91bmRzKFwidGhyb3R0bGVcIiwgdmFsdWUsIE1JTl9USFJPVFRMRSwgTUFYX1RIUk9UVExFKTtcbn1cbmZ1bmN0aW9uIGdldExvc3RDb25uZWN0aW9uVGltZW91dCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJsb3N0Q29ubmVjdGlvblRpbWVvdXRcIixcbiAgICB2YWx1ZSxcbiAgICBNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgTUFYX0xPU1RfQ09OTkVDVElPTl9USU1FT1VULFxuICAgIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVFxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlRGV2ZWxvcG1lbnRXYXJuaW5nKGNvbmRpdGlvbiwgLi4uYXJncykge1xuICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFoYXNXYXJuZWQgJiYgKHR5cGVvZiBjb25kaXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IGNvbmRpdGlvbigpIDogY29uZGl0aW9uKSkge1xuICAgICAgICB3YXJuKC4uLmFyZ3MpO1xuICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9jb21tZW50cy9jb21tZW50LWJvZHkudHNcbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlQYXJhZ3JhcGgoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibWVudGlvblwiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keVRleHQoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0ZXh0XCIgaW4gZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC50ZXh0ID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keU1lbnRpb24oZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibWVudGlvblwiO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Qm9keUxpbmsoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwibGlua1wiO1xufVxudmFyIGNvbW1lbnRCb2R5RWxlbWVudHNHdWFyZHMgPSB7XG4gIHBhcmFncmFwaDogaXNDb21tZW50Qm9keVBhcmFncmFwaCxcbiAgdGV4dDogaXNDb21tZW50Qm9keVRleHQsXG4gIGxpbms6IGlzQ29tbWVudEJvZHlMaW5rLFxuICBtZW50aW9uOiBpc0NvbW1lbnRCb2R5TWVudGlvblxufTtcbnZhciBjb21tZW50Qm9keUVsZW1lbnRzVHlwZXMgPSB7XG4gIHBhcmFncmFwaDogXCJibG9ja1wiLFxuICB0ZXh0OiBcImlubGluZVwiLFxuICBsaW5rOiBcImlubGluZVwiLFxuICBtZW50aW9uOiBcImlubGluZVwiXG59O1xuZnVuY3Rpb24gdHJhdmVyc2VDb21tZW50Qm9keShib2R5LCBlbGVtZW50T3JWaXNpdG9yLCBwb3NzaWJseVZpc2l0b3IpIHtcbiAgaWYgKCFib2R5IHx8ICFib2R5Py5jb250ZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGVsZW1lbnQgPSB0eXBlb2YgZWxlbWVudE9yVmlzaXRvciA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnRPclZpc2l0b3IgOiB2b2lkIDA7XG4gIGNvbnN0IHR5cGUgPSBlbGVtZW50ID8gY29tbWVudEJvZHlFbGVtZW50c1R5cGVzW2VsZW1lbnRdIDogXCJhbGxcIjtcbiAgY29uc3QgZ3VhcmQgPSBlbGVtZW50ID8gY29tbWVudEJvZHlFbGVtZW50c0d1YXJkc1tlbGVtZW50XSA6ICgpID0+IHRydWU7XG4gIGNvbnN0IHZpc2l0b3IgPSB0eXBlb2YgZWxlbWVudE9yVmlzaXRvciA9PT0gXCJmdW5jdGlvblwiID8gZWxlbWVudE9yVmlzaXRvciA6IHBvc3NpYmx5VmlzaXRvcjtcbiAgZm9yIChjb25zdCBibG9jayBvZiBib2R5LmNvbnRlbnQpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJhbGxcIiB8fCB0eXBlID09PSBcImJsb2NrXCIpIHtcbiAgICAgIGlmIChndWFyZChibG9jaykpIHtcbiAgICAgICAgdmlzaXRvcj8uKGJsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIgfHwgdHlwZSA9PT0gXCJpbmxpbmVcIikge1xuICAgICAgZm9yIChjb25zdCBpbmxpbmUgb2YgYmxvY2suY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGd1YXJkKGlubGluZSkpIHtcbiAgICAgICAgICB2aXNpdG9yPy4oaW5saW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5KGJvZHkpIHtcbiAgY29uc3QgbWVudGlvbmVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgdHJhdmVyc2VDb21tZW50Qm9keShcbiAgICBib2R5LFxuICAgIFwibWVudGlvblwiLFxuICAgIChtZW50aW9uKSA9PiBtZW50aW9uZWRJZHMuYWRkKG1lbnRpb24uaWQpXG4gICk7XG4gIHJldHVybiBBcnJheS5mcm9tKG1lbnRpb25lZElkcyk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5KGJvZHksIHJlc29sdmVVc2Vycykge1xuICBjb25zdCByZXNvbHZlZFVzZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgaWYgKCFyZXNvbHZlVXNlcnMpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWRVc2VycztcbiAgfVxuICBjb25zdCB1c2VySWRzID0gZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5KGJvZHkpO1xuICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc29sdmVVc2Vycyh7XG4gICAgdXNlcklkc1xuICB9KTtcbiAgZm9yIChjb25zdCBbaW5kZXgsIHVzZXJJZF0gb2YgdXNlcklkcy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCB1c2VyID0gdXNlcnM/LltpbmRleF07XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHJlc29sdmVkVXNlcnMuc2V0KHVzZXJJZCwgdXNlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNvbHZlZFVzZXJzO1xufVxudmFyIGh0bWxFc2NhcGFibGVzID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiMzOTtcIlxufTtcbnZhciBodG1sRXNjYXBhYmxlc1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgT2JqZWN0LmtleXMoaHRtbEVzY2FwYWJsZXMpLm1hcCgoZW50aXR5KSA9PiBgXFxcXCR7ZW50aXR5fWApLmpvaW4oXCJ8XCIpLFxuICBcImdcIlxuKTtcbmZ1bmN0aW9uIGh0bWxTYWZlKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoW1N0cmluZyh2YWx1ZSldLCBbXSk7XG59XG5mdW5jdGlvbiBqb2luSHRtbChzdHJpbmdzKSB7XG4gIGlmIChzdHJpbmdzLmxlbmd0aCA8PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhbXCJcIl0sIFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFxuICAgIFtcIlwiLCAuLi5BcnJheShzdHJpbmdzLmxlbmd0aCAtIDEpLmZpbGwoXCJcIiksIFwiXCJdLFxuICAgIHN0cmluZ3NcbiAgKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZUh0bWwodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSHRtbFNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gam9pbkh0bWwodmFsdWUpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkucmVwbGFjZShcbiAgICBodG1sRXNjYXBhYmxlc1JlZ2V4LFxuICAgIChjaGFyYWN0ZXIpID0+IGh0bWxFc2NhcGFibGVzW2NoYXJhY3Rlcl1cbiAgKTtcbn1cbnZhciBIdG1sU2FmZVN0cmluZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5ncywgdmFsdWVzKSB7XG4gICAgdGhpcy5fc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJpbmdzLnJlZHVjZSgocmVzdWx0LCBzdHIsIGkpID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQgKyBlc2NhcGVIdG1sKG5uKHRoaXMuX3ZhbHVlc1tpIC0gMV0pKSArIHN0cjtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGh0bWwoc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoc3RyaW5ncywgdmFsdWVzKTtcbn1cbnZhciBtYXJrZG93bkVzY2FwYWJsZXMgPSB7XG4gIF86IFwiXFxcXF9cIixcbiAgXCIqXCI6IFwiXFxcXCpcIixcbiAgXCIjXCI6IFwiXFxcXCNcIixcbiAgXCJgXCI6IFwiXFxcXGBcIixcbiAgXCJ+XCI6IFwiXFxcXH5cIixcbiAgXCIhXCI6IFwiXFxcXCFcIixcbiAgXCJ8XCI6IFwiXFxcXHxcIixcbiAgXCIoXCI6IFwiXFxcXChcIixcbiAgXCIpXCI6IFwiXFxcXClcIixcbiAgXCJ7XCI6IFwiXFxcXHtcIixcbiAgXCJ9XCI6IFwiXFxcXH1cIixcbiAgXCJbXCI6IFwiXFxcXFtcIixcbiAgXCJdXCI6IFwiXFxcXF1cIlxufTtcbnZhciBtYXJrZG93bkVzY2FwYWJsZXNSZWdleCA9IG5ldyBSZWdFeHAoXG4gIE9iamVjdC5rZXlzKG1hcmtkb3duRXNjYXBhYmxlcykubWFwKChlbnRpdHkpID0+IGBcXFxcJHtlbnRpdHl9YCkuam9pbihcInxcIiksXG4gIFwiZ1wiXG4pO1xuZnVuY3Rpb24gam9pbk1hcmtkb3duKHN0cmluZ3MpIHtcbiAgaWYgKHN0cmluZ3MubGVuZ3RoIDw9IDApIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhbXCJcIl0sIFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhcbiAgICBbXCJcIiwgLi4uQXJyYXkoc3RyaW5ncy5sZW5ndGggLSAxKS5maWxsKFwiXCIpLCBcIlwiXSxcbiAgICBzdHJpbmdzXG4gICk7XG59XG5mdW5jdGlvbiBlc2NhcGVNYXJrZG93bih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXJrZG93blNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gam9pbk1hcmtkb3duKHZhbHVlKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoXG4gICAgbWFya2Rvd25Fc2NhcGFibGVzUmVnZXgsXG4gICAgKGNoYXJhY3RlcikgPT4gbWFya2Rvd25Fc2NhcGFibGVzW2NoYXJhY3Rlcl1cbiAgKTtcbn1cbnZhciBNYXJrZG93blNhZmVTdHJpbmcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlcykge1xuICAgIHRoaXMuX3N0cmluZ3MgPSBzdHJpbmdzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyaW5ncy5yZWR1Y2UoKHJlc3VsdCwgc3RyLCBpKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlTWFya2Rvd24obm4odGhpcy5fdmFsdWVzW2kgLSAxXSkpICsgc3RyO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gbWFya2Rvd24oc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gIHJldHVybiBuZXcgTWFya2Rvd25TYWZlU3RyaW5nKHN0cmluZ3MsIHZhbHVlcyk7XG59XG5mdW5jdGlvbiB0b0Fic29sdXRlVXJsKHVybCkge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IHVybC5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9IGVsc2UgaWYgKHVybC5zdGFydHNXaXRoKFwid3d3LlwiKSkge1xuICAgIHJldHVybiBcImh0dHBzOi8vXCIgKyB1cmw7XG4gIH1cbiAgcmV0dXJuO1xufVxudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5UGxhaW5FbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiBjaGlsZHJlbixcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LnRleHQsXG4gIGxpbms6ICh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC51cmwsXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBgQCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfWA7XG4gIH1cbn07XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlIdG1sRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIHJldHVybiBjaGlsZHJlbiA/IGh0bWxgPHA+JHtodG1sU2FmZShjaGlsZHJlbil9PC9wPmAgOiBjaGlsZHJlbjtcbiAgfSxcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiB7XG4gICAgbGV0IGNoaWxkcmVuID0gZWxlbWVudC50ZXh0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuYm9sZCkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxzdHJvbmc+JHtjaGlsZHJlbn08L3N0cm9uZz5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pdGFsaWMpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8ZW0+JHtjaGlsZHJlbn08L2VtPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnN0cmlrZXRocm91Z2gpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8cz4ke2NoaWxkcmVufTwvcz5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jb2RlKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPGNvZGU+JHtjaGlsZHJlbn08L2NvZGU+YDtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICBsaW5rOiAoeyBlbGVtZW50LCBocmVmIH0pID0+IHtcbiAgICByZXR1cm4gaHRtbGA8YSBocmVmPVwiJHtocmVmfVwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIj4ke2VsZW1lbnQudXJsfTwvYT5gO1xuICB9LFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gaHRtbGA8c3BhbiBkYXRhLW1lbnRpb24+QCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfTwvc3Bhbj5gO1xuICB9XG59O1xudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5TWFya2Rvd25FbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IHtcbiAgICBsZXQgY2hpbGRyZW4gPSBlbGVtZW50LnRleHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5ib2xkKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYCoqJHtjaGlsZHJlbn0qKmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lml0YWxpYykge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmBfJHtjaGlsZHJlbn1fYDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuc3RyaWtldGhyb3VnaCkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmB+fiR7Y2hpbGRyZW59fn5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jb2RlKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYFxcYCR7Y2hpbGRyZW59XFxgYDtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICBsaW5rOiAoeyBlbGVtZW50LCBocmVmIH0pID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd25gWyR7ZWxlbWVudC51cmx9XSgke2hyZWZ9KWA7XG4gIH0sXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBtYXJrZG93bmBAJHt1c2VyPy5uYW1lID8/IGVsZW1lbnQuaWR9YDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIHN0cmluZ2lmeUNvbW1lbnRCb2R5KGJvZHksIG9wdGlvbnMpIHtcbiAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucz8uZm9ybWF0ID8/IFwicGxhaW5cIjtcbiAgY29uc3Qgc2VwYXJhdG9yID0gb3B0aW9ucz8uc2VwYXJhdG9yID8/IChmb3JtYXQgPT09IFwibWFya2Rvd25cIiA/IFwiXFxuXFxuXCIgOiBcIlxcblwiKTtcbiAgY29uc3QgZWxlbWVudHMgPSB7XG4gICAgLi4uZm9ybWF0ID09PSBcImh0bWxcIiA/IHN0cmluZ2lmeUNvbW1lbnRCb2R5SHRtbEVsZW1lbnRzIDogZm9ybWF0ID09PSBcIm1hcmtkb3duXCIgPyBzdHJpbmdpZnlDb21tZW50Qm9keU1hcmtkb3duRWxlbWVudHMgOiBzdHJpbmdpZnlDb21tZW50Qm9keVBsYWluRWxlbWVudHMsXG4gICAgLi4ub3B0aW9ucz8uZWxlbWVudHNcbiAgfTtcbiAgY29uc3QgcmVzb2x2ZWRVc2VycyA9IGF3YWl0IHJlc29sdmVVc2Vyc0luQ29tbWVudEJvZHkoXG4gICAgYm9keSxcbiAgICBvcHRpb25zPy5yZXNvbHZlVXNlcnNcbiAgKTtcbiAgY29uc3QgYmxvY2tzID0gYm9keS5jb250ZW50LmZsYXRNYXAoKGJsb2NrLCBibG9ja0luZGV4KSA9PiB7XG4gICAgc3dpdGNoIChibG9jay50eXBlKSB7XG4gICAgICBjYXNlIFwicGFyYWdyYXBoXCI6IHtcbiAgICAgICAgY29uc3QgaW5saW5lcyA9IGJsb2NrLmNoaWxkcmVuLmZsYXRNYXAoKGlubGluZSwgaW5saW5lSW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keU1lbnRpb24oaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlubGluZS5pZCA/IFtcbiAgICAgICAgICAgICAgZWxlbWVudHMubWVudGlvbihcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBpbmxpbmUsXG4gICAgICAgICAgICAgICAgICB1c2VyOiByZXNvbHZlZFVzZXJzLmdldChpbmxpbmUuaWQpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmxpbmVJbmRleFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdIDogW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5TGluayhpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBlbGVtZW50cy5saW5rKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGlubGluZSxcbiAgICAgICAgICAgICAgICAgIGhyZWY6IHRvQWJzb2x1dGVVcmwoaW5saW5lLnVybCkgPz8gaW5saW5lLnVybFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlUZXh0KGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWxlbWVudHMudGV4dCh7IGVsZW1lbnQ6IGlubGluZSB9LCBpbmxpbmVJbmRleCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGVsZW1lbnRzLnBhcmFncmFwaChcbiAgICAgICAgICAgIHsgZWxlbWVudDogYmxvY2ssIGNoaWxkcmVuOiBpbmxpbmVzLmpvaW4oXCJcIikgfSxcbiAgICAgICAgICAgIGJsb2NrSW5kZXhcbiAgICAgICAgICApXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGJsb2Nrcy5qb2luKHNlcGFyYXRvcik7XG59XG5cbi8vIHNyYy9jcmR0cy91dGlscy50c1xuZnVuY3Rpb24gdG9QbGFpbkxzb24obHNvbikge1xuICBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgZGF0YTogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhsc29uLnRvT2JqZWN0KCkpLmZsYXRNYXAoXG4gICAgICAgICAgKFtrZXksIHZhbHVlXSkgPT4gdmFsdWUgIT09IHZvaWQgMCA/IFtba2V5LCB0b1BsYWluTHNvbih2YWx1ZSldXSA6IFtdXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGxzb24gaW5zdGFuY2VvZiBMaXZlTWFwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdmVibG9ja3NUeXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIGRhdGE6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgWy4uLmxzb25dLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LCB0b1BsYWluTHNvbih2YWx1ZSldKVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVMaXN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdmVibG9ja3NUeXBlOiBcIkxpdmVMaXN0XCIsXG4gICAgICBkYXRhOiBbLi4ubHNvbl0ubWFwKChpdGVtKSA9PiB0b1BsYWluTHNvbihpdGVtKSlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsc29uO1xuICB9XG59XG5cbi8vIHNyYy9pbW11dGFibGUudHNcbmZ1bmN0aW9uIGxzb25PYmplY3RUb0pzb24ob2JqKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBjb25zdCB2YWwgPSBvYmpba2V5XTtcbiAgICBpZiAodmFsICE9PSB2b2lkIDApIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbHNvblRvSnNvbih2YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbGl2ZU9iamVjdFRvSnNvbihsaXZlT2JqZWN0KSB7XG4gIHJldHVybiBsc29uT2JqZWN0VG9Kc29uKGxpdmVPYmplY3QudG9PYmplY3QoKSk7XG59XG5mdW5jdGlvbiBsaXZlTWFwVG9Kc29uKG1hcCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwLmVudHJpZXMoKSkge1xuICAgIHJlc3VsdFtrZXldID0gbHNvblRvSnNvbih2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxzb25MaXN0VG9Kc29uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXAobHNvblRvSnNvbik7XG59XG5mdW5jdGlvbiBsaXZlTGlzdFRvSnNvbih2YWx1ZSkge1xuICByZXR1cm4gbHNvbkxpc3RUb0pzb24odmFsdWUudG9BcnJheSgpKTtcbn1cbmZ1bmN0aW9uIGxzb25Ub0pzb24odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZU9iamVjdCkge1xuICAgIHJldHVybiBsaXZlT2JqZWN0VG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVMaXN0KSB7XG4gICAgcmV0dXJuIGxpdmVMaXN0VG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVNYXApIHtcbiAgICByZXR1cm4gbGl2ZU1hcFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIpIHtcbiAgICByZXR1cm4gdmFsdWUuZGF0YTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbHNvbkxpc3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGxzb25PYmplY3RUb0pzb24odmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRlZXBMaXZlaWZ5KHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgTGl2ZUxpc3QodmFsdWUubWFwKGRlZXBMaXZlaWZ5KSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICBjb25zdCBpbml0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGNvbnN0IHZhbCA9IHZhbHVlW2tleV07XG4gICAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpbml0W2tleV0gPSBkZWVwTGl2ZWlmeSh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExpdmVPYmplY3QoaW5pdCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVMaXN0KGxpdmVMaXN0LCBwcmV2LCBuZXh0KSB7XG4gIGxldCBpID0gMDtcbiAgbGV0IHByZXZFbmQgPSBwcmV2Lmxlbmd0aCAtIDE7XG4gIGxldCBuZXh0RW5kID0gbmV4dC5sZW5ndGggLSAxO1xuICBsZXQgcHJldk5vZGUgPSBwcmV2WzBdO1xuICBsZXQgbmV4dE5vZGUgPSBuZXh0WzBdO1xuICBvdXRlcjoge1xuICAgIHdoaWxlIChwcmV2Tm9kZSA9PT0gbmV4dE5vZGUpIHtcbiAgICAgICsraTtcbiAgICAgIGlmIChpID4gcHJldkVuZCB8fCBpID4gbmV4dEVuZCkge1xuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIHByZXZOb2RlID0gcHJldltpXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtpXTtcbiAgICB9XG4gICAgcHJldk5vZGUgPSBwcmV2W3ByZXZFbmRdO1xuICAgIG5leHROb2RlID0gbmV4dFtuZXh0RW5kXTtcbiAgICB3aGlsZSAocHJldk5vZGUgPT09IG5leHROb2RlKSB7XG4gICAgICBwcmV2RW5kLS07XG4gICAgICBuZXh0RW5kLS07XG4gICAgICBpZiAoaSA+IHByZXZFbmQgfHwgaSA+IG5leHRFbmQpIHtcbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBwcmV2Tm9kZSA9IHByZXZbcHJldkVuZF07XG4gICAgICBuZXh0Tm9kZSA9IG5leHRbbmV4dEVuZF07XG4gICAgfVxuICB9XG4gIGlmIChpID4gcHJldkVuZCkge1xuICAgIGlmIChpIDw9IG5leHRFbmQpIHtcbiAgICAgIHdoaWxlIChpIDw9IG5leHRFbmQpIHtcbiAgICAgICAgbGl2ZUxpc3QuaW5zZXJ0KGRlZXBMaXZlaWZ5KG5leHRbaV0pLCBpKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpID4gbmV4dEVuZCkge1xuICAgIGxldCBsb2NhbEkgPSBpO1xuICAgIHdoaWxlIChsb2NhbEkgPD0gcHJldkVuZCkge1xuICAgICAgbGl2ZUxpc3QuZGVsZXRlKGkpO1xuICAgICAgbG9jYWxJKys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChpIDw9IHByZXZFbmQgJiYgaSA8PSBuZXh0RW5kKSB7XG4gICAgICBwcmV2Tm9kZSA9IHByZXZbaV07XG4gICAgICBuZXh0Tm9kZSA9IG5leHRbaV07XG4gICAgICBjb25zdCBsaXZlTGlzdE5vZGUgPSBsaXZlTGlzdC5nZXQoaSk7XG4gICAgICBpZiAoaXNMaXZlT2JqZWN0KGxpdmVMaXN0Tm9kZSkgJiYgaXNQbGFpbk9iamVjdChwcmV2Tm9kZSkgJiYgaXNQbGFpbk9iamVjdChuZXh0Tm9kZSkpIHtcbiAgICAgICAgcGF0Y2hMaXZlT2JqZWN0KGxpdmVMaXN0Tm9kZSwgcHJldk5vZGUsIG5leHROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpdmVMaXN0LnNldChpLCBkZWVwTGl2ZWlmeShuZXh0Tm9kZSkpO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8PSBuZXh0RW5kKSB7XG4gICAgICBsaXZlTGlzdC5pbnNlcnQoZGVlcExpdmVpZnkobmV4dFtpXSksIGkpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICBsZXQgbG9jYWxJID0gaTtcbiAgICB3aGlsZSAobG9jYWxJIDw9IHByZXZFbmQpIHtcbiAgICAgIGxpdmVMaXN0LmRlbGV0ZShpKTtcbiAgICAgIGxvY2FsSSsrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hMaXZlT2JqZWN0S2V5KGxpdmVPYmplY3QsIGtleSwgcHJldiwgbmV4dCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3Qgbm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUobmV4dCk7XG4gICAgaWYgKG5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICBlcnJvcjIoXG4gICAgICAgIGBOZXcgc3RhdGUgcGF0aDogJyR7bm9uU2VyaWFsaXphYmxlVmFsdWUucGF0aH0nIHZhbHVlOiAnJHtTdHJpbmcoXG4gICAgICAgICAgbm9uU2VyaWFsaXphYmxlVmFsdWUudmFsdWVcbiAgICAgICAgKX0nIGlzIG5vdCBzZXJpYWxpemFibGUuXG5Pbmx5IHNlcmlhbGl6YWJsZSB2YWx1ZSBjYW4gYmUgc3luY2VkIHdpdGggTGl2ZWJsb2Nrcy5gXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjb25zdCB2YWx1ZSA9IGxpdmVPYmplY3QuZ2V0KGtleSk7XG4gIGlmIChuZXh0ID09PSB2b2lkIDApIHtcbiAgICBsaXZlT2JqZWN0LmRlbGV0ZShrZXkpO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICBsaXZlT2JqZWN0LnNldChrZXksIGRlZXBMaXZlaWZ5KG5leHQpKTtcbiAgfSBlbHNlIGlmIChwcmV2ID09PSBuZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGlzTGl2ZUxpc3QodmFsdWUpICYmIEFycmF5LmlzQXJyYXkocHJldikgJiYgQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIHBhdGNoTGl2ZUxpc3QodmFsdWUsIHByZXYsIG5leHQpO1xuICB9IGVsc2UgaWYgKGlzTGl2ZU9iamVjdCh2YWx1ZSkgJiYgaXNQbGFpbk9iamVjdChwcmV2KSAmJiBpc1BsYWluT2JqZWN0KG5leHQpKSB7XG4gICAgcGF0Y2hMaXZlT2JqZWN0KHZhbHVlLCBwcmV2LCBuZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBsaXZlT2JqZWN0LnNldChrZXksIGRlZXBMaXZlaWZ5KG5leHQpKTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hMaXZlT2JqZWN0KHJvb3QsIHByZXYsIG5leHQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG4gICAgcGF0Y2hMaXZlT2JqZWN0S2V5KHJvb3QsIGtleSwgcHJldltrZXldLCBuZXh0W2tleV0pO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcbiAgICBpZiAobmV4dFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIHJvb3QuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9XG4gIGlmIChPYmplY3Qua2V5cyh1cGRhdGVzKS5sZW5ndGggPiAwKSB7XG4gICAgcm9vdC51cGRhdGUodXBkYXRlcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBhcmVudHNQYXRoKG5vZGUpIHtcbiAgY29uc3QgcGF0aCA9IFtdO1xuICB3aGlsZSAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgIGlmIChpc0xpdmVMaXN0KG5vZGUucGFyZW50Lm5vZGUpKSB7XG4gICAgICBwYXRoLnB1c2gobm9kZS5wYXJlbnQubm9kZS5faW5kZXhPZlBvc2l0aW9uKG5vZGUucGFyZW50LmtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoLnB1c2gobm9kZS5wYXJlbnQua2V5KTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Lm5vZGU7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3Qoc3RhdGUsIHVwZGF0ZXMpIHtcbiAgcmV0dXJuIHVwZGF0ZXMucmVkdWNlKFxuICAgIChzdGF0ZTIsIHVwZGF0ZSkgPT4gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0V2l0aFVwZGF0ZShzdGF0ZTIsIHVwZGF0ZSksXG4gICAgc3RhdGVcbiAgKTtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdFdpdGhVcGRhdGUoc3RhdGUsIHVwZGF0ZSkge1xuICBjb25zdCBwYXRoID0gZ2V0UGFyZW50c1BhdGgodXBkYXRlLm5vZGUpO1xuICByZXR1cm4gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShzdGF0ZSwgcGF0aCwgdXBkYXRlKTtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUoc3RhdGUsIHBhdGgsIHVwZGF0ZSkge1xuICBjb25zdCBwYXRoSXRlbSA9IHBhdGgucG9wKCk7XG4gIGlmIChwYXRoSXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgY2FzZSBcIkxpdmVPYmplY3RcIjoge1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZU9iamVjdCBidXQgc3RhdGUgd2FzIG5vdCBhbiBvYmplY3RcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHVwZGF0ZS5ub2RlLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBsc29uVG9Kc29uKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkxpdmVMaXN0XCI6IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlTGlzdCBidXQgc3RhdGUgd2FzIG5vdCBhbiBhcnJheVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3U3RhdGUgPSBzdGF0ZS5tYXAoKHgpID0+IHgpO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RVcGRhdGUgb2YgdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcInNldFwiKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlLm1hcChcbiAgICAgICAgICAgICAgKGl0ZW0sIGluZGV4KSA9PiBpbmRleCA9PT0gbGlzdFVwZGF0ZS5pbmRleCA/IGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSA6IGl0ZW1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwiaW5zZXJ0XCIpIHtcbiAgICAgICAgICAgIGlmIChsaXN0VXBkYXRlLmluZGV4ID09PSBuZXdTdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUucHVzaChsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5pbmRleCksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXgpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlLnNwbGljZShsaXN0VXBkYXRlLmluZGV4LCAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJtb3ZlXCIpIHtcbiAgICAgICAgICAgIGlmIChsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggPiBsaXN0VXBkYXRlLmluZGV4KSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUuaW5kZXgpLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4LCBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXgpLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCArIDEpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXgpLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGUuaW5kZXggKyAxXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleCArIDEpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJMaXZlTWFwXCI6IHtcbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVNYXAgYnV0IHN0YXRlIHdhcyBub3QgYW4gb2JqZWN0XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHVwZGF0ZS5ub2RlLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IGxzb25Ub0pzb24odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgY29uc3QgbmV3QXJyYXkgPSBbLi4uc3RhdGVdO1xuICAgIG5ld0FycmF5W3BhdGhJdGVtXSA9IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUoXG4gICAgICBzdGF0ZVtwYXRoSXRlbV0sXG4gICAgICBwYXRoLFxuICAgICAgdXBkYXRlXG4gICAgKTtcbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH0gZWxzZSBpZiAoaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgIGNvbnN0IG5vZGUgPSBzdGF0ZVtwYXRoSXRlbV07XG4gICAgaWYgKG5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGF0ZUFzT2JqID0gc3RhdGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZUFzT2JqLFxuICAgICAgICBbcGF0aEl0ZW1dOiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKG5vZGUsIHBhdGgsIHVwZGF0ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL1BvbGxlci50c1xuZnVuY3Rpb24gbWFrZVBvbGxlcihjYWxsYmFjaykge1xuICBsZXQgY29udGV4dCA9IHtcbiAgICBzdGF0ZTogXCJzdG9wcGVkXCIsXG4gICAgdGltZW91dEhhbmRsZTogbnVsbCxcbiAgICBpbnRlcnZhbDogbnVsbCxcbiAgICBsYXN0U2NoZWR1bGVkQXQ6IG51bGwsXG4gICAgcmVtYWluaW5nSW50ZXJ2YWw6IG51bGxcbiAgfTtcbiAgZnVuY3Rpb24gcG9sbCgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSA9PT0gXCJydW5uaW5nXCIpIHtcbiAgICAgIHNjaGVkdWxlKGNvbnRleHQuaW50ZXJ2YWwpO1xuICAgIH1cbiAgICB2b2lkIGNhbGxiYWNrKCk7XG4gIH1cbiAgZnVuY3Rpb24gc2NoZWR1bGUoaW50ZXJ2YWwpIHtcbiAgICBjb250ZXh0ID0ge1xuICAgICAgc3RhdGU6IFwicnVubmluZ1wiLFxuICAgICAgaW50ZXJ2YWw6IGNvbnRleHQuc3RhdGUgIT09IFwic3RvcHBlZFwiID8gY29udGV4dC5pbnRlcnZhbCA6IGludGVydmFsLFxuICAgICAgbGFzdFNjaGVkdWxlZEF0OiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgIHRpbWVvdXRIYW5kbGU6IHNldFRpbWVvdXQocG9sbCwgaW50ZXJ2YWwpLFxuICAgICAgcmVtYWluaW5nSW50ZXJ2YWw6IG51bGxcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNjaGVkdWxlUmVtYWluaW5nKHJlbWFpbmluZykge1xuICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSBcInBhdXNlZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQgPSB7XG4gICAgICBzdGF0ZTogXCJydW5uaW5nXCIsXG4gICAgICBpbnRlcnZhbDogY29udGV4dC5pbnRlcnZhbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogY29udGV4dC5sYXN0U2NoZWR1bGVkQXQsXG4gICAgICB0aW1lb3V0SGFuZGxlOiBzZXRUaW1lb3V0KHBvbGwsIHJlbWFpbmluZyksXG4gICAgICByZW1haW5pbmdJbnRlcnZhbDogbnVsbFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoaW50ZXJ2YWwpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSA9PT0gXCJydW5uaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZWR1bGUoaW50ZXJ2YWwpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc3RhcnQoaW50ZXJ2YWwpIHtcbiAgICBzdG9wKCk7XG4gICAgc3RhcnQoaW50ZXJ2YWwpO1xuICB9XG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSBcInJ1bm5pbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoY29udGV4dC50aW1lb3V0SGFuZGxlKTtcbiAgICBjb250ZXh0ID0ge1xuICAgICAgc3RhdGU6IFwicGF1c2VkXCIsXG4gICAgICBpbnRlcnZhbDogY29udGV4dC5pbnRlcnZhbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRBdDogY29udGV4dC5sYXN0U2NoZWR1bGVkQXQsXG4gICAgICB0aW1lb3V0SGFuZGxlOiBudWxsLFxuICAgICAgcmVtYWluaW5nSW50ZXJ2YWw6IGNvbnRleHQuaW50ZXJ2YWwgLSAocGVyZm9ybWFuY2Uubm93KCkgLSBjb250ZXh0Lmxhc3RTY2hlZHVsZWRBdClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gXCJwYXVzZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY2hlZHVsZVJlbWFpbmluZyhjb250ZXh0LnJlbWFpbmluZ0ludGVydmFsKTtcbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIGlmIChjb250ZXh0LnN0YXRlID09PSBcInN0b3BwZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC50aW1lb3V0SGFuZGxlKSB7XG4gICAgICBjbGVhclRpbWVvdXQoY29udGV4dC50aW1lb3V0SGFuZGxlKTtcbiAgICB9XG4gICAgY29udGV4dCA9IHtcbiAgICAgIHN0YXRlOiBcInN0b3BwZWRcIixcbiAgICAgIGludGVydmFsOiBudWxsLFxuICAgICAgbGFzdFNjaGVkdWxlZEF0OiBudWxsLFxuICAgICAgdGltZW91dEhhbmRsZTogbnVsbCxcbiAgICAgIHJlbWFpbmluZ0ludGVydmFsOiBudWxsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0LFxuICAgIHJlc3RhcnQsXG4gICAgcGF1c2UsXG4gICAgcmVzdW1lLFxuICAgIHN0b3BcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9zaGFsbG93LnRzXG5mdW5jdGlvbiBzaGFsbG93QXJyYXkoeHMsIHlzKSB7XG4gIGlmICh4cy5sZW5ndGggIT09IHlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFPYmplY3QuaXMoeHNbaV0sIHlzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dPYmoob2JqQSwgb2JqQikge1xuICBpZiAodHlwZW9mIG9iakEgIT09IFwib2JqZWN0XCIgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCBvYmpCID09PSBudWxsIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmpBKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqQikgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqQikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBrZXlzQS5ldmVyeShcbiAgICAoa2V5KSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5KSAmJiBPYmplY3QuaXMob2JqQVtrZXldLCBvYmpCW2tleV0pXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93KGEsIGIpIHtcbiAgaWYgKE9iamVjdC5pcyhhLCBiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgY29uc3QgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICBpZiAoaXNBcnJheUEgfHwgaXNBcnJheUIpIHtcbiAgICBpZiAoIWlzQXJyYXlBIHx8ICFpc0FycmF5Qikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2hhbGxvd0FycmF5KGEsIGIpO1xuICB9XG4gIHJldHVybiBzaGFsbG93T2JqKGEsIGIpO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmRldGVjdER1cGVzKFBLR19OQU1FLCBQS0dfVkVSU0lPTiwgUEtHX0ZPUk1BVCk7XG5leHBvcnQge1xuICBDbGllbnRNc2dDb2RlLFxuICBDb21tZW50c0FwaUVycm9yLFxuICBDcmR0VHlwZSxcbiAgTGl2ZUxpc3QsXG4gIExpdmVNYXAsXG4gIExpdmVPYmplY3QsXG4gIE5vdGlmaWNhdGlvbnNBcGlFcnJvcixcbiAgT3BDb2RlLFxuICBTZXJ2ZXJNc2dDb2RlLFxuICBXZWJzb2NrZXRDbG9zZUNvZGVzLFxuICBhY2tPcCxcbiAgYWRkUmVhY3Rpb24sXG4gIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMsXG4gIGFzUG9zLFxuICBhc3NlcnQsXG4gIGFzc2VydE5ldmVyLFxuICBiNjRkZWNvZGUsXG4gIGNsb25lTHNvbixcbiAgZmFuY3lfY29uc29sZV9leHBvcnRzIGFzIGNvbnNvbGUsXG4gIGNvbnZlcnRUb0NvbW1lbnREYXRhLFxuICBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uLFxuICBjb252ZXJ0VG9UaHJlYWREYXRhLFxuICBjcmVhdGVDbGllbnQsXG4gIGRlbGV0ZUNvbW1lbnQsXG4gIGRlcHJlY2F0ZSxcbiAgZGVwcmVjYXRlSWYsXG4gIGRldGVjdER1cGVzLFxuICBlcnJvcklmLFxuICBmcmVlemUsXG4gIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keSxcbiAgaXNDaGlsZENyZHQsXG4gIGlzSnNvbkFycmF5LFxuICBpc0pzb25PYmplY3QsXG4gIGlzSnNvblNjYWxhcixcbiAgaXNMaXZlTm9kZSxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNSb290Q3JkdCxcbiAga0ludGVybmFsLFxuICBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3QsXG4gIGxzb25Ub0pzb24sXG4gIG1ha2VFdmVudFNvdXJjZSxcbiAgbWFrZVBvbGxlcixcbiAgbWFrZVBvc2l0aW9uLFxuICBubixcbiAgcGF0Y2hMaXZlT2JqZWN0S2V5LFxuICByYWlzZSxcbiAgcmVtb3ZlUmVhY3Rpb24sXG4gIHNoYWxsb3csXG4gIHN0cmluZ2lmeSxcbiAgc3RyaW5naWZ5Q29tbWVudEJvZHksXG4gIHRocm93VXNhZ2VFcnJvcixcbiAgdG9QbGFpbkxzb24sXG4gIHRyeVBhcnNlSnNvbixcbiAgdXBzZXJ0Q29tbWVudCxcbiAgd2l0aFRpbWVvdXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@liveblocks/core/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@liveblocks/react/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/index.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientSideSuspense: function() { return /* binding */ ClientSideSuspense; },\n/* harmony export */   createLiveblocksContext: function() { return /* binding */ createLiveblocksContext; },\n/* harmony export */   createRoomContext: function() { return /* binding */ createRoomContext; },\n/* harmony export */   shallow: function() { return /* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow; },\n/* harmony export */   useLiveblocksContextBundle: function() { return /* binding */ useLiveblocksContextBundle; },\n/* harmony export */   useRoomContextBundle: function() { return /* binding */ useRoomContextBundle; },\n/* harmony export */   useSharedContextBundle: function() { return /* binding */ useSharedContextBundle; }\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/client */ \"(app-pages-browser)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nanoid */ \"(app-pages-browser)/./node_modules/nanoid/index.browser.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n/* __next_internal_client_entry_do_not_use__ ClientSideSuspense,createLiveblocksContext,createRoomContext,shallow,useLiveblocksContextBundle,useRoomContextBundle,useSharedContextBundle auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$();\n// src/index.ts\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/react\";\nvar PKG_VERSION = \"1.10.2\";\nvar PKG_FORMAT = \"esm\";\n// src/ClientSideSuspense.tsx\n\nfunction ClientSideSuspense(props) {\n    _s();\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n        fallback: props.fallback\n    }, mounted ? props.children() : props.fallback);\n}\n_s(ClientSideSuspense, \"LrrVfNW3d1raFE0BNzCTILYmIfo=\");\n_c = ClientSideSuspense;\n// src/liveblocks.tsx\n\n\n\n\n\n// src/comments/lib/selected-inbox-notifications.ts\n\nfunction selectedInboxNotifications(state) {\n    const result = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.applyOptimisticUpdates)(state);\n    return Object.values(result.inboxNotifications).sort(// Sort so that the most recent notifications are first\n    (a, b)=>b.notifiedAt.getTime() - a.notifiedAt.getTime());\n}\n// src/lib/retry-error.ts\nvar MAX_ERROR_RETRY_COUNT = 5;\nvar ERROR_RETRY_INTERVAL = 5e3;\nfunction retryError(action, retryCount) {\n    if (retryCount >= MAX_ERROR_RETRY_COUNT) return;\n    const timeout = Math.pow(2, retryCount) * ERROR_RETRY_INTERVAL;\n    setTimeout(()=>{\n        void action();\n    }, timeout);\n}\n// src/shared.ts\n\n\n\n// src/room.tsx\n\n\n\n\n\n// src/comments/errors.ts\nvar CreateThreadError = class extends Error {\n    constructor(cause, context){\n        super(\"Create thread failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"CreateThreadError\";\n    }\n};\nvar EditThreadMetadataError = class extends Error {\n    constructor(cause, context){\n        super(\"Edit thread metadata failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"EditThreadMetadataError\";\n    }\n};\nvar CreateCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Create comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"CreateCommentError\";\n    }\n};\nvar EditCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Edit comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"EditCommentError\";\n    }\n};\nvar DeleteCommentError = class extends Error {\n    constructor(cause, context){\n        super(\"Delete comment failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"DeleteCommentError\";\n    }\n};\nvar AddReactionError = class extends Error {\n    constructor(cause, context){\n        super(\"Add reaction failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"AddReactionError\";\n    }\n};\nvar RemoveReactionError = class extends Error {\n    constructor(cause, context){\n        super(\"Remove reaction failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"RemoveReactionError\";\n    }\n};\nvar MarkInboxNotificationAsReadError = class extends Error {\n    constructor(cause, context){\n        super(\"Mark inbox notification as read failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"MarkInboxNotificationAsReadError\";\n    }\n};\nvar UpdateNotificationSettingsError = class extends Error {\n    constructor(cause, context){\n        super(\"Update notification settings failed.\");\n        this.cause = cause;\n        this.context = context;\n        this.name = \"UpdateNotificationSettingsError\";\n    }\n};\n// src/comments/lib/createIds.ts\n\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nfunction createOptimisticId(prefix) {\n    return \"\".concat(prefix, \"_\").concat((0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)());\n}\nfunction createThreadId() {\n    return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n    return createOptimisticId(COMMENT_ID_PREFIX);\n}\n// src/comments/lib/select-notification-settings.ts\n\nfunction selectNotificationSettings(roomId, state) {\n    const { notificationSettings } = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.applyOptimisticUpdates)(state);\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.nn)(notificationSettings[roomId]);\n}\n// src/comments/lib/selected-threads.ts\n\nfunction selectedThreads(roomId, state, options) {\n    const result = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.applyOptimisticUpdates)(state);\n    const threads = Object.values(result.threads).filter((thread)=>{\n        if (thread.roomId !== roomId) return false;\n        if (thread.deletedAt !== void 0) {\n            return false;\n        }\n        const query = options.query;\n        if (!query) return true;\n        for(const key in query.metadata){\n            if (thread.metadata[key] !== query.metadata[key]) {\n                return false;\n            }\n        }\n        return true;\n    });\n    return threads.sort((a, b)=>a.createdAt.getTime() - b.createdAt.getTime());\n}\n// src/lib/use-initial.ts\n\nfunction useInitial(value) {\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(value)[0];\n}\n_s1(useInitial, \"SaqJvJUOBqgh/CiDbPxODAGleM0=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useState\n    ];\n});\n// src/lib/use-latest.ts\n\nfunction useLatest(value) {\n    _s2();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref;\n}\n_s2(useLatest, \"BLZ/gngkT3sJtHn99TU3Jk6LR4U=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect\n    ];\n});\n// src/lib/use-rerender.ts\n\nfunction useRerender() {\n    _s3();\n    const [, update] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(// This implementation works by incrementing a hidden counter value that is\n    // never consumed. Simply incrementing the counter changes the component's\n    // state and, thus, trigger a re-render.\n    (x)=>x + 1, 0);\n    return update;\n}\n_s3(useRerender, \"OhrQOAn1W/INSRhOrgETZKuOhVA=\");\n// src/room.tsx\nvar noop = ()=>{};\nvar identity = (x)=>x;\nvar missing_unstable_batchedUpdates = (reactVersion, roomId)=>\"We noticed you’re using React \".concat(reactVersion, '. Please pass unstable_batchedUpdates at the RoomProvider level until you’re ready to upgrade to React 18:\\n\\n    import { unstable_batchedUpdates } from \"react-dom\";  // or \"react-native\"\\n\\n    <RoomProvider id=').concat(JSON.stringify(roomId), \" ... unstable_batchedUpdates={unstable_batchedUpdates}>\\n      ...\\n    </RoomProvider>\\n\\nWhy? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information\");\nvar superfluous_unstable_batchedUpdates = \"You don’t need to pass unstable_batchedUpdates to RoomProvider anymore, since you’re on React 18+ already.\";\nfunction useSyncExternalStore(s, gs, gss) {\n    _s4();\n    return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(s, gs, gss, identity);\n}\n_s4(useSyncExternalStore, \"B+Aoh5GYdro626SmEkKwUx058gA=\", false, function() {\n    return [\n        use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector\n    ];\n});\nvar STABLE_EMPTY_LIST = Object.freeze([]);\nvar POLLING_INTERVAL = 5 * 60 * 1e3;\nvar MENTION_SUGGESTIONS_DEBOUNCE = 500;\nfunction alwaysEmptyList() {\n    return STABLE_EMPTY_LIST;\n}\nfunction alwaysNull() {\n    return null;\n}\nfunction makeMutationContext(room) {\n    const errmsg = \"This mutation cannot be used until connected to the Liveblocks room\";\n    return {\n        get storage () {\n            const mutableRoot = room.getStorageSnapshot();\n            if (mutableRoot === null) {\n                throw new Error(errmsg);\n            }\n            return mutableRoot;\n        },\n        get self () {\n            const self = room.getSelf();\n            if (self === null) {\n                throw new Error(errmsg);\n            }\n            return self;\n        },\n        get others () {\n            const others = room.getOthers();\n            if (room.getSelf() === null) {\n                throw new Error(errmsg);\n            }\n            return others;\n        },\n        setMyPresence: room.updatePresence\n    };\n}\nvar ContextBundle = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useRoomContextBundle() {\n    _s5();\n    const bundle = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ContextBundle);\n    if (bundle === null) {\n        throw new Error(\"RoomProvider is missing from the React tree.\");\n    }\n    return bundle;\n}\n_s5(useRoomContextBundle, \"/Yt2TBLkiK+BQAGeiF3IxG9eCZY=\");\nfunction createRoomContext(client, options) {\n    var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$(), _s13 = $RefreshSig$(), _s14 = $RefreshSig$(), _s15 = $RefreshSig$(), _s16 = $RefreshSig$(), _s17 = $RefreshSig$(), _s18 = $RefreshSig$(), _s19 = $RefreshSig$(), _s20 = $RefreshSig$(), _s21 = $RefreshSig$(), _s22 = $RefreshSig$(), _s23 = $RefreshSig$(), _s24 = $RefreshSig$(), _s25 = $RefreshSig$(), _s26 = $RefreshSig$(), _s27 = $RefreshSig$(), _s28 = $RefreshSig$(), _s29 = $RefreshSig$(), _s30 = $RefreshSig$(), _s31 = $RefreshSig$(), _s32 = $RefreshSig$(), _s33 = $RefreshSig$(), _s34 = $RefreshSig$(), _s35 = $RefreshSig$(), _s36 = $RefreshSig$(), _s37 = $RefreshSig$(), _s38 = $RefreshSig$(), _s39 = $RefreshSig$(), _s40 = $RefreshSig$(), _s41 = $RefreshSig$(), _s42 = $RefreshSig$(), _s43 = $RefreshSig$(), _s44 = $RefreshSig$(), _s45 = $RefreshSig$(), _s46 = $RefreshSig$(), _s47 = $RefreshSig$(), _s48 = $RefreshSig$(), _s49 = $RefreshSig$(), _s50 = $RefreshSig$(), _s51 = $RefreshSig$();\n    if (options === null || options === void 0 ? void 0 : options.resolveUsers) {\n        throw new Error(\"The 'resolveUsers' option has moved to 'createClient' from '@liveblocks/client'. Please refer to our Upgrade Guide to learn more, see https://liveblocks.io/docs/platform/upgrading/1.10.\");\n    }\n    if (options === null || options === void 0 ? void 0 : options.resolveMentionSuggestions) {\n        throw new Error(\"The 'resolveMentionSuggestions' option has moved to 'createClient' from '@liveblocks/client'. Please refer to our Upgrade Guide to learn more, see https://liveblocks.io/docs/platform/upgrading/1.10.\");\n    }\n    const RoomContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n    const commentsErrorEventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n    const shared = createSharedContext(client);\n    function RoomProviderOuter(props) {\n        _s();\n        const [cache] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>/* @__PURE__ */ new Map());\n        const stableEnterRoom = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((roomId, options2)=>{\n            const cached = cache.get(roomId);\n            if (cached) return cached;\n            const rv = client.enterRoom(roomId, options2);\n            const origLeave = rv.leave;\n            rv.leave = ()=>{\n                origLeave();\n                cache.delete(roomId);\n            };\n            cache.set(roomId, rv);\n            return rv;\n        }, [\n            cache\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomProviderInner, {\n            ...props,\n            stableEnterRoom\n        });\n    }\n    _s(RoomProviderOuter, \"mKddi/3p7+2yJai7e/U3hcSmznE=\");\n    function RoomProviderInner(props) {\n        _s1();\n        const { id: roomId, stableEnterRoom } = props;\n        if (true) {\n            if (!roomId) {\n                throw new Error(\"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\");\n            }\n            if (typeof roomId !== \"string\") {\n                throw new Error(\"RoomProvider id property should be a string.\");\n            }\n            const majorReactVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version) || 1;\n            const oldReactVersion = majorReactVersion < 18;\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.errorIf)(oldReactVersion && props.unstable_batchedUpdates === void 0, missing_unstable_batchedUpdates(majorReactVersion, roomId));\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.deprecateIf)(!oldReactVersion && props.unstable_batchedUpdates !== void 0, superfluous_unstable_batchedUpdates);\n        }\n        var _props_autoConnect, _ref;\n        const frozenProps = useInitial({\n            initialPresence: props.initialPresence,\n            initialStorage: props.initialStorage,\n            unstable_batchedUpdates: props.unstable_batchedUpdates,\n            autoConnect: (_ref = (_props_autoConnect = props.autoConnect) !== null && _props_autoConnect !== void 0 ? _props_autoConnect : props.shouldInitiallyConnect) !== null && _ref !== void 0 ? _ref : typeof window !== \"undefined\"\n        });\n        const [{ room }, setRoomLeavePair] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>stableEnterRoom(roomId, {\n                ...frozenProps,\n                autoConnect: false\n            }));\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            async function handleCommentEvent(message) {\n                const info = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.getThread({\n                    threadId: message.threadId\n                });\n                if (!info) {\n                    store.deleteThread(message.threadId);\n                    return;\n                }\n                const { thread, inboxNotification } = info;\n                const existingThread = store.get().threads[message.threadId];\n                switch(message.type){\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_EDITED:\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.THREAD_METADATA_UPDATED:\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_REACTION_ADDED:\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_REACTION_REMOVED:\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_DELETED:\n                        if (!existingThread) break;\n                        store.updateThreadAndNotification(thread, inboxNotification);\n                        break;\n                    case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_CREATED:\n                        store.updateThreadAndNotification(thread, inboxNotification);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            return room.events.comments.subscribe((message)=>void handleCommentEvent(message));\n        }, [\n            room\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            void getThreadsUpdates(room.id);\n        }, [\n            room.id\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            function handleIsOnline() {\n                void getThreadsUpdates(room.id);\n            }\n            window.addEventListener(\"online\", handleIsOnline);\n            return ()=>{\n                window.removeEventListener(\"online\", handleIsOnline);\n            };\n        }, [\n            room.id\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const pair = stableEnterRoom(roomId, frozenProps);\n            setRoomLeavePair(pair);\n            const { room: room2, leave } = pair;\n            if (frozenProps.autoConnect) {\n                room2.connect();\n            }\n            return ()=>{\n                leave();\n            };\n        }, [\n            roomId,\n            frozenProps,\n            stableEnterRoom\n        ]);\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomContext.Provider, {\n            value: room\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextBundle.Provider, {\n            value: bundle\n        }, props.children));\n    }\n    _s1(RoomProviderInner, \"pW2OFIgPSYeewPmsWSJX6/Mtlaw=\", false, function() {\n        return [\n            useInitial\n        ];\n    });\n    function connectionIdSelector(others) {\n        return others.map((user)=>user.connectionId);\n    }\n    function useRoom() {\n        _s2();\n        const room = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RoomContext);\n        if (room === null) {\n            throw new Error(\"RoomProvider is missing from the React tree.\");\n        }\n        return room;\n    }\n    _s2(useRoom, \"8pzZl8Wn+Ru3GugNYlOVJR39oTA=\");\n    function useStatus() {\n        _s3();\n        const room = useRoom();\n        const subscribe = room.events.status.subscribe;\n        const getSnapshot = room.getStatus;\n        const getServerSnapshot = room.getStatus;\n        return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    }\n    _s3(useStatus, \"ZXwyxKFUfDzqu7nFjEjRuhwOrXw=\", false, function() {\n        return [\n            useRoom,\n            useSyncExternalStore\n        ];\n    });\n    function useMyPresence() {\n        _s4();\n        const room = useRoom();\n        const subscribe = room.events.myPresence.subscribe;\n        const getSnapshot = room.getPresence;\n        const presence = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n        const setPresence = room.updatePresence;\n        return [\n            presence,\n            setPresence\n        ];\n    }\n    _s4(useMyPresence, \"rfzeXdCBjZ0SElXIa8kiarrmFCY=\", false, function() {\n        return [\n            useRoom,\n            useSyncExternalStore\n        ];\n    });\n    function useUpdateMyPresence() {\n        _s5();\n        return useRoom().updatePresence;\n    }\n    _s5(useUpdateMyPresence, \"FxiKrJOMJJNhaRQQz0EOlEBhEog=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useOthers(selector, isEqual) {\n        _s6();\n        const room = useRoom();\n        const subscribe = room.events.others.subscribe;\n        const getSnapshot = room.getOthers;\n        const getServerSnapshot = alwaysEmptyList;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(subscribe, getSnapshot, getServerSnapshot, selector !== null && selector !== void 0 ? selector : identity, isEqual);\n    }\n    _s6(useOthers, \"zCQHp2SL2cK++6/3jyImBmt7C+8=\", false, function() {\n        return [\n            useRoom,\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function useOthersConnectionIds() {\n        _s7();\n        return useOthers(connectionIdSelector, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow);\n    }\n    _s7(useOthersConnectionIds, \"6jB4CmiADvy0x5yMLb1ArTc/siU=\", false, function() {\n        return [\n            useOthers\n        ];\n    });\n    function useOthersMapped(itemSelector, itemIsEqual) {\n        _s8();\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((others)=>others.map((other)=>[\n                    other.connectionId,\n                    itemSelector(other)\n                ]), [\n            itemSelector\n        ]);\n        const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((a, b)=>{\n            const eq = itemIsEqual !== null && itemIsEqual !== void 0 ? itemIsEqual : Object.is;\n            return a.length === b.length && a.every((atuple, index)=>{\n                const btuple = b[index];\n                return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n            });\n        }, [\n            itemIsEqual\n        ]);\n        return useOthers(wrappedSelector, wrappedIsEqual);\n    }\n    _s8(useOthersMapped, \"QVo/xWftrYyzYLUmcqVZUiiRPdw=\", false, function() {\n        return [\n            useOthers\n        ];\n    });\n    const NOT_FOUND = Symbol();\n    function useOther(connectionId, selector, isEqual) {\n        _s9();\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((others)=>{\n            const other2 = others.find((other3)=>other3.connectionId === connectionId);\n            return other2 !== void 0 ? selector(other2) : NOT_FOUND;\n        }, [\n            connectionId,\n            selector\n        ]);\n        const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((prev, curr)=>{\n            if (prev === NOT_FOUND || curr === NOT_FOUND) {\n                return prev === curr;\n            }\n            const eq = isEqual !== null && isEqual !== void 0 ? isEqual : Object.is;\n            return eq(prev, curr);\n        }, [\n            isEqual\n        ]);\n        const other = useOthers(wrappedSelector, wrappedIsEqual);\n        if (other === NOT_FOUND) {\n            throw new Error(\"No such other user with connection id \".concat(connectionId, \" exists\"));\n        }\n        return other;\n    }\n    _s9(useOther, \"9iZgjSXiCys5UFZauLNwjMbsrjo=\", false, function() {\n        return [\n            useOthers\n        ];\n    });\n    function useBroadcastEvent() {\n        _s10();\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(event) {\n            let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n                shouldQueueEventIfNotReady: false\n            };\n            room.broadcastEvent(event, options2);\n        }, [\n            room\n        ]);\n    }\n    _s10(useBroadcastEvent, \"mRjfZCZLIOt9iOyXufGWtKsUM38=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useOthersListener(callback) {\n        _s11();\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.others.subscribe((event)=>savedCallback.current(event)), [\n            room,\n            savedCallback\n        ]);\n    }\n    _s11(useOthersListener, \"pVgeNp/NR8vr1KFBM1x9XIErS1Y=\", false, function() {\n        return [\n            useRoom,\n            useLatest\n        ];\n    });\n    function useLostConnectionListener(callback) {\n        _s12();\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.lostConnection.subscribe((event)=>savedCallback.current(event)), [\n            room,\n            savedCallback\n        ]);\n    }\n    _s12(useLostConnectionListener, \"pVgeNp/NR8vr1KFBM1x9XIErS1Y=\", false, function() {\n        return [\n            useRoom,\n            useLatest\n        ];\n    });\n    function useErrorListener(callback) {\n        _s13();\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>room.events.error.subscribe((e)=>savedCallback.current(e)), [\n            room,\n            savedCallback\n        ]);\n    }\n    _s13(useErrorListener, \"pVgeNp/NR8vr1KFBM1x9XIErS1Y=\", false, function() {\n        return [\n            useRoom,\n            useLatest\n        ];\n    });\n    function useEventListener(callback) {\n        _s14();\n        const room = useRoom();\n        const savedCallback = useLatest(callback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const listener = (eventData)=>{\n                savedCallback.current(eventData);\n            };\n            return room.events.customEvent.subscribe(listener);\n        }, [\n            room,\n            savedCallback\n        ]);\n    }\n    _s14(useEventListener, \"pVgeNp/NR8vr1KFBM1x9XIErS1Y=\", false, function() {\n        return [\n            useRoom,\n            useLatest\n        ];\n    });\n    function useSelf(maybeSelector, isEqual) {\n        _s15();\n        const room = useRoom();\n        const subscribe = room.events.self.subscribe;\n        const getSnapshot = room.getSelf;\n        const selector = maybeSelector !== null && maybeSelector !== void 0 ? maybeSelector : identity;\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((me)=>me !== null ? selector(me) : null, [\n            selector\n        ]);\n        const getServerSnapshot = alwaysNull;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(subscribe, getSnapshot, getServerSnapshot, wrappedSelector, isEqual);\n    }\n    _s15(useSelf, \"otswN+jfatrTK71iqSfeRSL7SOU=\", false, function() {\n        return [\n            useRoom,\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function useMutableStorageRoot() {\n        _s16();\n        const room = useRoom();\n        const subscribe = room.events.storageDidLoad.subscribeOnce;\n        const getSnapshot = room.getStorageSnapshot;\n        const getServerSnapshot = alwaysNull;\n        return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    }\n    _s16(useMutableStorageRoot, \"ZXwyxKFUfDzqu7nFjEjRuhwOrXw=\", false, function() {\n        return [\n            useRoom,\n            useSyncExternalStore\n        ];\n    });\n    function useStorageRoot() {\n        _s17();\n        return [\n            useMutableStorageRoot()\n        ];\n    }\n    _s17(useStorageRoot, \"ScjpHkLIwcJwYDu1t5uCS240Fs8=\", false, function() {\n        return [\n            useMutableStorageRoot\n        ];\n    });\n    function useHistory() {\n        _s18();\n        return useRoom().history;\n    }\n    _s18(useHistory, \"FxiKrJOMJJNhaRQQz0EOlEBhEog=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useUndo() {\n        _s19();\n        return useHistory().undo;\n    }\n    _s19(useUndo, \"ebO9cvF3Ou0GZnyLIaifBK5vWck=\", false, function() {\n        return [\n            useHistory\n        ];\n    });\n    function useRedo() {\n        _s20();\n        return useHistory().redo;\n    }\n    _s20(useRedo, \"ebO9cvF3Ou0GZnyLIaifBK5vWck=\", false, function() {\n        return [\n            useHistory\n        ];\n    });\n    function useCanUndo() {\n        _s21();\n        const room = useRoom();\n        const subscribe = room.events.history.subscribe;\n        const canUndo = room.history.canUndo;\n        return useSyncExternalStore(subscribe, canUndo, canUndo);\n    }\n    _s21(useCanUndo, \"ZXwyxKFUfDzqu7nFjEjRuhwOrXw=\", false, function() {\n        return [\n            useRoom,\n            useSyncExternalStore\n        ];\n    });\n    function useCanRedo() {\n        _s22();\n        const room = useRoom();\n        const subscribe = room.events.history.subscribe;\n        const canRedo = room.history.canRedo;\n        return useSyncExternalStore(subscribe, canRedo, canRedo);\n    }\n    _s22(useCanRedo, \"ZXwyxKFUfDzqu7nFjEjRuhwOrXw=\", false, function() {\n        return [\n            useRoom,\n            useSyncExternalStore\n        ];\n    });\n    function useBatch() {\n        _s23();\n        return useRoom().batch;\n    }\n    _s23(useBatch, \"FxiKrJOMJJNhaRQQz0EOlEBhEog=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useLegacyKey(key) {\n        _s24();\n        const room = useRoom();\n        const rootOrNull = useMutableStorageRoot();\n        const rerender = useRerender();\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            if (rootOrNull === null) {\n                return;\n            }\n            const root = rootOrNull;\n            let unsubCurr;\n            let curr = root.get(key);\n            function subscribeToCurr() {\n                unsubCurr = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.isLiveNode)(curr) ? room.subscribe(curr, rerender) : void 0;\n            }\n            function onRootChange() {\n                const newValue = root.get(key);\n                if (newValue !== curr) {\n                    unsubCurr === null || unsubCurr === void 0 ? void 0 : unsubCurr();\n                    curr = newValue;\n                    subscribeToCurr();\n                    rerender();\n                }\n            }\n            subscribeToCurr();\n            rerender();\n            const unsubscribeRoot = room.subscribe(root, onRootChange);\n            return ()=>{\n                unsubscribeRoot();\n                unsubCurr === null || unsubCurr === void 0 ? void 0 : unsubCurr();\n            };\n        }, [\n            rootOrNull,\n            room,\n            key,\n            rerender\n        ]);\n        if (rootOrNull === null) {\n            return null;\n        } else {\n            return rootOrNull.get(key);\n        }\n    }\n    _s24(useLegacyKey, \"Jcr1Y5ArKo4MfMC3Yie4xsFig0A=\", false, function() {\n        return [\n            useRoom,\n            useMutableStorageRoot,\n            useRerender\n        ];\n    });\n    function useStorage(selector, isEqual) {\n        _s25();\n        const room = useRoom();\n        const rootOrNull = useMutableStorageRoot();\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootOrNull2)=>rootOrNull2 !== null ? selector(rootOrNull2) : null, [\n            selector\n        ]);\n        const subscribe = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((onStoreChange)=>rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, {\n                isDeep: true\n            }) : noop, [\n            room,\n            rootOrNull\n        ]);\n        const getSnapshot = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n            if (rootOrNull === null) {\n                return null;\n            } else {\n                const root = rootOrNull;\n                const imm = root.toImmutable();\n                return imm;\n            }\n        }, [\n            rootOrNull\n        ]);\n        const getServerSnapshot = alwaysNull;\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(subscribe, getSnapshot, getServerSnapshot, wrappedSelector, isEqual);\n    }\n    _s25(useStorage, \"PXpsUr6PIoQYzpsS0/PzhVn9wXk=\", false, function() {\n        return [\n            useRoom,\n            useMutableStorageRoot,\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function ensureNotServerSide() {\n        if (typeof window === \"undefined\") {\n            throw new Error(\"You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr\");\n        }\n    }\n    function useSuspendUntilStorageLoaded() {\n        _s26();\n        const room = useRoom();\n        if (room.getStorageSnapshot() !== null) {\n            return;\n        }\n        ensureNotServerSide();\n        throw new Promise((res)=>{\n            room.events.storageDidLoad.subscribeOnce(()=>res());\n        });\n    }\n    _s26(useSuspendUntilStorageLoaded, \"5S+JyCCayKN2MtiKPOSRKS71F0s=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useSuspendUntilPresenceLoaded() {\n        _s27();\n        const room = useRoom();\n        if (room.getSelf() !== null) {\n            return;\n        }\n        ensureNotServerSide();\n        throw new Promise((res)=>{\n            room.events.self.subscribeOnce(()=>res());\n            room.events.status.subscribeOnce(()=>res());\n        });\n    }\n    _s27(useSuspendUntilPresenceLoaded, \"5S+JyCCayKN2MtiKPOSRKS71F0s=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useMutation(callback, deps) {\n        _s28();\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n            return function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                return(// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                room.batch(()=>// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    callback(makeMutationContext(room), ...args)));\n            };\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            room,\n            ...deps\n        ]);\n    }\n    _s28(useMutation, \"UIS+w5CDyOyk6Qsa0iFAjGNrJxA=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useStorageSuspense(selector, isEqual) {\n        _s29();\n        useSuspendUntilStorageLoaded();\n        return useStorage(selector, isEqual);\n    }\n    _s29(useStorageSuspense, \"ufHq6RVDBh54qc/BvISf00FLxV0=\", false, function() {\n        return [\n            useSuspendUntilStorageLoaded,\n            useStorage\n        ];\n    });\n    function useSelfSuspense(selector, isEqual) {\n        _s30();\n        useSuspendUntilPresenceLoaded();\n        return useSelf(selector, isEqual);\n    }\n    _s30(useSelfSuspense, \"BgLte48ji+6JvKhVuqCKetBzjDw=\", false, function() {\n        return [\n            useSuspendUntilPresenceLoaded,\n            useSelf\n        ];\n    });\n    function useOthersSuspense(selector, isEqual) {\n        _s31();\n        useSuspendUntilPresenceLoaded();\n        return useOthers(selector, isEqual);\n    }\n    _s31(useOthersSuspense, \"tgwOdB3IIxS+X2oeFCV6cWMZDcg=\", false, function() {\n        return [\n            useSuspendUntilPresenceLoaded,\n            useOthers\n        ];\n    });\n    function useOthersConnectionIdsSuspense() {\n        _s32();\n        useSuspendUntilPresenceLoaded();\n        return useOthersConnectionIds();\n    }\n    _s32(useOthersConnectionIdsSuspense, \"BffsyqAH7fc+aZC9vagFs5jiTu4=\", false, function() {\n        return [\n            useSuspendUntilPresenceLoaded,\n            useOthersConnectionIds\n        ];\n    });\n    function useOthersMappedSuspense(itemSelector, itemIsEqual) {\n        _s33();\n        useSuspendUntilPresenceLoaded();\n        return useOthersMapped(itemSelector, itemIsEqual);\n    }\n    _s33(useOthersMappedSuspense, \"J+5f7Iz6l6KRz7hpbMcA7i42zPc=\", false, function() {\n        return [\n            useSuspendUntilPresenceLoaded,\n            useOthersMapped\n        ];\n    });\n    function useOtherSuspense(connectionId, selector, isEqual) {\n        _s34();\n        useSuspendUntilPresenceLoaded();\n        return useOther(connectionId, selector, isEqual);\n    }\n    _s34(useOtherSuspense, \"sSBwliR/JAo6HptIb+i+vJMr9hk=\", false, function() {\n        return [\n            useSuspendUntilPresenceLoaded,\n            useOther\n        ];\n    });\n    function useLegacyKeySuspense(key) {\n        _s35();\n        useSuspendUntilStorageLoaded();\n        return useLegacyKey(key);\n    }\n    _s35(useLegacyKeySuspense, \"yueVrdGi24iMN//WrvZxeaFAsDg=\", false, function() {\n        return [\n            useSuspendUntilStorageLoaded,\n            useLegacyKey\n        ];\n    });\n    const store = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].cacheStore;\n    function onMutationFailure(innerError, optimisticUpdateId, createPublicError) {\n        store.set((state)=>({\n                ...state,\n                optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n            }));\n        if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.CommentsApiError) {\n            const error = handleApiError(innerError);\n            commentsErrorEventSource.notify(createPublicError(error));\n            return;\n        }\n        if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.NotificationsApiError) {\n            handleApiError(innerError);\n            return;\n        }\n        throw innerError;\n    }\n    const subscribersByQuery = /* @__PURE__ */ new Map();\n    const requestsByQuery = /* @__PURE__ */ new Map();\n    const poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(refreshThreadsAndNotifications);\n    async function refreshThreadsAndNotifications() {\n        const requests = [];\n        client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].getRoomIds().map((roomId)=>{\n            const room = client.getRoom(roomId);\n            if (room === null) return;\n            requests.push(getThreadsUpdates(room.id));\n        });\n        await Promise.allSettled(requests);\n    }\n    function incrementQuerySubscribers(queryKey) {\n        var _subscribersByQuery_get;\n        const subscribers = (_subscribersByQuery_get = subscribersByQuery.get(queryKey)) !== null && _subscribersByQuery_get !== void 0 ? _subscribersByQuery_get : 0;\n        subscribersByQuery.set(queryKey, subscribers + 1);\n        poller.start(POLLING_INTERVAL);\n    }\n    function decrementQuerySubscribers(queryKey) {\n        const subscribers = subscribersByQuery.get(queryKey);\n        if (subscribers === void 0 || subscribers <= 0) {\n            _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn('Internal unexpected behavior. Cannot decrease subscriber count for query \"'.concat(queryKey, '\"'));\n            return;\n        }\n        subscribersByQuery.set(queryKey, subscribers - 1);\n        let totalSubscribers = 0;\n        for (const subscribers2 of subscribersByQuery.values()){\n            totalSubscribers += subscribers2;\n        }\n        if (totalSubscribers <= 0) {\n            poller.stop();\n        }\n    }\n    async function getThreadsAndInboxNotifications(room, queryKey, options2) {\n        let { retryCount } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {\n            retryCount: 0\n        };\n        const existingRequest = requestsByQuery.get(queryKey);\n        if (existingRequest !== void 0) return existingRequest;\n        const request = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.getThreads(options2);\n        requestsByQuery.set(queryKey, request);\n        store.setQueryState(queryKey, {\n            isLoading: true\n        });\n        try {\n            const result = await request;\n            store.updateThreadsAndNotifications(result.threads, result.inboxNotifications, result.deletedThreads, result.deletedInboxNotifications, queryKey);\n            const lastRequestedAt = lastRequestedAtByRoom.get(room.id);\n            if (lastRequestedAt === void 0 || lastRequestedAt > result.meta.requestedAt) {\n                lastRequestedAtByRoom.set(room.id, result.meta.requestedAt);\n            }\n            poller.start(POLLING_INTERVAL);\n        } catch (err) {\n            requestsByQuery.delete(queryKey);\n            retryError(()=>{\n                void getThreadsAndInboxNotifications(room, queryKey, options2, {\n                    retryCount: retryCount + 1\n                });\n            }, retryCount);\n            store.setQueryState(queryKey, {\n                isLoading: false,\n                error: err\n            });\n            return;\n        }\n    }\n    const DEFAULT_DEDUPING_INTERVAL = 2e3;\n    const lastRequestedAtByRoom = /* @__PURE__ */ new Map();\n    const requestStatusByRoom = /* @__PURE__ */ new Map();\n    async function getThreadsUpdates(roomId) {\n        const room = client.getRoom(roomId);\n        if (room === null) return;\n        const since = lastRequestedAtByRoom.get(room.id);\n        if (since === void 0) return;\n        var _requestStatusByRoom_get;\n        const isFetchingThreadsUpdates = (_requestStatusByRoom_get = requestStatusByRoom.get(room.id)) !== null && _requestStatusByRoom_get !== void 0 ? _requestStatusByRoom_get : false;\n        if (isFetchingThreadsUpdates === true) return;\n        try {\n            requestStatusByRoom.set(room.id, true);\n            const updates = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.getThreads({\n                since\n            });\n            setTimeout(()=>{\n                requestStatusByRoom.set(room.id, false);\n            }, DEFAULT_DEDUPING_INTERVAL);\n            store.updateThreadsAndNotifications(updates.threads, updates.inboxNotifications, updates.deletedThreads, updates.deletedInboxNotifications);\n            lastRequestedAtByRoom.set(room.id, updates.meta.requestedAt);\n        } catch (err) {\n            requestStatusByRoom.set(room.id, false);\n            return;\n        }\n    }\n    function useThreads() {\n        let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n            query: {\n                metadata: {}\n            }\n        };\n        _s36();\n        const room = useRoom();\n        const queryKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>generateQueryKey(room.id, options2.query), [\n            room,\n            options2\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            void getThreadsAndInboxNotifications(room, queryKey, options2);\n            incrementQuerySubscribers(queryKey);\n            return ()=>decrementQuerySubscribers(queryKey);\n        }, [\n            room,\n            queryKey\n        ]);\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state)=>{\n            const query = state.queries[queryKey];\n            if (query === void 0 || query.isLoading) {\n                return {\n                    isLoading: true\n                };\n            }\n            return {\n                threads: selectedThreads(room.id, state, options2),\n                isLoading: false,\n                error: query.error\n            };\n        }, [\n            room,\n            queryKey\n        ]);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n    }\n    _s36(useThreads, \"G6uFBqHq3v0cH/CtCgAldqEte4g=\", false, function() {\n        return [\n            useRoom,\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function useThreadsSuspense() {\n        let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n            query: {\n                metadata: {}\n            }\n        };\n        _s37();\n        const room = useRoom();\n        const queryKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>generateQueryKey(room.id, options2 === null || options2 === void 0 ? void 0 : options2.query), [\n            room,\n            options2\n        ]);\n        const query = store.get().queries[queryKey];\n        if (query === void 0 || query.isLoading) {\n            throw getThreadsAndInboxNotifications(room, queryKey, options2);\n        }\n        if (query.error) {\n            throw query.error;\n        }\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state)=>{\n            return {\n                threads: selectedThreads(room.id, state, options2),\n                isLoading: false\n            };\n        }, [\n            room,\n            queryKey\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            incrementQuerySubscribers(queryKey);\n            return ()=>{\n                decrementQuerySubscribers(queryKey);\n            };\n        }, [\n            queryKey\n        ]);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n    }\n    _s37(useThreadsSuspense, \"2laqXnRB2GJvhhiUjvUV7KPFObs=\", false, function() {\n        return [\n            useRoom,\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function useCreateThread() {\n        _s38();\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((options2)=>{\n            const body = options2.body;\n            const metadata = \"metadata\" in options2 ? options2.metadata : {};\n            const threadId = createThreadId();\n            const commentId = createCommentId();\n            const createdAt = /* @__PURE__ */ new Date();\n            const newComment = {\n                id: commentId,\n                threadId,\n                roomId: room.id,\n                createdAt,\n                type: \"comment\",\n                userId: getCurrentUserId(room),\n                body,\n                reactions: []\n            };\n            const newThread = {\n                id: threadId,\n                type: \"thread\",\n                createdAt,\n                updatedAt: createdAt,\n                roomId: room.id,\n                metadata,\n                comments: [\n                    newComment\n                ]\n            };\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"create-thread\",\n                thread: newThread,\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.createThread({\n                threadId,\n                commentId,\n                body,\n                metadata\n            }).then((thread)=>{\n                store.set((state)=>({\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: thread\n                        },\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (err2)=>new CreateThreadError(err2, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        body,\n                        metadata\n                    })));\n            return newThread;\n        }, [\n            room\n        ]);\n    }\n    _s38(useCreateThread, \"mRjfZCZLIOt9iOyXufGWtKsUM38=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useEditThreadMetadata() {\n        _s39();\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((options2)=>{\n            if (!(\"metadata\" in options2)) {\n                return;\n            }\n            const threadId = options2.threadId;\n            const metadata = options2.metadata;\n            const updatedAt = /* @__PURE__ */ new Date();\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"edit-thread-metadata\",\n                metadata,\n                id: optimisticUpdateId,\n                threadId,\n                updatedAt\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.editThreadMetadata({\n                metadata,\n                threadId\n            }).then((metadata2)=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    if (existingThread.deletedAt !== void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    if (existingThread.updatedAt && existingThread.updatedAt > updatedAt) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: {\n                                ...existingThread,\n                                metadata: {\n                                    ...existingThread.metadata,\n                                    ...metadata2\n                                }\n                            }\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new EditThreadMetadataError(error, {\n                        roomId: room.id,\n                        threadId,\n                        metadata\n                    })));\n        }, [\n            room\n        ]);\n    }\n    _s39(useEditThreadMetadata, \"mRjfZCZLIOt9iOyXufGWtKsUM38=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useAddReaction() {\n        _s40();\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((param)=>{\n            let { threadId, commentId, emoji } = param;\n            const createdAt = /* @__PURE__ */ new Date();\n            const userId = getCurrentUserId(room);\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"add-reaction\",\n                threadId,\n                commentId,\n                reaction: {\n                    emoji,\n                    userId,\n                    createdAt\n                },\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.addReaction({\n                threadId,\n                commentId,\n                emoji\n            }).then((addedReaction)=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.addReaction)(existingThread, commentId, addedReaction)\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new AddReactionError(error, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        emoji\n                    })));\n        }, [\n            room\n        ]);\n    }\n    _s40(useAddReaction, \"mRjfZCZLIOt9iOyXufGWtKsUM38=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useRemoveReaction() {\n        _s41();\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((param)=>{\n            let { threadId, commentId, emoji } = param;\n            const userId = getCurrentUserId(room);\n            const removedAt = /* @__PURE__ */ new Date();\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"remove-reaction\",\n                threadId,\n                commentId,\n                emoji,\n                userId,\n                removedAt,\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.removeReaction({\n                threadId,\n                commentId,\n                emoji\n            }).then(()=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.removeReaction)(existingThread, commentId, emoji, userId, removedAt)\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new RemoveReactionError(error, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        emoji\n                    })));\n        }, [\n            room\n        ]);\n    }\n    _s41(useRemoveReaction, \"mRjfZCZLIOt9iOyXufGWtKsUM38=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useCreateComment() {\n        _s42();\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((param)=>{\n            let { threadId, body } = param;\n            const commentId = createCommentId();\n            const createdAt = /* @__PURE__ */ new Date();\n            const comment = {\n                id: commentId,\n                threadId,\n                roomId: room.id,\n                type: \"comment\",\n                createdAt,\n                userId: getCurrentUserId(room),\n                body,\n                reactions: []\n            };\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"create-comment\",\n                comment,\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.createComment({\n                threadId,\n                commentId,\n                body\n            }).then((newComment)=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    const inboxNotification = Object.values(state.inboxNotifications).find((notification)=>notification.threadId === threadId);\n                    const updatedInboxNotifications = inboxNotification !== void 0 ? {\n                        ...state.inboxNotifications,\n                        [inboxNotification.id]: {\n                            ...inboxNotification,\n                            notifiedAt: newComment.createdAt,\n                            readAt: newComment.createdAt\n                        }\n                    } : state.inboxNotifications;\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.upsertComment)(existingThread, newComment)\n                        },\n                        inboxNotifications: updatedInboxNotifications,\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (err2)=>new CreateCommentError(err2, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        body\n                    })));\n            return comment;\n        }, [\n            room\n        ]);\n    }\n    _s42(useCreateComment, \"mRjfZCZLIOt9iOyXufGWtKsUM38=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useEditComment() {\n        _s43();\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((param)=>{\n            let { threadId, commentId, body } = param;\n            const editedAt = /* @__PURE__ */ new Date();\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            const thread = store.get().threads[threadId];\n            if (thread === void 0) {\n                _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn('Internal unexpected behavior. Cannot edit comment in thread \"'.concat(threadId, '\" because the thread does not exist in the cache.'));\n                return;\n            }\n            const comment = thread.comments.find((comment2)=>comment2.id === commentId);\n            if (comment === void 0 || comment.deletedAt !== void 0) {\n                _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn('Internal unexpected behavior. Cannot edit comment \"'.concat(commentId, '\" in thread \"').concat(threadId, '\" because the comment does not exist in the cache.'));\n                return;\n            }\n            store.pushOptimisticUpdate({\n                type: \"edit-comment\",\n                comment: {\n                    ...comment,\n                    editedAt,\n                    body\n                },\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.editComment({\n                threadId,\n                commentId,\n                body\n            }).then((editedComment)=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.upsertComment)(existingThread, editedComment)\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new EditCommentError(error, {\n                        roomId: room.id,\n                        threadId,\n                        commentId,\n                        body\n                    })));\n        }, [\n            room\n        ]);\n    }\n    _s43(useEditComment, \"mRjfZCZLIOt9iOyXufGWtKsUM38=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useDeleteComment() {\n        _s44();\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((param)=>{\n            let { threadId, commentId } = param;\n            const deletedAt = /* @__PURE__ */ new Date();\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                type: \"delete-comment\",\n                threadId,\n                commentId,\n                deletedAt,\n                id: optimisticUpdateId\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].comments.deleteComment({\n                threadId,\n                commentId\n            }).then(()=>{\n                store.set((state)=>{\n                    const existingThread = state.threads[threadId];\n                    const updatedOptimisticUpdates = state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId);\n                    if (existingThread === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: updatedOptimisticUpdates\n                        };\n                    }\n                    return {\n                        ...state,\n                        threads: {\n                            ...state.threads,\n                            [threadId]: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.deleteComment)(existingThread, commentId, deletedAt)\n                        },\n                        optimisticUpdates: updatedOptimisticUpdates\n                    };\n                });\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new DeleteCommentError(error, {\n                        roomId: room.id,\n                        threadId,\n                        commentId\n                    })));\n        }, [\n            room\n        ]);\n    }\n    _s44(useDeleteComment, \"mRjfZCZLIOt9iOyXufGWtKsUM38=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    const resolveMentionSuggestions = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].resolveMentionSuggestions;\n    const mentionSuggestionsCache = /* @__PURE__ */ new Map();\n    function useMentionSuggestions(search) {\n        _s45();\n        const room = useRoom();\n        const [mentionSuggestions, setMentionSuggestions] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n        const lastInvokedAt = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            if (search === void 0 || !resolveMentionSuggestions) {\n                return;\n            }\n            const resolveMentionSuggestionsArgs = {\n                text: search,\n                roomId: room.id\n            };\n            const mentionSuggestionsCacheKey = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(resolveMentionSuggestionsArgs);\n            let debounceTimeout;\n            let isCanceled = false;\n            const getMentionSuggestions = async ()=>{\n                try {\n                    lastInvokedAt.current = performance.now();\n                    const mentionSuggestions2 = await resolveMentionSuggestions(resolveMentionSuggestionsArgs);\n                    if (!isCanceled) {\n                        setMentionSuggestions(mentionSuggestions2);\n                        mentionSuggestionsCache.set(mentionSuggestionsCacheKey, mentionSuggestions2);\n                    }\n                } catch (error) {\n                    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.error(error === null || error === void 0 ? void 0 : error.message);\n                }\n            };\n            if (mentionSuggestionsCache.has(mentionSuggestionsCacheKey)) {\n                setMentionSuggestions(mentionSuggestionsCache.get(mentionSuggestionsCacheKey));\n            } else if (!lastInvokedAt.current || Math.abs(performance.now() - lastInvokedAt.current) > MENTION_SUGGESTIONS_DEBOUNCE) {\n                void getMentionSuggestions();\n            } else {\n                debounceTimeout = window.setTimeout(()=>{\n                    void getMentionSuggestions();\n                }, MENTION_SUGGESTIONS_DEBOUNCE);\n            }\n            return ()=>{\n                isCanceled = true;\n                window.clearTimeout(debounceTimeout);\n            };\n        }, [\n            room.id,\n            search\n        ]);\n        return mentionSuggestions;\n    }\n    _s45(useMentionSuggestions, \"V8/Qrpmui6EX5Hemh5oCmIbZLEk=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useThreadSubscription(threadId) {\n        _s46();\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state)=>{\n            const inboxNotification = selectedInboxNotifications(state).find((inboxNotification2)=>inboxNotification2.threadId === threadId);\n            const thread = state.threads[threadId];\n            if (inboxNotification === void 0 || thread === void 0) {\n                return {\n                    status: \"not-subscribed\"\n                };\n            }\n            return {\n                status: \"subscribed\",\n                unreadSince: inboxNotification.readAt\n            };\n        }, [\n            threadId\n        ]);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n    }\n    _s46(useThreadSubscription, \"T1CTvAIbYChkHXJPN4Qum49Zol0=\", false, function() {\n        return [\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function useMarkThreadAsRead() {\n        _s47();\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((threadId)=>{\n            const inboxNotification = Object.values(store.get().inboxNotifications).find((inboxNotification2)=>inboxNotification2.threadId === threadId);\n            if (!inboxNotification) return;\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            const now = /* @__PURE__ */ new Date();\n            store.pushOptimisticUpdate({\n                type: \"mark-inbox-notification-as-read\",\n                id: optimisticUpdateId,\n                inboxNotificationId: inboxNotification.id,\n                readAt: now\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications.markInboxNotificationAsRead(inboxNotification.id).then(()=>{\n                store.set((state)=>({\n                        ...state,\n                        inboxNotifications: {\n                            ...state.inboxNotifications,\n                            [inboxNotification.id]: {\n                                ...inboxNotification,\n                                readAt: now\n                            }\n                        },\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            }, (err)=>{\n                onMutationFailure(err, optimisticUpdateId, (error)=>new MarkInboxNotificationAsReadError(error, {\n                        inboxNotificationId: inboxNotification.id\n                    }));\n                return;\n            });\n        }, [\n            room\n        ]);\n    }\n    _s47(useMarkThreadAsRead, \"mRjfZCZLIOt9iOyXufGWtKsUM38=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function makeNotificationSettingsQueryKey(roomId) {\n        return \"\".concat(roomId, \":NOTIFICATION_SETTINGS\");\n    }\n    async function getInboxNotificationSettings(room, queryKey) {\n        let { retryCount } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {\n            retryCount: 0\n        };\n        const existingRequest = requestsByQuery.get(queryKey);\n        if (existingRequest !== void 0) return existingRequest;\n        try {\n            const request = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications.getRoomNotificationSettings();\n            requestsByQuery.set(queryKey, request);\n            store.setQueryState(queryKey, {\n                isLoading: true\n            });\n            const settings = await request;\n            store.updateRoomInboxNotificationSettings(room.id, settings, queryKey);\n        } catch (err) {\n            requestsByQuery.delete(queryKey);\n            retryError(()=>{\n                void getInboxNotificationSettings(room, queryKey, {\n                    retryCount: retryCount + 1\n                });\n            }, retryCount);\n            store.setQueryState(queryKey, {\n                isLoading: false,\n                error: err\n            });\n            return;\n        }\n    }\n    function useRoomNotificationSettings() {\n        _s48();\n        const room = useRoom();\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            const queryKey = makeNotificationSettingsQueryKey(room.id);\n            void getInboxNotificationSettings(room, queryKey);\n        }, [\n            room\n        ]);\n        const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state)=>{\n            const query = state.queries[makeNotificationSettingsQueryKey(room.id)];\n            if (query === void 0 || query.isLoading) {\n                return {\n                    isLoading: true\n                };\n            }\n            if (query.error !== void 0) {\n                return {\n                    isLoading: false,\n                    error: query.error\n                };\n            }\n            return {\n                isLoading: false,\n                settings: selectNotificationSettings(room.id, state)\n            };\n        }, [\n            room\n        ]);\n        const settings = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n        return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n            return [\n                settings,\n                updateRoomNotificationSettings\n            ];\n        }, [\n            settings,\n            updateRoomNotificationSettings\n        ]);\n    }\n    _s48(useRoomNotificationSettings, \"4bhS3qOE141/XwGrAedfJ0oBkFA=\", false, function() {\n        return [\n            useRoom,\n            useUpdateRoomNotificationSettings,\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function useRoomNotificationSettingsSuspense() {\n        _s49();\n        const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n        const room = useRoom();\n        const queryKey = makeNotificationSettingsQueryKey(room.id);\n        const query = store.get().queries[queryKey];\n        if (query === void 0 || query.isLoading) {\n            throw getInboxNotificationSettings(room, queryKey);\n        }\n        if (query.error) {\n            throw query.error;\n        }\n        const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((state)=>{\n            return {\n                isLoading: false,\n                settings: selectNotificationSettings(room.id, state)\n            };\n        }, [\n            room\n        ]);\n        const settings = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n        return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n            return [\n                settings,\n                updateRoomNotificationSettings\n            ];\n        }, [\n            settings,\n            updateRoomNotificationSettings\n        ]);\n    }\n    _s49(useRoomNotificationSettingsSuspense, \"tgoWlwFLZ/GAzXW8VD7Pmwo78Y8=\", false, function() {\n        return [\n            useUpdateRoomNotificationSettings,\n            useRoom,\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function useUpdateRoomNotificationSettings() {\n        _s50();\n        const room = useRoom();\n        return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((settings)=>{\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            store.pushOptimisticUpdate({\n                id: optimisticUpdateId,\n                type: \"update-notification-settings\",\n                roomId: room.id,\n                settings\n            });\n            room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications.updateRoomNotificationSettings(settings).then((settings2)=>{\n                store.set((state)=>({\n                        ...state,\n                        notificationSettings: {\n                            [room.id]: settings2\n                        },\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            }, (err)=>onMutationFailure(err, optimisticUpdateId, (error)=>new UpdateNotificationSettingsError(error, {\n                        roomId: room.id\n                    })));\n        }, [\n            room\n        ]);\n    }\n    _s50(useUpdateRoomNotificationSettings, \"mRjfZCZLIOt9iOyXufGWtKsUM38=\", false, function() {\n        return [\n            useRoom\n        ];\n    });\n    function useCurrentUserId() {\n        _s51();\n        return useSelf((user)=>typeof user.id === \"string\" ? user.id : null);\n    }\n    _s51(useCurrentUserId, \"B0yOKmJ7foLxXH3H5FyDPbhhYRc=\", false, function() {\n        return [\n            useSelf\n        ];\n    });\n    const bundle = {\n        RoomContext,\n        RoomProvider: RoomProviderOuter,\n        useRoom,\n        useStatus,\n        useBatch,\n        useBroadcastEvent,\n        useOthersListener,\n        useLostConnectionListener,\n        useErrorListener,\n        useEventListener,\n        useHistory,\n        useUndo,\n        useRedo,\n        useCanRedo,\n        useCanUndo,\n        // These are just aliases. The passed-in key will define their return values.\n        useList: useLegacyKey,\n        useMap: useLegacyKey,\n        useObject: useLegacyKey,\n        useStorageRoot,\n        useStorage,\n        useSelf,\n        useMyPresence,\n        useUpdateMyPresence,\n        useOthers,\n        useOthersMapped,\n        useOthersConnectionIds,\n        useOther,\n        useMutation,\n        useThreads,\n        useCreateThread,\n        useEditThreadMetadata,\n        useCreateComment,\n        useEditComment,\n        useDeleteComment,\n        useAddReaction,\n        useRemoveReaction,\n        useMarkThreadAsRead,\n        useThreadSubscription,\n        useRoomNotificationSettings,\n        useUpdateRoomNotificationSettings,\n        ...shared,\n        suspense: {\n            RoomContext,\n            RoomProvider: RoomProviderOuter,\n            useRoom,\n            useStatus,\n            useBatch,\n            useBroadcastEvent,\n            useOthersListener,\n            useLostConnectionListener,\n            useErrorListener,\n            useEventListener,\n            useHistory,\n            useUndo,\n            useRedo,\n            useCanRedo,\n            useCanUndo,\n            // Legacy hooks\n            useList: useLegacyKeySuspense,\n            useMap: useLegacyKeySuspense,\n            useObject: useLegacyKeySuspense,\n            useStorageRoot,\n            useStorage: useStorageSuspense,\n            useSelf: useSelfSuspense,\n            useMyPresence,\n            useUpdateMyPresence,\n            useOthers: useOthersSuspense,\n            useOthersMapped: useOthersMappedSuspense,\n            useOthersConnectionIds: useOthersConnectionIdsSuspense,\n            useOther: useOtherSuspense,\n            useMutation,\n            useThreads: useThreadsSuspense,\n            useCreateThread,\n            useEditThreadMetadata,\n            useCreateComment,\n            useEditComment,\n            useDeleteComment,\n            useAddReaction,\n            useRemoveReaction,\n            useMarkThreadAsRead,\n            useThreadSubscription,\n            useRoomNotificationSettings: useRoomNotificationSettingsSuspense,\n            useUpdateRoomNotificationSettings,\n            ...shared.suspense\n        },\n        [_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal]: {\n            useCurrentUserId,\n            hasResolveMentionSuggestions: resolveMentionSuggestions !== void 0,\n            useMentionSuggestions\n        }\n    };\n    return Object.defineProperty(bundle, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal, {\n        enumerable: false\n    });\n}\nfunction getCurrentUserId(room) {\n    const self = room.getSelf();\n    if (self === null || self.id === void 0) {\n        return \"anonymous\";\n    } else {\n        return self.id;\n    }\n}\nfunction handleApiError(err) {\n    var _err_details;\n    const message = \"Request failed with status \".concat(err.status, \": \").concat(err.message);\n    if (((_err_details = err.details) === null || _err_details === void 0 ? void 0 : _err_details.error) === \"FORBIDDEN\") {\n        const detailedMessage = [\n            message,\n            err.details.suggestion,\n            err.details.docs\n        ].filter(Boolean).join(\"\\n\");\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.error(detailedMessage);\n    }\n    return new Error(message);\n}\nfunction generateQueryKey(roomId, options) {\n    return \"\".concat(roomId, \"-\").concat((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(options !== null && options !== void 0 ? options : {}));\n}\n// src/shared.ts\nfunction useSharedContextBundle() {\n    _s6();\n    const roomContextBundle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ContextBundle);\n    const liveblocksContextBundle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ContextBundle2);\n    if (roomContextBundle !== null) {\n        return roomContextBundle;\n    } else if (liveblocksContextBundle !== null) {\n        return liveblocksContextBundle;\n    } else {\n        throw new Error(\"LiveblocksProvider or RoomProvider are missing from the React tree.\");\n    }\n}\n_s6(useSharedContextBundle, \"w5/6GR5bUdoxIyEuUNjwZNV+FVA=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useContext,\n        react__WEBPACK_IMPORTED_MODULE_0__.useContext\n    ];\n});\nfunction createSharedContext(client) {\n    var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$();\n    const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].usersStore;\n    const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].roomsInfoStore;\n    function useUser(userId) {\n        _s();\n        const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>usersStore.getState(userId), [\n            userId\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void usersStore.get(userId);\n        }, [\n            userId\n        ]);\n        const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(usersStore.subscribe, getUserState, getUserState);\n        return state ? {\n            ...state,\n            user: state.data\n        } : {\n            isLoading: true\n        };\n    }\n    _s(useUser, \"sVqI9NltDLjei9wo26pdeNqsRNM=\", false, function() {\n        return [\n            react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n            react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n            use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore\n        ];\n    });\n    function useUserSuspense(userId) {\n        _s1();\n        const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>usersStore.getState(userId), [\n            userId\n        ]);\n        const userState = getUserState();\n        if (!userState || userState.isLoading) {\n            throw usersStore.get(userId);\n        }\n        if (userState.error) {\n            throw userState.error;\n        }\n        const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(usersStore.subscribe, getUserState, getUserState);\n        return {\n            ...state,\n            user: state === null || state === void 0 ? void 0 : state.data\n        };\n    }\n    _s1(useUserSuspense, \"FpJK9WoQkqRIDg/NyTH3Qtg9QUM=\", false, function() {\n        return [\n            react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n            use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore\n        ];\n    });\n    function useRoomInfo(roomId) {\n        _s2();\n        const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>roomsInfoStore.getState(roomId), [\n            roomId\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void roomsInfoStore.get(roomId);\n        }, [\n            roomId\n        ]);\n        const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(roomsInfoStore.subscribe, getRoomInfoState, getRoomInfoState);\n        return state ? {\n            ...state,\n            info: state.data\n        } : {\n            isLoading: true\n        };\n    }\n    _s2(useRoomInfo, \"IkgqCYSK1lv+wzRJbOYeEQI5Dbg=\", false, function() {\n        return [\n            react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n            react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n            use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore\n        ];\n    });\n    function useRoomInfoSuspense(roomId) {\n        _s3();\n        const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>roomsInfoStore.getState(roomId), [\n            roomId\n        ]);\n        const roomInfoState = getRoomInfoState();\n        if (!roomInfoState || roomInfoState.isLoading) {\n            throw roomsInfoStore.get(roomId);\n        }\n        if (roomInfoState.error) {\n            throw roomInfoState.error;\n        }\n        const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(roomsInfoStore.subscribe, getRoomInfoState, getRoomInfoState);\n        return {\n            ...state,\n            info: state === null || state === void 0 ? void 0 : state.data\n        };\n    }\n    _s3(useRoomInfoSuspense, \"kBBXNmaJlelNxojwfiz2Z1Qs9tc=\", false, function() {\n        return [\n            react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n            use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore\n        ];\n    });\n    const bundle = {\n        useUser,\n        useRoomInfo,\n        suspense: {\n            useUser: useUserSuspense,\n            useRoomInfo: useRoomInfoSuspense\n        }\n    };\n    return bundle;\n}\n// src/liveblocks.tsx\nvar ContextBundle2 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction useLiveblocksContextBundle() {\n    _s7();\n    const bundle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ContextBundle2);\n    if (bundle === null) {\n        throw new Error(\"LiveblocksProvider is missing from the React tree.\");\n    }\n    return bundle;\n}\n_s7(useLiveblocksContextBundle, \"cA/KZ22VG6cdjTyKBHeIa/y8DC8=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useContext\n    ];\n});\nvar POLLING_INTERVAL2 = 60 * 1e3;\nvar INBOX_NOTIFICATIONS_QUERY = \"INBOX_NOTIFICATIONS\";\nfunction createLiveblocksContext(client) {\n    var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$();\n    const shared = createSharedContext(client);\n    const store = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].cacheStore;\n    const notifications = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].notifications;\n    function LiveblocksProvider(props) {\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextBundle2.Provider, {\n            value: bundle\n        }, props.children);\n    }\n    let fetchInboxNotificationsRequest = null;\n    let inboxNotificationsSubscribers = 0;\n    let lastRequestedAt;\n    const poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(refreshThreadsAndNotifications);\n    function refreshThreadsAndNotifications() {\n        return notifications.getInboxNotifications({\n            since: lastRequestedAt\n        }).then((result)=>{\n            lastRequestedAt = result.meta.requestedAt;\n            store.updateThreadsAndNotifications(result.threads, result.inboxNotifications, result.deletedThreads, result.deletedInboxNotifications, INBOX_NOTIFICATIONS_QUERY);\n        }, ()=>{});\n    }\n    function incrementInboxNotificationsSubscribers() {\n        inboxNotificationsSubscribers++;\n        poller.start(POLLING_INTERVAL2);\n    }\n    function decrementInboxNotificationsSubscribers() {\n        if (inboxNotificationsSubscribers <= 0) {\n            console.warn('Internal unexpected behavior. Cannot decrease subscriber count for query \"'.concat(INBOX_NOTIFICATIONS_QUERY, '\"'));\n            return;\n        }\n        inboxNotificationsSubscribers--;\n        if (inboxNotificationsSubscribers <= 0) {\n            poller.stop();\n        }\n    }\n    async function fetchInboxNotifications() {\n        let { retryCount } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n            retryCount: 0\n        };\n        if (fetchInboxNotificationsRequest !== null) {\n            return fetchInboxNotificationsRequest;\n        }\n        store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {\n            isLoading: true\n        });\n        try {\n            fetchInboxNotificationsRequest = notifications.getInboxNotifications();\n            const result = await fetchInboxNotificationsRequest;\n            store.updateThreadsAndNotifications(result.threads, result.inboxNotifications, result.deletedThreads, result.deletedInboxNotifications, INBOX_NOTIFICATIONS_QUERY);\n            if (lastRequestedAt === void 0 || lastRequestedAt > result.meta.requestedAt) {\n                lastRequestedAt = result.meta.requestedAt;\n            }\n            poller.start(POLLING_INTERVAL2);\n        } catch (er) {\n            fetchInboxNotificationsRequest = null;\n            retryError(()=>{\n                void fetchInboxNotifications({\n                    retryCount: retryCount + 1\n                });\n            }, retryCount);\n            store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {\n                isLoading: false,\n                error: er\n            });\n        }\n        return;\n    }\n    function useInboxNotificationsSelectorCallback(state) {\n        const query = state.queries[INBOX_NOTIFICATIONS_QUERY];\n        if (query === void 0 || query.isLoading) {\n            return {\n                isLoading: true\n            };\n        }\n        if (query.error !== void 0) {\n            return {\n                error: query.error,\n                isLoading: false\n            };\n        }\n        return {\n            inboxNotifications: selectedInboxNotifications(state),\n            isLoading: false\n        };\n    }\n    function useInboxNotifications() {\n        _s();\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void fetchInboxNotifications();\n            incrementInboxNotificationsSubscribers();\n            return ()=>decrementInboxNotificationsSubscribers();\n        }, []);\n        const result = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, useInboxNotificationsSelectorCallback);\n        return result;\n    }\n    _s(useInboxNotifications, \"xHCtFR2Nmox2LgfjCtk7aMhTC2A=\", false, function() {\n        return [\n            react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function useInboxNotificationsSuspenseSelector(state) {\n        return {\n            inboxNotifications: selectedInboxNotifications(state),\n            isLoading: false\n        };\n    }\n    function useInboxNotificationsSuspense() {\n        _s1();\n        const query = store.get().queries[INBOX_NOTIFICATIONS_QUERY];\n        if (query === void 0 || query.isLoading) {\n            throw fetchInboxNotifications();\n        }\n        if (query.error !== void 0) {\n            throw query.error;\n        }\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            incrementInboxNotificationsSubscribers();\n            return ()=>{\n                decrementInboxNotificationsSubscribers();\n            };\n        }, []);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, useInboxNotificationsSuspenseSelector);\n    }\n    _s1(useInboxNotificationsSuspense, \"LRrZ0V8Vqgl48ynNB0eVX/C3uRE=\", false, function() {\n        return [\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function selectUnreadInboxNotificationsCount(state) {\n        let count = 0;\n        for (const notification of selectedInboxNotifications(state)){\n            if (notification.readAt === null || notification.readAt < notification.notifiedAt) {\n                count++;\n            }\n        }\n        return count;\n    }\n    function useUnreadInboxNotificationsCountSelector(state) {\n        const query = state.queries[INBOX_NOTIFICATIONS_QUERY];\n        if (query === void 0 || query.isLoading) {\n            return {\n                isLoading: true\n            };\n        }\n        if (query.error !== void 0) {\n            return {\n                error: query.error,\n                isLoading: false\n            };\n        }\n        return {\n            isLoading: false,\n            count: selectUnreadInboxNotificationsCount(state)\n        };\n    }\n    function useUnreadInboxNotificationsCount() {\n        _s2();\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            void fetchInboxNotifications();\n            incrementInboxNotificationsSubscribers();\n            return ()=>decrementInboxNotificationsSubscribers();\n        }, []);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, useUnreadInboxNotificationsCountSelector);\n    }\n    _s2(useUnreadInboxNotificationsCount, \"eyfdKIY5gqyWG7PdsNJyklmRS6I=\", false, function() {\n        return [\n            react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function useUnreadInboxNotificationsCountSuspenseSelector(state) {\n        return {\n            isLoading: false,\n            count: selectUnreadInboxNotificationsCount(state)\n        };\n    }\n    function useUnreadInboxNotificationsCountSuspense() {\n        _s3();\n        const query = store.get().queries[INBOX_NOTIFICATIONS_QUERY];\n        if (query === void 0 || query.isLoading) {\n            throw fetchInboxNotifications();\n        }\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n            incrementInboxNotificationsSubscribers();\n            return ()=>{\n                decrementInboxNotificationsSubscribers();\n            };\n        }, []);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, useUnreadInboxNotificationsCountSuspenseSelector);\n    }\n    _s3(useUnreadInboxNotificationsCountSuspense, \"LRrZ0V8Vqgl48ynNB0eVX/C3uRE=\", false, function() {\n        return [\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector\n        ];\n    });\n    function useMarkInboxNotificationAsRead() {\n        _s4();\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((inboxNotificationId)=>{\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            const readAt = /* @__PURE__ */ new Date();\n            store.pushOptimisticUpdate({\n                type: \"mark-inbox-notification-as-read\",\n                id: optimisticUpdateId,\n                inboxNotificationId,\n                readAt\n            });\n            notifications.markInboxNotificationAsRead(inboxNotificationId).then(()=>{\n                store.set((state)=>{\n                    const existingNotification = state.inboxNotifications[inboxNotificationId];\n                    if (existingNotification === void 0) {\n                        return {\n                            ...state,\n                            optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                        };\n                    }\n                    return {\n                        ...state,\n                        inboxNotifications: {\n                            ...state.inboxNotifications,\n                            [inboxNotificationId]: {\n                                ...existingNotification,\n                                readAt\n                            }\n                        },\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    };\n                });\n            }, ()=>{\n                store.set((state)=>({\n                        ...state,\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            });\n        }, []);\n    }\n    _s4(useMarkInboxNotificationAsRead, \"/l41xbnc1hEMtDU/TCqUEfLtUJ0=\", false, function() {\n        return [\n            react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n        ];\n    });\n    function useMarkAllInboxNotificationsAsRead() {\n        _s5();\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n            const optimisticUpdateId = (0,nanoid__WEBPACK_IMPORTED_MODULE_4__.nanoid)();\n            const readAt = /* @__PURE__ */ new Date();\n            store.pushOptimisticUpdate({\n                type: \"mark-inbox-notifications-as-read\",\n                id: optimisticUpdateId,\n                readAt\n            });\n            notifications.markAllInboxNotificationsAsRead().then(()=>{\n                store.set((state)=>({\n                        ...state,\n                        inboxNotifications: Object.fromEntries(Array.from(Object.entries(state.inboxNotifications)).map((param)=>{\n                            let [id, inboxNotification] = param;\n                            return [\n                                id,\n                                {\n                                    ...inboxNotification,\n                                    readAt\n                                }\n                            ];\n                        })),\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            }, ()=>{\n                store.set((state)=>({\n                        ...state,\n                        optimisticUpdates: state.optimisticUpdates.filter((update)=>update.id !== optimisticUpdateId)\n                    }));\n            });\n        }, []);\n    }\n    _s5(useMarkAllInboxNotificationsAsRead, \"/l41xbnc1hEMtDU/TCqUEfLtUJ0=\", false, function() {\n        return [\n            react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n        ];\n    });\n    function useThreadFromCache(threadId) {\n        _s6();\n        const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((state)=>{\n            const thread = state.threads[threadId];\n            if (thread === void 0) {\n                throw new Error('Internal error: thread with id \"'.concat(threadId, '\" not found in cache'));\n            }\n            return thread;\n        }, [\n            threadId\n        ]);\n        return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(store.subscribe, store.get, store.get, selector);\n    }\n    _s6(useThreadFromCache, \"63CKAzLaNLpJkLWAFT9dRi2fFKw=\", false, function() {\n        return [\n            react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n            use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector\n        ];\n    });\n    const currentUserIdStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].currentUserIdStore;\n    function useCurrentUserId() {\n        _s7();\n        return (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(currentUserIdStore.subscribe, currentUserIdStore.get, currentUserIdStore.get);\n    }\n    _s7(useCurrentUserId, \"3NyOp0xpzg8DSAxW0FUtGyq/HXY=\", false, function() {\n        return [\n            use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore\n        ];\n    });\n    const bundle = {\n        LiveblocksProvider,\n        useInboxNotifications,\n        useUnreadInboxNotificationsCount,\n        useMarkInboxNotificationAsRead,\n        useMarkAllInboxNotificationsAsRead,\n        ...shared,\n        suspense: {\n            LiveblocksProvider,\n            useInboxNotifications: useInboxNotificationsSuspense,\n            useUnreadInboxNotificationsCount: useUnreadInboxNotificationsCountSuspense,\n            useMarkInboxNotificationAsRead,\n            useMarkAllInboxNotificationsAsRead,\n            ...shared.suspense\n        },\n        [_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal]: {\n            useThreadFromCache,\n            useCurrentUserId\n        }\n    };\n    return Object.defineProperty(bundle, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal, {\n        enumerable: false\n    });\n}\n// src/index.ts\n\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n //# sourceMappingURL=index.mjs.map\nvar _c;\n$RefreshReg$(_c, \"ClientSideSuspense\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsZUFBZTtBQUNnQztBQUUvQyxpQkFBaUI7QUFDakIsSUFBSUMsV0FBVztBQUNmLElBQUlDLGNBQWM7QUFDbEIsSUFBSUMsYUFBYTtBQUVqQiw2QkFBNkI7QUFDRTtBQUMvQixTQUFTRSxtQkFBbUJDLEtBQUs7O0lBQy9CLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHSiwyQ0FBYyxDQUFDO0lBQzdDQSw0Q0FBZSxDQUFDO1FBQ2RJLFdBQVc7SUFDYixHQUFHLEVBQUU7SUFDTCxPQUFPLGFBQWEsaUJBQUdKLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFO1FBQUVTLFVBQVVQLE1BQU1PLFFBQVE7SUFBQyxHQUFHTixVQUFVRCxNQUFNUSxRQUFRLEtBQUtSLE1BQU1PLFFBQVE7QUFDdEk7R0FOU1I7S0FBQUE7QUFRVCxxQkFBcUI7QUFDaUU7QUFDM0M7QUFNNUI7QUFDdUY7QUFDZ0M7QUFFdEksbURBQW1EO0FBQ087QUFDMUQsU0FBUzZCLDJCQUEyQkMsS0FBSztJQUN2QyxNQUFNQyxTQUFTSCx3RUFBc0JBLENBQUNFO0lBQ3RDLE9BQU9FLE9BQU9DLE1BQU0sQ0FBQ0YsT0FBT0csa0JBQWtCLEVBQUVDLElBQUksQ0FDbEQsdURBQXVEO0lBQ3ZELENBQUNDLEdBQUdDLElBQU1BLEVBQUVDLFVBQVUsQ0FBQ0MsT0FBTyxLQUFLSCxFQUFFRSxVQUFVLENBQUNDLE9BQU87QUFFM0Q7QUFFQSx5QkFBeUI7QUFDekIsSUFBSUMsd0JBQXdCO0FBQzVCLElBQUlDLHVCQUF1QjtBQUMzQixTQUFTQyxXQUFXQyxNQUFNLEVBQUVDLFVBQVU7SUFDcEMsSUFBSUEsY0FBY0osdUJBQ2hCO0lBQ0YsTUFBTUssVUFBVUMsS0FBS0MsR0FBRyxDQUFDLEdBQUdILGNBQWNIO0lBQzFDTyxXQUFXO1FBQ1QsS0FB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O0lBQ0Y7SUFDQSxPQUFPeFosT0FBTytaLGNBQWMsQ0FBQzNTLFFBQVF6SSx1REFBVUEsRUFBRTtRQUMvQ3FiLFlBQVk7SUFDZDtBQUNGO0FBRUEsZUFBZTtBQUMwQztBQUN6RHJjLDZEQUFXQSxDQUFDQyxVQUFVQyxhQUFhQztBQVNqQyxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9pbmRleC5tanM/Y2QzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBkZXRlY3REdXBlcyB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL3JlYWN0XCI7XG52YXIgUEtHX1ZFUlNJT04gPSBcIjEuMTAuMlwiO1xudmFyIFBLR19GT1JNQVQgPSBcImVzbVwiO1xuXG4vLyBzcmMvQ2xpZW50U2lkZVN1c3BlbnNlLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBDbGllbnRTaWRlU3VzcGVuc2UocHJvcHMpIHtcbiAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LlN1c3BlbnNlLCB7IGZhbGxiYWNrOiBwcm9wcy5mYWxsYmFjayB9LCBtb3VudGVkID8gcHJvcHMuY2hpbGRyZW4oKSA6IHByb3BzLmZhbGxiYWNrKTtcbn1cblxuLy8gc3JjL2xpdmVibG9ja3MudHN4XG5pbXBvcnQgeyBrSW50ZXJuYWwgYXMga0ludGVybmFsMywgbWFrZVBvbGxlciBhcyBtYWtlUG9sbGVyMiB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgeyBuYW5vaWQgYXMgbmFub2lkMyB9IGZyb20gXCJuYW5vaWRcIjtcbmltcG9ydCBSZWFjdDMsIHtcbiAgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MixcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2szLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQzLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NVxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzXCI7XG5cbi8vIHNyYy9jb21tZW50cy9saWIvc2VsZWN0ZWQtaW5ib3gtbm90aWZpY2F0aW9ucy50c1xuaW1wb3J0IHsgYXBwbHlPcHRpbWlzdGljVXBkYXRlcyB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5mdW5jdGlvbiBzZWxlY3RlZEluYm94Tm90aWZpY2F0aW9ucyhzdGF0ZSkge1xuICBjb25zdCByZXN1bHQgPSBhcHBseU9wdGltaXN0aWNVcGRhdGVzKHN0YXRlKTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucykuc29ydChcbiAgICAvLyBTb3J0IHNvIHRoYXQgdGhlIG1vc3QgcmVjZW50IG5vdGlmaWNhdGlvbnMgYXJlIGZpcnN0XG4gICAgKGEsIGIpID0+IGIubm90aWZpZWRBdC5nZXRUaW1lKCkgLSBhLm5vdGlmaWVkQXQuZ2V0VGltZSgpXG4gICk7XG59XG5cbi8vIHNyYy9saWIvcmV0cnktZXJyb3IudHNcbnZhciBNQVhfRVJST1JfUkVUUllfQ09VTlQgPSA1O1xudmFyIEVSUk9SX1JFVFJZX0lOVEVSVkFMID0gNWUzO1xuZnVuY3Rpb24gcmV0cnlFcnJvcihhY3Rpb24sIHJldHJ5Q291bnQpIHtcbiAgaWYgKHJldHJ5Q291bnQgPj0gTUFYX0VSUk9SX1JFVFJZX0NPVU5UKVxuICAgIHJldHVybjtcbiAgY29uc3QgdGltZW91dCA9IE1hdGgucG93KDIsIHJldHJ5Q291bnQpICogRVJST1JfUkVUUllfSU5URVJWQUw7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHZvaWQgYWN0aW9uKCk7XG4gIH0sIHRpbWVvdXQpO1xufVxuXG4vLyBzcmMvc2hhcmVkLnRzXG5pbXBvcnQgeyBrSW50ZXJuYWwgYXMga0ludGVybmFsMiB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qc1wiO1xuXG4vLyBzcmMvcm9vbS50c3hcbmltcG9ydCB7IHNoYWxsb3cgfSBmcm9tIFwiQGxpdmVibG9ja3MvY2xpZW50XCI7XG5pbXBvcnQge1xuICBhZGRSZWFjdGlvbixcbiAgQ29tbWVudHNBcGlFcnJvcixcbiAgY29uc29sZSBhcyBjb25zb2xlMixcbiAgZGVsZXRlQ29tbWVudCxcbiAgZGVwcmVjYXRlSWYsXG4gIGVycm9ySWYsXG4gIGlzTGl2ZU5vZGUsXG4gIGtJbnRlcm5hbCxcbiAgbWFrZUV2ZW50U291cmNlLFxuICBtYWtlUG9sbGVyLFxuICBOb3RpZmljYXRpb25zQXBpRXJyb3IsXG4gIHJlbW92ZVJlYWN0aW9uLFxuICBTZXJ2ZXJNc2dDb2RlLFxuICBzdHJpbmdpZnksXG4gIHVwc2VydENvbW1lbnRcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCB7IG5hbm9pZCBhcyBuYW5vaWQyIH0gZnJvbSBcIm5hbm9pZFwiO1xuaW1wb3J0ICogYXMgUmVhY3QyIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzXCI7XG5cbi8vIHNyYy9jb21tZW50cy9lcnJvcnMudHNcbnZhciBDcmVhdGVUaHJlYWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiQ3JlYXRlIHRocmVhZCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiQ3JlYXRlVGhyZWFkRXJyb3JcIjtcbiAgfVxufTtcbnZhciBFZGl0VGhyZWFkTWV0YWRhdGFFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiRWRpdCB0aHJlYWQgbWV0YWRhdGEgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIkVkaXRUaHJlYWRNZXRhZGF0YUVycm9yXCI7XG4gIH1cbn07XG52YXIgQ3JlYXRlQ29tbWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJDcmVhdGUgY29tbWVudCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiQ3JlYXRlQ29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgRWRpdENvbW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiRWRpdCBjb21tZW50IGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJFZGl0Q29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgRGVsZXRlQ29tbWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJEZWxldGUgY29tbWVudCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiRGVsZXRlQ29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgQWRkUmVhY3Rpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiQWRkIHJlYWN0aW9uIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJBZGRSZWFjdGlvbkVycm9yXCI7XG4gIH1cbn07XG52YXIgUmVtb3ZlUmVhY3Rpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiUmVtb3ZlIHJlYWN0aW9uIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJSZW1vdmVSZWFjdGlvbkVycm9yXCI7XG4gIH1cbn07XG52YXIgTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIk1hcmsgaW5ib3ggbm90aWZpY2F0aW9uIGFzIHJlYWQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIk1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZEVycm9yXCI7XG4gIH1cbn07XG52YXIgVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiVXBkYXRlIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NFcnJvclwiO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbWVudHMvbGliL2NyZWF0ZUlkcy50c1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSBcIm5hbm9pZFwiO1xudmFyIFRIUkVBRF9JRF9QUkVGSVggPSBcInRoXCI7XG52YXIgQ09NTUVOVF9JRF9QUkVGSVggPSBcImNtXCI7XG5mdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljSWQocHJlZml4KSB7XG4gIHJldHVybiBgJHtwcmVmaXh9XyR7bmFub2lkKCl9YDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRocmVhZElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKFRIUkVBRF9JRF9QUkVGSVgpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKENPTU1FTlRfSURfUFJFRklYKTtcbn1cblxuLy8gc3JjL2NvbW1lbnRzL2xpYi9zZWxlY3Qtbm90aWZpY2F0aW9uLXNldHRpbmdzLnRzXG5pbXBvcnQge1xuICBhcHBseU9wdGltaXN0aWNVcGRhdGVzIGFzIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMyLFxuICBublxufSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuZnVuY3Rpb24gc2VsZWN0Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbUlkLCBzdGF0ZSkge1xuICBjb25zdCB7IG5vdGlmaWNhdGlvblNldHRpbmdzIH0gPSBhcHBseU9wdGltaXN0aWNVcGRhdGVzMihzdGF0ZSk7XG4gIHJldHVybiBubihub3RpZmljYXRpb25TZXR0aW5nc1tyb29tSWRdKTtcbn1cblxuLy8gc3JjL2NvbW1lbnRzL2xpYi9zZWxlY3RlZC10aHJlYWRzLnRzXG5pbXBvcnQge1xuICBhcHBseU9wdGltaXN0aWNVcGRhdGVzIGFzIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMzXG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5mdW5jdGlvbiBzZWxlY3RlZFRocmVhZHMocm9vbUlkLCBzdGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCByZXN1bHQgPSBhcHBseU9wdGltaXN0aWNVcGRhdGVzMyhzdGF0ZSk7XG4gIGNvbnN0IHRocmVhZHMgPSBPYmplY3QudmFsdWVzKHJlc3VsdC50aHJlYWRzKS5maWx0ZXIoKHRocmVhZCkgPT4ge1xuICAgIGlmICh0aHJlYWQucm9vbUlkICE9PSByb29tSWQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeSA9IG9wdGlvbnMucXVlcnk7XG4gICAgaWYgKCFxdWVyeSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5Lm1ldGFkYXRhKSB7XG4gICAgICBpZiAodGhyZWFkLm1ldGFkYXRhW2tleV0gIT09IHF1ZXJ5Lm1ldGFkYXRhW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiB0aHJlYWRzLnNvcnQoKGEsIGIpID0+IGEuY3JlYXRlZEF0LmdldFRpbWUoKSAtIGIuY3JlYXRlZEF0LmdldFRpbWUoKSk7XG59XG5cbi8vIHNyYy9saWIvdXNlLWluaXRpYWwudHNcbmltcG9ydCB7IHVzZVN0YXRlIGFzIHVzZVN0YXRlMiB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlSW5pdGlhbCh2YWx1ZSkge1xuICByZXR1cm4gdXNlU3RhdGUyKHZhbHVlKVswXTtcbn1cblxuLy8gc3JjL2xpYi91c2UtbGF0ZXN0LnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VMYXRlc3QodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKHZhbHVlKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiByZWY7XG59XG5cbi8vIHNyYy9saWIvdXNlLXJlcmVuZGVyLnRzXG5pbXBvcnQgeyB1c2VSZWR1Y2VyIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VSZXJlbmRlcigpIHtcbiAgY29uc3QgWywgdXBkYXRlXSA9IHVzZVJlZHVjZXIoXG4gICAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiB3b3JrcyBieSBpbmNyZW1lbnRpbmcgYSBoaWRkZW4gY291bnRlciB2YWx1ZSB0aGF0IGlzXG4gICAgLy8gbmV2ZXIgY29uc3VtZWQuIFNpbXBseSBpbmNyZW1lbnRpbmcgdGhlIGNvdW50ZXIgY2hhbmdlcyB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBzdGF0ZSBhbmQsIHRodXMsIHRyaWdnZXIgYSByZS1yZW5kZXIuXG4gICAgKHgpID0+IHggKyAxLFxuICAgIDBcbiAgKTtcbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuLy8gc3JjL3Jvb20udHN4XG52YXIgbm9vcCA9ICgpID0+IHtcbn07XG52YXIgaWRlbnRpdHkgPSAoeCkgPT4geDtcbnZhciBtaXNzaW5nX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gKHJlYWN0VmVyc2lvbiwgcm9vbUlkKSA9PiBgV2Ugbm90aWNlZCB5b3VcXHUyMDE5cmUgdXNpbmcgUmVhY3QgJHtyZWFjdFZlcnNpb259LiBQbGVhc2UgcGFzcyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyBhdCB0aGUgUm9vbVByb3ZpZGVyIGxldmVsIHVudGlsIHlvdVxcdTIwMTlyZSByZWFkeSB0byB1cGdyYWRlIHRvIFJlYWN0IDE4OlxuXG4gICAgaW1wb3J0IHsgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgfSBmcm9tIFwicmVhY3QtZG9tXCI7ICAvLyBvciBcInJlYWN0LW5hdGl2ZVwiXG5cbiAgICA8Um9vbVByb3ZpZGVyIGlkPSR7SlNPTi5zdHJpbmdpZnkoXG4gIHJvb21JZFxuKX0gLi4uIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzPXt1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc30+XG4gICAgICAuLi5cbiAgICA8L1Jvb21Qcm92aWRlcj5cblxuV2h5PyBQbGVhc2Ugc2VlIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3BsYXRmb3JtL3Ryb3VibGVzaG9vdGluZyNzdGFsZS1wcm9wcy16b21iaWUtY2hpbGQgZm9yIG1vcmUgaW5mb3JtYXRpb25gO1xudmFyIHN1cGVyZmx1b3VzX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gXCJZb3UgZG9uXFx1MjAxOXQgbmVlZCB0byBwYXNzIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIHRvIFJvb21Qcm92aWRlciBhbnltb3JlLCBzaW5jZSB5b3VcXHUyMDE5cmUgb24gUmVhY3QgMTgrIGFscmVhZHkuXCI7XG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzLCBncywgZ3NzKSB7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihzLCBncywgZ3NzLCBpZGVudGl0eSk7XG59XG52YXIgU1RBQkxFX0VNUFRZX0xJU1QgPSBPYmplY3QuZnJlZXplKFtdKTtcbnZhciBQT0xMSU5HX0lOVEVSVkFMID0gNSAqIDYwICogMWUzO1xudmFyIE1FTlRJT05fU1VHR0VTVElPTlNfREVCT1VOQ0UgPSA1MDA7XG5mdW5jdGlvbiBhbHdheXNFbXB0eUxpc3QoKSB7XG4gIHJldHVybiBTVEFCTEVfRU1QVFlfTElTVDtcbn1cbmZ1bmN0aW9uIGFsd2F5c051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZU11dGF0aW9uQ29udGV4dChyb29tKSB7XG4gIGNvbnN0IGVycm1zZyA9IFwiVGhpcyBtdXRhdGlvbiBjYW5ub3QgYmUgdXNlZCB1bnRpbCBjb25uZWN0ZWQgdG8gdGhlIExpdmVibG9ja3Mgcm9vbVwiO1xuICByZXR1cm4ge1xuICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgY29uc3QgbXV0YWJsZVJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICAgICAgaWYgKG11dGFibGVSb290ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJtc2cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG11dGFibGVSb290O1xuICAgIH0sXG4gICAgZ2V0IHNlbGYoKSB7XG4gICAgICBjb25zdCBzZWxmID0gcm9vbS5nZXRTZWxmKCk7XG4gICAgICBpZiAoc2VsZiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJybXNnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG4gICAgZ2V0IG90aGVycygpIHtcbiAgICAgIGNvbnN0IG90aGVycyA9IHJvb20uZ2V0T3RoZXJzKCk7XG4gICAgICBpZiAocm9vbS5nZXRTZWxmKCkgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm1zZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3RoZXJzO1xuICAgIH0sXG4gICAgc2V0TXlQcmVzZW5jZTogcm9vbS51cGRhdGVQcmVzZW5jZVxuICB9O1xufVxudmFyIENvbnRleHRCdW5kbGUgPSBSZWFjdDIuY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIHVzZVJvb21Db250ZXh0QnVuZGxlKCkge1xuICBjb25zdCBidW5kbGUgPSBSZWFjdDIudXNlQ29udGV4dChDb250ZXh0QnVuZGxlKTtcbiAgaWYgKGJ1bmRsZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJvb21Qcm92aWRlciBpcyBtaXNzaW5nIGZyb20gdGhlIFJlYWN0IHRyZWUuXCIpO1xuICB9XG4gIHJldHVybiBidW5kbGU7XG59XG5mdW5jdGlvbiBjcmVhdGVSb29tQ29udGV4dChjbGllbnQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnM/LnJlc29sdmVVc2Vycykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlICdyZXNvbHZlVXNlcnMnIG9wdGlvbiBoYXMgbW92ZWQgdG8gJ2NyZWF0ZUNsaWVudCcgZnJvbSAnQGxpdmVibG9ja3MvY2xpZW50Jy4gUGxlYXNlIHJlZmVyIHRvIG91ciBVcGdyYWRlIEd1aWRlIHRvIGxlYXJuIG1vcmUsIHNlZSBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9wbGF0Zm9ybS91cGdyYWRpbmcvMS4xMC5cIlxuICAgICk7XG4gIH1cbiAgaWYgKG9wdGlvbnM/LnJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSAncmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucycgb3B0aW9uIGhhcyBtb3ZlZCB0byAnY3JlYXRlQ2xpZW50JyBmcm9tICdAbGl2ZWJsb2Nrcy9jbGllbnQnLiBQbGVhc2UgcmVmZXIgdG8gb3VyIFVwZ3JhZGUgR3VpZGUgdG8gbGVhcm4gbW9yZSwgc2VlIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3BsYXRmb3JtL3VwZ3JhZGluZy8xLjEwLlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBSb29tQ29udGV4dCA9IFJlYWN0Mi5jcmVhdGVDb250ZXh0KG51bGwpO1xuICBjb25zdCBjb21tZW50c0Vycm9yRXZlbnRTb3VyY2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgY29uc3Qgc2hhcmVkID0gY3JlYXRlU2hhcmVkQ29udGV4dChjbGllbnQpO1xuICBmdW5jdGlvbiBSb29tUHJvdmlkZXJPdXRlcihwcm9wcykge1xuICAgIGNvbnN0IFtjYWNoZV0gPSBSZWFjdDIudXNlU3RhdGUoXG4gICAgICAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gICAgKTtcbiAgICBjb25zdCBzdGFibGVFbnRlclJvb20gPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAocm9vbUlkLCBvcHRpb25zMikgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQocm9vbUlkKTtcbiAgICAgICAgaWYgKGNhY2hlZClcbiAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICBjb25zdCBydiA9IGNsaWVudC5lbnRlclJvb20oXG4gICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgIG9wdGlvbnMyXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG9yaWdMZWF2ZSA9IHJ2LmxlYXZlO1xuICAgICAgICBydi5sZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICBvcmlnTGVhdmUoKTtcbiAgICAgICAgICBjYWNoZS5kZWxldGUocm9vbUlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FjaGUuc2V0KHJvb21JZCwgcnYpO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9LFxuICAgICAgW2NhY2hlXVxuICAgICk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSb29tUHJvdmlkZXJJbm5lciwgeyAuLi5wcm9wcywgc3RhYmxlRW50ZXJSb29tIH0pO1xuICB9XG4gIGZ1bmN0aW9uIFJvb21Qcm92aWRlcklubmVyKHByb3BzKSB7XG4gICAgY29uc3QgeyBpZDogcm9vbUlkLCBzdGFibGVFbnRlclJvb20gfSA9IHByb3BzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghcm9vbUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlJvb21Qcm92aWRlciBpZCBwcm9wZXJ0eSBpcyByZXF1aXJlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2Vycm9ycy9saXZlYmxvY2tzLXJlYWN0L1Jvb21Qcm92aWRlci1pZC1wcm9wZXJ0eS1pcy1yZXF1aXJlZFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJvb21JZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tUHJvdmlkZXIgaWQgcHJvcGVydHkgc2hvdWxkIGJlIGEgc3RyaW5nLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1ham9yUmVhY3RWZXJzaW9uID0gcGFyc2VJbnQoUmVhY3QyLnZlcnNpb24pIHx8IDE7XG4gICAgICBjb25zdCBvbGRSZWFjdFZlcnNpb24gPSBtYWpvclJlYWN0VmVyc2lvbiA8IDE4O1xuICAgICAgZXJyb3JJZihcbiAgICAgICAgb2xkUmVhY3RWZXJzaW9uICYmIHByb3BzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID09PSB2b2lkIDAsXG4gICAgICAgIG1pc3NpbmdfdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMobWFqb3JSZWFjdFZlcnNpb24sIHJvb21JZClcbiAgICAgICk7XG4gICAgICBkZXByZWNhdGVJZihcbiAgICAgICAgIW9sZFJlYWN0VmVyc2lvbiAmJiBwcm9wcy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyAhPT0gdm9pZCAwLFxuICAgICAgICBzdXBlcmZsdW91c191bnN0YWJsZV9iYXRjaGVkVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZnJvemVuUHJvcHMgPSB1c2VJbml0aWFsKHtcbiAgICAgIGluaXRpYWxQcmVzZW5jZTogcHJvcHMuaW5pdGlhbFByZXNlbmNlLFxuICAgICAgaW5pdGlhbFN0b3JhZ2U6IHByb3BzLmluaXRpYWxTdG9yYWdlLFxuICAgICAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IHByb3BzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLFxuICAgICAgYXV0b0Nvbm5lY3Q6IHByb3BzLmF1dG9Db25uZWN0ID8/IHByb3BzLnNob3VsZEluaXRpYWxseUNvbm5lY3QgPz8gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgIH0pO1xuICAgIGNvbnN0IFt7IHJvb20gfSwgc2V0Um9vbUxlYXZlUGFpcl0gPSBSZWFjdDIudXNlU3RhdGUoXG4gICAgICAoKSA9PiBzdGFibGVFbnRlclJvb20ocm9vbUlkLCB7XG4gICAgICAgIC4uLmZyb3plblByb3BzLFxuICAgICAgICBhdXRvQ29ubmVjdDogZmFsc2VcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IHVzaW5nIGZhbHNlIGhlcmUgb24gdGhlIGZpcnN0IHJlbmRlciwgc2VlIGJlbG93XG4gICAgICB9KVxuICAgICk7XG4gICAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBhc3luYyBmdW5jdGlvbiBoYW5kbGVDb21tZW50RXZlbnQobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBpbmZvID0gYXdhaXQgcm9vbVtrSW50ZXJuYWxdLmNvbW1lbnRzLmdldFRocmVhZCh7XG4gICAgICAgICAgdGhyZWFkSWQ6IG1lc3NhZ2UudGhyZWFkSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgIHN0b3JlLmRlbGV0ZVRocmVhZChtZXNzYWdlLnRocmVhZElkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0aHJlYWQsIGluYm94Tm90aWZpY2F0aW9uIH0gPSBpbmZvO1xuICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0b3JlLmdldCgpLnRocmVhZHNbbWVzc2FnZS50aHJlYWRJZF07XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfRURJVEVEOlxuICAgICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5USFJFQURfTUVUQURBVEFfVVBEQVRFRDpcbiAgICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9SRUFDVElPTl9BRERFRDpcbiAgICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9SRUFDVElPTl9SRU1PVkVEOlxuICAgICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX0RFTEVURUQ6XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nVGhyZWFkKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0b3JlLnVwZGF0ZVRocmVhZEFuZE5vdGlmaWNhdGlvbih0aHJlYWQsIGluYm94Tm90aWZpY2F0aW9uKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX0NSRUFURUQ6XG4gICAgICAgICAgICBzdG9yZS51cGRhdGVUaHJlYWRBbmROb3RpZmljYXRpb24odGhyZWFkLCBpbmJveE5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb29tLmV2ZW50cy5jb21tZW50cy5zdWJzY3JpYmUoXG4gICAgICAgIChtZXNzYWdlKSA9PiB2b2lkIGhhbmRsZUNvbW1lbnRFdmVudChtZXNzYWdlKVxuICAgICAgKTtcbiAgICB9LCBbcm9vbV0pO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgdm9pZCBnZXRUaHJlYWRzVXBkYXRlcyhyb29tLmlkKTtcbiAgICB9LCBbcm9vbS5pZF0pO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgZnVuY3Rpb24gaGFuZGxlSXNPbmxpbmUoKSB7XG4gICAgICAgIHZvaWQgZ2V0VGhyZWFkc1VwZGF0ZXMocm9vbS5pZCk7XG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBoYW5kbGVJc09ubGluZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBoYW5kbGVJc09ubGluZSk7XG4gICAgICB9O1xuICAgIH0sIFtyb29tLmlkXSk7XG4gICAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBwYWlyID0gc3RhYmxlRW50ZXJSb29tKHJvb21JZCwgZnJvemVuUHJvcHMpO1xuICAgICAgc2V0Um9vbUxlYXZlUGFpcihwYWlyKTtcbiAgICAgIGNvbnN0IHsgcm9vbTogcm9vbTIsIGxlYXZlIH0gPSBwYWlyO1xuICAgICAgaWYgKGZyb3plblByb3BzLmF1dG9Db25uZWN0KSB7XG4gICAgICAgIHJvb20yLmNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxlYXZlKCk7XG4gICAgICB9O1xuICAgIH0sIFtyb29tSWQsIGZyb3plblByb3BzLCBzdGFibGVFbnRlclJvb21dKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJvb21Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiByb29tIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgIENvbnRleHRCdW5kbGUuUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiBidW5kbGVcbiAgICAgIH0sXG4gICAgICBwcm9wcy5jaGlsZHJlblxuICAgICkpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbm5lY3Rpb25JZFNlbGVjdG9yKG90aGVycykge1xuICAgIHJldHVybiBvdGhlcnMubWFwKCh1c2VyKSA9PiB1c2VyLmNvbm5lY3Rpb25JZCk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlUm9vbSgpIHtcbiAgICBjb25zdCByb29tID0gUmVhY3QyLnVzZUNvbnRleHQoUm9vbUNvbnRleHQpO1xuICAgIGlmIChyb29tID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tUHJvdmlkZXIgaXMgbWlzc2luZyBmcm9tIHRoZSBSZWFjdCB0cmVlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb207XG4gIH1cbiAgZnVuY3Rpb24gdXNlU3RhdHVzKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0U3RhdHVzO1xuICAgIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gcm9vbS5nZXRTdGF0dXM7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgfVxuICBmdW5jdGlvbiB1c2VNeVByZXNlbmNlKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMubXlQcmVzZW5jZS5zdWJzY3JpYmU7XG4gICAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFByZXNlbmNlO1xuICAgIGNvbnN0IHByZXNlbmNlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U25hcHNob3QpO1xuICAgIGNvbnN0IHNldFByZXNlbmNlID0gcm9vbS51cGRhdGVQcmVzZW5jZTtcbiAgICByZXR1cm4gW3ByZXNlbmNlLCBzZXRQcmVzZW5jZV07XG4gIH1cbiAgZnVuY3Rpb24gdXNlVXBkYXRlTXlQcmVzZW5jZSgpIHtcbiAgICByZXR1cm4gdXNlUm9vbSgpLnVwZGF0ZVByZXNlbmNlO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVycyhzZWxlY3RvciwgaXNFcXVhbCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0T3RoZXJzO1xuICAgIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzRW1wdHlMaXN0O1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIGdldFNuYXBzaG90LFxuICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICBzZWxlY3RvciA/PyBpZGVudGl0eSxcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHMoKSB7XG4gICAgcmV0dXJuIHVzZU90aGVycyhjb25uZWN0aW9uSWRTZWxlY3Rvciwgc2hhbGxvdyk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzTWFwcGVkKGl0ZW1TZWxlY3RvciwgaXRlbUlzRXF1YWwpIHtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAob3RoZXJzKSA9PiBvdGhlcnMubWFwKFxuICAgICAgICAob3RoZXIpID0+IFtvdGhlci5jb25uZWN0aW9uSWQsIGl0ZW1TZWxlY3RvcihvdGhlcildXG4gICAgICApLFxuICAgICAgW2l0ZW1TZWxlY3Rvcl1cbiAgICApO1xuICAgIGNvbnN0IHdyYXBwZWRJc0VxdWFsID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgZXEgPSBpdGVtSXNFcXVhbCA/PyBPYmplY3QuaXM7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoYXR1cGxlLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGJ0dXBsZSA9IGJbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiBhdHVwbGVbMF0gPT09IGJ0dXBsZVswXSAmJiBlcShhdHVwbGVbMV0sIGJ0dXBsZVsxXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFtpdGVtSXNFcXVhbF1cbiAgICApO1xuICAgIHJldHVybiB1c2VPdGhlcnMod3JhcHBlZFNlbGVjdG9yLCB3cmFwcGVkSXNFcXVhbCk7XG4gIH1cbiAgY29uc3QgTk9UX0ZPVU5EID0gU3ltYm9sKCk7XG4gIGZ1bmN0aW9uIHVzZU90aGVyKGNvbm5lY3Rpb25JZCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAob3RoZXJzKSA9PiB7XG4gICAgICAgIGNvbnN0IG90aGVyMiA9IG90aGVycy5maW5kKFxuICAgICAgICAgIChvdGhlcjMpID0+IG90aGVyMy5jb25uZWN0aW9uSWQgPT09IGNvbm5lY3Rpb25JZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gb3RoZXIyICE9PSB2b2lkIDAgPyBzZWxlY3RvcihvdGhlcjIpIDogTk9UX0ZPVU5EO1xuICAgICAgfSxcbiAgICAgIFtjb25uZWN0aW9uSWQsIHNlbGVjdG9yXVxuICAgICk7XG4gICAgY29uc3Qgd3JhcHBlZElzRXF1YWwgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAocHJldiwgY3VycikgPT4ge1xuICAgICAgICBpZiAocHJldiA9PT0gTk9UX0ZPVU5EIHx8IGN1cnIgPT09IE5PVF9GT1VORCkge1xuICAgICAgICAgIHJldHVybiBwcmV2ID09PSBjdXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVxID0gaXNFcXVhbCA/PyBPYmplY3QuaXM7XG4gICAgICAgIHJldHVybiBlcShwcmV2LCBjdXJyKTtcbiAgICAgIH0sXG4gICAgICBbaXNFcXVhbF1cbiAgICApO1xuICAgIGNvbnN0IG90aGVyID0gdXNlT3RoZXJzKHdyYXBwZWRTZWxlY3Rvciwgd3JhcHBlZElzRXF1YWwpO1xuICAgIGlmIChvdGhlciA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBObyBzdWNoIG90aGVyIHVzZXIgd2l0aCBjb25uZWN0aW9uIGlkICR7Y29ubmVjdGlvbklkfSBleGlzdHNgXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gb3RoZXI7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQnJvYWRjYXN0RXZlbnQoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKGV2ZW50LCBvcHRpb25zMiA9IHsgc2hvdWxkUXVldWVFdmVudElmTm90UmVhZHk6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgcm9vbS5icm9hZGNhc3RFdmVudChldmVudCwgb3B0aW9uczIpO1xuICAgICAgfSxcbiAgICAgIFtyb29tXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoXG4gICAgICAoKSA9PiByb29tLmV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKChldmVudCkgPT4gc2F2ZWRDYWxsYmFjay5jdXJyZW50KGV2ZW50KSksXG4gICAgICBbcm9vbSwgc2F2ZWRDYWxsYmFja11cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoXG4gICAgICAoKSA9PiByb29tLmV2ZW50cy5sb3N0Q29ubmVjdGlvbi5zdWJzY3JpYmUoXG4gICAgICAgIChldmVudCkgPT4gc2F2ZWRDYWxsYmFjay5jdXJyZW50KGV2ZW50KVxuICAgICAgKSxcbiAgICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRXJyb3JMaXN0ZW5lcihjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gICAgUmVhY3QyLnVzZUVmZmVjdChcbiAgICAgICgpID0+IHJvb20uZXZlbnRzLmVycm9yLnN1YnNjcmliZSgoZSkgPT4gc2F2ZWRDYWxsYmFjay5jdXJyZW50KGUpKSxcbiAgICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlRXZlbnRMaXN0ZW5lcihjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gICAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IChldmVudERhdGEpID0+IHtcbiAgICAgICAgc2F2ZWRDYWxsYmFjay5jdXJyZW50KGV2ZW50RGF0YSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJvb20uZXZlbnRzLmN1c3RvbUV2ZW50LnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgfSwgW3Jvb20sIHNhdmVkQ2FsbGJhY2tdKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VTZWxmKG1heWJlU2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLnNlbGYuc3Vic2NyaWJlO1xuICAgIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRTZWxmO1xuICAgIGNvbnN0IHNlbGVjdG9yID0gbWF5YmVTZWxlY3RvciA/PyBpZGVudGl0eTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAobWUpID0+IG1lICE9PSBudWxsID8gc2VsZWN0b3IobWUpIDogbnVsbCxcbiAgICAgIFtzZWxlY3Rvcl1cbiAgICApO1xuICAgIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzTnVsbDtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBnZXRTbmFwc2hvdCxcbiAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgICAgaXNFcXVhbFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlTXV0YWJsZVN0b3JhZ2VSb290KCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc3RvcmFnZURpZExvYWQuc3Vic2NyaWJlT25jZTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90O1xuICAgIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzTnVsbDtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVN0b3JhZ2VSb290KCkge1xuICAgIHJldHVybiBbdXNlTXV0YWJsZVN0b3JhZ2VSb290KCldO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUhpc3RvcnkoKSB7XG4gICAgcmV0dXJuIHVzZVJvb20oKS5oaXN0b3J5O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVVuZG8oKSB7XG4gICAgcmV0dXJuIHVzZUhpc3RvcnkoKS51bmRvO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJlZG8oKSB7XG4gICAgcmV0dXJuIHVzZUhpc3RvcnkoKS5yZWRvO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUNhblVuZG8oKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5oaXN0b3J5LnN1YnNjcmliZTtcbiAgICBjb25zdCBjYW5VbmRvID0gcm9vbS5oaXN0b3J5LmNhblVuZG87XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgY2FuVW5kbywgY2FuVW5kbyk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQ2FuUmVkbygpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLmhpc3Rvcnkuc3Vic2NyaWJlO1xuICAgIGNvbnN0IGNhblJlZG8gPSByb29tLmhpc3RvcnkuY2FuUmVkbztcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBjYW5SZWRvLCBjYW5SZWRvKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VCYXRjaCgpIHtcbiAgICByZXR1cm4gdXNlUm9vbSgpLmJhdGNoO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUxlZ2FjeUtleShrZXkpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHJvb3RPck51bGwgPSB1c2VNdXRhYmxlU3RvcmFnZVJvb3QoKTtcbiAgICBjb25zdCByZXJlbmRlciA9IHVzZVJlcmVuZGVyKCk7XG4gICAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAocm9vdE9yTnVsbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByb290ID0gcm9vdE9yTnVsbDtcbiAgICAgIGxldCB1bnN1YkN1cnI7XG4gICAgICBsZXQgY3VyciA9IHJvb3QuZ2V0KGtleSk7XG4gICAgICBmdW5jdGlvbiBzdWJzY3JpYmVUb0N1cnIoKSB7XG4gICAgICAgIHVuc3ViQ3VyciA9IGlzTGl2ZU5vZGUoY3VycikgPyByb29tLnN1YnNjcmliZShjdXJyLCByZXJlbmRlcikgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvblJvb3RDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcm9vdC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBjdXJyKSB7XG4gICAgICAgICAgdW5zdWJDdXJyPy4oKTtcbiAgICAgICAgICBjdXJyID0gbmV3VmFsdWU7XG4gICAgICAgICAgc3Vic2NyaWJlVG9DdXJyKCk7XG4gICAgICAgICAgcmVyZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3Vic2NyaWJlVG9DdXJyKCk7XG4gICAgICByZXJlbmRlcigpO1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmVSb290ID0gcm9vbS5zdWJzY3JpYmUocm9vdCwgb25Sb290Q2hhbmdlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVuc3Vic2NyaWJlUm9vdCgpO1xuICAgICAgICB1bnN1YkN1cnI/LigpO1xuICAgICAgfTtcbiAgICB9LCBbcm9vdE9yTnVsbCwgcm9vbSwga2V5LCByZXJlbmRlcl0pO1xuICAgIGlmIChyb290T3JOdWxsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJvb3RPck51bGwuZ2V0KGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVzZVN0b3JhZ2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IHJvb3RPck51bGwgPSB1c2VNdXRhYmxlU3RvcmFnZVJvb3QoKTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAocm9vdE9yTnVsbDIpID0+IHJvb3RPck51bGwyICE9PSBudWxsID8gc2VsZWN0b3Iocm9vdE9yTnVsbDIpIDogbnVsbCxcbiAgICAgIFtzZWxlY3Rvcl1cbiAgICApO1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgIChvblN0b3JlQ2hhbmdlKSA9PiByb290T3JOdWxsICE9PSBudWxsID8gcm9vbS5zdWJzY3JpYmUocm9vdE9yTnVsbCwgb25TdG9yZUNoYW5nZSwgeyBpc0RlZXA6IHRydWUgfSkgOiBub29wLFxuICAgICAgW3Jvb20sIHJvb3RPck51bGxdXG4gICAgKTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdCA9IFJlYWN0Mi51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBpZiAocm9vdE9yTnVsbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSByb290T3JOdWxsO1xuICAgICAgICBjb25zdCBpbW0gPSByb290LnRvSW1tdXRhYmxlKCk7XG4gICAgICAgIHJldHVybiBpbW07XG4gICAgICB9XG4gICAgfSwgW3Jvb3RPck51bGxdKTtcbiAgICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c051bGw7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgICAgc3Vic2NyaWJlLFxuICAgICAgZ2V0U25hcHNob3QsXG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGVuc3VyZU5vdFNlcnZlclNpZGUoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJZb3UgY2Fubm90IHVzZSB0aGUgU3VzcGVuc2UgdmVyc2lvbiBvZiB0aGlzIGhvb2sgb24gdGhlIHNlcnZlciBzaWRlLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIHRoZW0gb24gdGhlIGNsaWVudCBzaWRlLlxcbkZvciB0aXBzLCBzZWUgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLXJlYWN0I3N1c3BlbnNlLWF2b2lkLXNzclwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1c2VTdXNwZW5kVW50aWxTdG9yYWdlTG9hZGVkKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgaWYgKHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCkgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICAgIHRocm93IG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VEaWRMb2FkLnN1YnNjcmliZU9uY2UoKCkgPT4gcmVzKCkpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlTG9hZGVkKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgaWYgKHJvb20uZ2V0U2VsZigpICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgICB0aHJvdyBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICByb29tLmV2ZW50cy5zZWxmLnN1YnNjcmliZU9uY2UoKCkgPT4gcmVzKCkpO1xuICAgICAgcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZU9uY2UoKCkgPT4gcmVzKCkpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU11dGF0aW9uKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZU1lbW8oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4gKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgIHJvb20uYmF0Y2goXG4gICAgICAgICAgICAoKSA9PiAoXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgICBtYWtlTXV0YXRpb25Db250ZXh0KHJvb20pLFxuICAgICAgICAgICAgICAgIC4uLmFyZ3NcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICBbcm9vbSwgLi4uZGVwc11cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVN0b3JhZ2VTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICAgIHVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VMb2FkZWQoKTtcbiAgICByZXR1cm4gdXNlU3RvcmFnZShcbiAgICAgIHNlbGVjdG9yLFxuICAgICAgaXNFcXVhbFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlU2VsZlN1c3BlbnNlKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gICAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VMb2FkZWQoKTtcbiAgICByZXR1cm4gdXNlU2VsZihcbiAgICAgIHNlbGVjdG9yLFxuICAgICAgaXNFcXVhbFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VPdGhlcnMoXG4gICAgICBzZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHNTdXNwZW5zZSgpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzKCk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlT3RoZXJzTWFwcGVkU3VzcGVuc2UoaXRlbVNlbGVjdG9yLCBpdGVtSXNFcXVhbCkge1xuICAgIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlTG9hZGVkKCk7XG4gICAgcmV0dXJuIHVzZU90aGVyc01hcHBlZChpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VPdGhlclN1c3BlbnNlKGNvbm5lY3Rpb25JZCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCgpO1xuICAgIHJldHVybiB1c2VPdGhlcihjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VMZWdhY3lLZXlTdXNwZW5zZShrZXkpIHtcbiAgICB1c2VTdXNwZW5kVW50aWxTdG9yYWdlTG9hZGVkKCk7XG4gICAgcmV0dXJuIHVzZUxlZ2FjeUtleShrZXkpO1xuICB9XG4gIGNvbnN0IHN0b3JlID0gY2xpZW50W2tJbnRlcm5hbF0uY2FjaGVTdG9yZTtcbiAgZnVuY3Rpb24gb25NdXRhdGlvbkZhaWx1cmUoaW5uZXJFcnJvciwgb3B0aW1pc3RpY1VwZGF0ZUlkLCBjcmVhdGVQdWJsaWNFcnJvcikge1xuICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICApXG4gICAgfSkpO1xuICAgIGlmIChpbm5lckVycm9yIGluc3RhbmNlb2YgQ29tbWVudHNBcGlFcnJvcikge1xuICAgICAgY29uc3QgZXJyb3IgPSBoYW5kbGVBcGlFcnJvcihpbm5lckVycm9yKTtcbiAgICAgIGNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZS5ub3RpZnkoY3JlYXRlUHVibGljRXJyb3IoZXJyb3IpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlubmVyRXJyb3IgaW5zdGFuY2VvZiBOb3RpZmljYXRpb25zQXBpRXJyb3IpIHtcbiAgICAgIGhhbmRsZUFwaUVycm9yKGlubmVyRXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBpbm5lckVycm9yO1xuICB9XG4gIGNvbnN0IHN1YnNjcmliZXJzQnlRdWVyeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHJlcXVlc3RzQnlRdWVyeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHBvbGxlciA9IG1ha2VQb2xsZXIocmVmcmVzaFRocmVhZHNBbmROb3RpZmljYXRpb25zKTtcbiAgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaFRocmVhZHNBbmROb3RpZmljYXRpb25zKCkge1xuICAgIGNvbnN0IHJlcXVlc3RzID0gW107XG4gICAgY2xpZW50W2tJbnRlcm5hbF0uZ2V0Um9vbUlkcygpLm1hcCgocm9vbUlkKSA9PiB7XG4gICAgICBjb25zdCByb29tID0gY2xpZW50LmdldFJvb20ocm9vbUlkKTtcbiAgICAgIGlmIChyb29tID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICByZXF1ZXN0cy5wdXNoKGdldFRocmVhZHNVcGRhdGVzKHJvb20uaWQpKTtcbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocmVxdWVzdHMpO1xuICB9XG4gIGZ1bmN0aW9uIGluY3JlbWVudFF1ZXJ5U3Vic2NyaWJlcnMocXVlcnlLZXkpIHtcbiAgICBjb25zdCBzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzQnlRdWVyeS5nZXQocXVlcnlLZXkpID8/IDA7XG4gICAgc3Vic2NyaWJlcnNCeVF1ZXJ5LnNldChxdWVyeUtleSwgc3Vic2NyaWJlcnMgKyAxKTtcbiAgICBwb2xsZXIuc3RhcnQoUE9MTElOR19JTlRFUlZBTCk7XG4gIH1cbiAgZnVuY3Rpb24gZGVjcmVtZW50UXVlcnlTdWJzY3JpYmVycyhxdWVyeUtleSkge1xuICAgIGNvbnN0IHN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnNCeVF1ZXJ5LmdldChxdWVyeUtleSk7XG4gICAgaWYgKHN1YnNjcmliZXJzID09PSB2b2lkIDAgfHwgc3Vic2NyaWJlcnMgPD0gMCkge1xuICAgICAgY29uc29sZTIud2FybihcbiAgICAgICAgYEludGVybmFsIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIENhbm5vdCBkZWNyZWFzZSBzdWJzY3JpYmVyIGNvdW50IGZvciBxdWVyeSBcIiR7cXVlcnlLZXl9XCJgXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdWJzY3JpYmVyc0J5UXVlcnkuc2V0KHF1ZXJ5S2V5LCBzdWJzY3JpYmVycyAtIDEpO1xuICAgIGxldCB0b3RhbFN1YnNjcmliZXJzID0gMDtcbiAgICBmb3IgKGNvbnN0IHN1YnNjcmliZXJzMiBvZiBzdWJzY3JpYmVyc0J5UXVlcnkudmFsdWVzKCkpIHtcbiAgICAgIHRvdGFsU3Vic2NyaWJlcnMgKz0gc3Vic2NyaWJlcnMyO1xuICAgIH1cbiAgICBpZiAodG90YWxTdWJzY3JpYmVycyA8PSAwKSB7XG4gICAgICBwb2xsZXIuc3RvcCgpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzQW5kSW5ib3hOb3RpZmljYXRpb25zKHJvb20sIHF1ZXJ5S2V5LCBvcHRpb25zMiwgeyByZXRyeUNvdW50IH0gPSB7IHJldHJ5Q291bnQ6IDAgfSkge1xuICAgIGNvbnN0IGV4aXN0aW5nUmVxdWVzdCA9IHJlcXVlc3RzQnlRdWVyeS5nZXQocXVlcnlLZXkpO1xuICAgIGlmIChleGlzdGluZ1JlcXVlc3QgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBleGlzdGluZ1JlcXVlc3Q7XG4gICAgY29uc3QgcmVxdWVzdCA9IHJvb21ba0ludGVybmFsXS5jb21tZW50cy5nZXRUaHJlYWRzKG9wdGlvbnMyKTtcbiAgICByZXF1ZXN0c0J5UXVlcnkuc2V0KHF1ZXJ5S2V5LCByZXF1ZXN0KTtcbiAgICBzdG9yZS5zZXRRdWVyeVN0YXRlKHF1ZXJ5S2V5LCB7XG4gICAgICBpc0xvYWRpbmc6IHRydWVcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdDtcbiAgICAgIHN0b3JlLnVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zKFxuICAgICAgICByZXN1bHQudGhyZWFkcyxcbiAgICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgcmVzdWx0LmRlbGV0ZWRUaHJlYWRzLFxuICAgICAgICByZXN1bHQuZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgcXVlcnlLZXlcbiAgICAgICk7XG4gICAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSBsYXN0UmVxdWVzdGVkQXRCeVJvb20uZ2V0KHJvb20uaWQpO1xuICAgICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gdm9pZCAwIHx8IGxhc3RSZXF1ZXN0ZWRBdCA+IHJlc3VsdC5tZXRhLnJlcXVlc3RlZEF0KSB7XG4gICAgICAgIGxhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5zZXQocm9vbS5pZCwgcmVzdWx0Lm1ldGEucmVxdWVzdGVkQXQpO1xuICAgICAgfVxuICAgICAgcG9sbGVyLnN0YXJ0KFBPTExJTkdfSU5URVJWQUwpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVxdWVzdHNCeVF1ZXJ5LmRlbGV0ZShxdWVyeUtleSk7XG4gICAgICByZXRyeUVycm9yKCgpID0+IHtcbiAgICAgICAgdm9pZCBnZXRUaHJlYWRzQW5kSW5ib3hOb3RpZmljYXRpb25zKHJvb20sIHF1ZXJ5S2V5LCBvcHRpb25zMiwge1xuICAgICAgICAgIHJldHJ5Q291bnQ6IHJldHJ5Q291bnQgKyAxXG4gICAgICAgIH0pO1xuICAgICAgfSwgcmV0cnlDb3VudCk7XG4gICAgICBzdG9yZS5zZXRRdWVyeVN0YXRlKHF1ZXJ5S2V5LCB7XG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjb25zdCBERUZBVUxUX0RFRFVQSU5HX0lOVEVSVkFMID0gMmUzO1xuICBjb25zdCBsYXN0UmVxdWVzdGVkQXRCeVJvb20gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCByZXF1ZXN0U3RhdHVzQnlSb29tID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkc1VwZGF0ZXMocm9vbUlkKSB7XG4gICAgY29uc3Qgcm9vbSA9IGNsaWVudC5nZXRSb29tKHJvb21JZCk7XG4gICAgaWYgKHJvb20gPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgc2luY2UgPSBsYXN0UmVxdWVzdGVkQXRCeVJvb20uZ2V0KHJvb20uaWQpO1xuICAgIGlmIChzaW5jZSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlzRmV0Y2hpbmdUaHJlYWRzVXBkYXRlcyA9IHJlcXVlc3RTdGF0dXNCeVJvb20uZ2V0KHJvb20uaWQpID8/IGZhbHNlO1xuICAgIGlmIChpc0ZldGNoaW5nVGhyZWFkc1VwZGF0ZXMgPT09IHRydWUpXG4gICAgICByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIHJlcXVlc3RTdGF0dXNCeVJvb20uc2V0KHJvb20uaWQsIHRydWUpO1xuICAgICAgY29uc3QgdXBkYXRlcyA9IGF3YWl0IHJvb21ba0ludGVybmFsXS5jb21tZW50cy5nZXRUaHJlYWRzKHsgc2luY2UgfSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVxdWVzdFN0YXR1c0J5Um9vbS5zZXQocm9vbS5pZCwgZmFsc2UpO1xuICAgICAgfSwgREVGQVVMVF9ERURVUElOR19JTlRFUlZBTCk7XG4gICAgICBzdG9yZS51cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyhcbiAgICAgICAgdXBkYXRlcy50aHJlYWRzLFxuICAgICAgICB1cGRhdGVzLmluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgdXBkYXRlcy5kZWxldGVkVGhyZWFkcyxcbiAgICAgICAgdXBkYXRlcy5kZWxldGVkSW5ib3hOb3RpZmljYXRpb25zXG4gICAgICApO1xuICAgICAgbGFzdFJlcXVlc3RlZEF0QnlSb29tLnNldChyb29tLmlkLCB1cGRhdGVzLm1ldGEucmVxdWVzdGVkQXQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVxdWVzdFN0YXR1c0J5Um9vbS5zZXQocm9vbS5pZCwgZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1c2VUaHJlYWRzKG9wdGlvbnMyID0geyBxdWVyeTogeyBtZXRhZGF0YToge30gfSB9KSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBxdWVyeUtleSA9IFJlYWN0Mi51c2VNZW1vKFxuICAgICAgKCkgPT4gZ2VuZXJhdGVRdWVyeUtleShyb29tLmlkLCBvcHRpb25zMi5xdWVyeSksXG4gICAgICBbcm9vbSwgb3B0aW9uczJdXG4gICAgKTtcbiAgICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHZvaWQgZ2V0VGhyZWFkc0FuZEluYm94Tm90aWZpY2F0aW9ucyhyb29tLCBxdWVyeUtleSwgb3B0aW9uczIpO1xuICAgICAgaW5jcmVtZW50UXVlcnlTdWJzY3JpYmVycyhxdWVyeUtleSk7XG4gICAgICByZXR1cm4gKCkgPT4gZGVjcmVtZW50UXVlcnlTdWJzY3JpYmVycyhxdWVyeUtleSk7XG4gICAgfSwgW3Jvb20sIHF1ZXJ5S2V5XSk7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBzdGF0ZS5xdWVyaWVzW3F1ZXJ5S2V5XTtcbiAgICAgICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDAgfHwgcXVlcnkuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzTG9hZGluZzogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0aHJlYWRzOiBzZWxlY3RlZFRocmVhZHMocm9vbS5pZCwgc3RhdGUsIG9wdGlvbnMyKSxcbiAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBxdWVyeS5lcnJvclxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIFtyb29tLCBxdWVyeUtleV1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgKTtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzZWxlY3RvclxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlVGhyZWFkc1N1c3BlbnNlKG9wdGlvbnMyID0geyBxdWVyeTogeyBtZXRhZGF0YToge30gfSB9KSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBjb25zdCBxdWVyeUtleSA9IFJlYWN0Mi51c2VNZW1vKFxuICAgICAgKCkgPT4gZ2VuZXJhdGVRdWVyeUtleShyb29tLmlkLCBvcHRpb25zMj8ucXVlcnkpLFxuICAgICAgW3Jvb20sIG9wdGlvbnMyXVxuICAgICk7XG4gICAgY29uc3QgcXVlcnkgPSBzdG9yZS5nZXQoKS5xdWVyaWVzW3F1ZXJ5S2V5XTtcbiAgICBpZiAocXVlcnkgPT09IHZvaWQgMCB8fCBxdWVyeS5pc0xvYWRpbmcpIHtcbiAgICAgIHRocm93IGdldFRocmVhZHNBbmRJbmJveE5vdGlmaWNhdGlvbnMocm9vbSwgcXVlcnlLZXksIG9wdGlvbnMyKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmVycm9yKSB7XG4gICAgICB0aHJvdyBxdWVyeS5lcnJvcjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAoc3RhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0aHJlYWRzOiBzZWxlY3RlZFRocmVhZHMocm9vbS5pZCwgc3RhdGUsIG9wdGlvbnMyKSxcbiAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgW3Jvb20sIHF1ZXJ5S2V5XVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICApO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaW5jcmVtZW50UXVlcnlTdWJzY3JpYmVycyhxdWVyeUtleSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkZWNyZW1lbnRRdWVyeVN1YnNjcmliZXJzKHF1ZXJ5S2V5KTtcbiAgICAgIH07XG4gICAgfSwgW3F1ZXJ5S2V5XSk7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc2VsZWN0b3JcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUNyZWF0ZVRocmVhZCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAob3B0aW9uczIpID0+IHtcbiAgICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMyLmJvZHk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gXCJtZXRhZGF0YVwiIGluIG9wdGlvbnMyID8gb3B0aW9uczIubWV0YWRhdGEgOiB7fTtcbiAgICAgICAgY29uc3QgdGhyZWFkSWQgPSBjcmVhdGVUaHJlYWRJZCgpO1xuICAgICAgICBjb25zdCBjb21tZW50SWQgPSBjcmVhdGVDb21tZW50SWQoKTtcbiAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IG5ld0NvbW1lbnQgPSB7XG4gICAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICAgIHR5cGU6IFwiY29tbWVudFwiLFxuICAgICAgICAgIHVzZXJJZDogZ2V0Q3VycmVudFVzZXJJZChyb29tKSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIHJlYWN0aW9uczogW11cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbmV3VGhyZWFkID0ge1xuICAgICAgICAgIGlkOiB0aHJlYWRJZCxcbiAgICAgICAgICB0eXBlOiBcInRocmVhZFwiLFxuICAgICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IGNyZWF0ZWRBdCxcbiAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgY29tbWVudHM6IFtuZXdDb21tZW50XVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQyKCk7XG4gICAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgICB0eXBlOiBcImNyZWF0ZS10aHJlYWRcIixcbiAgICAgICAgICB0aHJlYWQ6IG5ld1RocmVhZCxcbiAgICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgIH0pO1xuICAgICAgICByb29tW2tJbnRlcm5hbF0uY29tbWVudHMuY3JlYXRlVGhyZWFkKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgYm9keSwgbWV0YWRhdGEgfSkudGhlbihcbiAgICAgICAgICAodGhyZWFkKSA9PiB7XG4gICAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgdGhyZWFkczoge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLnRocmVhZHMsXG4gICAgICAgICAgICAgICAgW3RocmVhZElkXTogdGhyZWFkXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICAoZXJyMikgPT4gbmV3IENyZWF0ZVRocmVhZEVycm9yKGVycjIsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBuZXdUaHJlYWQ7XG4gICAgICB9LFxuICAgICAgW3Jvb21dXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VFZGl0VGhyZWFkTWV0YWRhdGEoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKG9wdGlvbnMyKSA9PiB7XG4gICAgICAgIGlmICghKFwibWV0YWRhdGFcIiBpbiBvcHRpb25zMikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhyZWFkSWQgPSBvcHRpb25zMi50aHJlYWRJZDtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBvcHRpb25zMi5tZXRhZGF0YTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDIoKTtcbiAgICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICAgIHR5cGU6IFwiZWRpdC10aHJlYWQtbWV0YWRhdGFcIixcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIHVwZGF0ZWRBdFxuICAgICAgICB9KTtcbiAgICAgICAgcm9vbVtrSW50ZXJuYWxdLmNvbW1lbnRzLmVkaXRUaHJlYWRNZXRhZGF0YSh7IG1ldGFkYXRhLCB0aHJlYWRJZCB9KS50aGVuKFxuICAgICAgICAgIChtZXRhZGF0YTIpID0+IHtcbiAgICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSBzdGF0ZS50aHJlYWRzW3RocmVhZElkXTtcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzID0gc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChleGlzdGluZ1RocmVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGhyZWFkLnVwZGF0ZWRBdCAmJiBleGlzdGluZ1RocmVhZC51cGRhdGVkQXQgPiB1cGRhdGVkQXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLnRocmVhZHMsXG4gICAgICAgICAgICAgICAgICBbdGhyZWFkSWRdOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmV4aXN0aW5nVGhyZWFkLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmV4aXN0aW5nVGhyZWFkLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgIC4uLm1ldGFkYXRhMlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgKGVycm9yKSA9PiBuZXcgRWRpdFRocmVhZE1ldGFkYXRhRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIFtyb29tXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQWRkUmVhY3Rpb24oKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkgPT4ge1xuICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgdXNlcklkID0gZ2V0Q3VycmVudFVzZXJJZChyb29tKTtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMigpO1xuICAgICAgICBzdG9yZS5wdXNoT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgICAgdHlwZTogXCJhZGQtcmVhY3Rpb25cIixcbiAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgcmVhY3Rpb246IHtcbiAgICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgIH0pO1xuICAgICAgICByb29tW2tJbnRlcm5hbF0uY29tbWVudHMuYWRkUmVhY3Rpb24oeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KS50aGVuKFxuICAgICAgICAgIChhZGRlZFJlYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gc3RhdGUudGhyZWFkc1t0aHJlYWRJZF07XG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlcyA9IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUaHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgdGhyZWFkczoge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUudGhyZWFkcyxcbiAgICAgICAgICAgICAgICAgIFt0aHJlYWRJZF06IGFkZFJlYWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1RocmVhZCxcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgICAgICAgICBhZGRlZFJlYWN0aW9uXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgKGVycm9yKSA9PiBuZXcgQWRkUmVhY3Rpb25FcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgIGVtb2ppXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBbcm9vbV1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJlbW92ZVJlYWN0aW9uKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgICh7IHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pID0+IHtcbiAgICAgICAgY29uc3QgdXNlcklkID0gZ2V0Q3VycmVudFVzZXJJZChyb29tKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IG5hbm9pZDIoKTtcbiAgICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICAgIHR5cGU6IFwicmVtb3ZlLXJlYWN0aW9uXCIsXG4gICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgIGVtb2ppLFxuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICByZW1vdmVkQXQsXG4gICAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICB9KTtcbiAgICAgICAgcm9vbVtrSW50ZXJuYWxdLmNvbW1lbnRzLnJlbW92ZVJlYWN0aW9uKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkudGhlbihcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gc3RhdGUudGhyZWFkc1t0aHJlYWRJZF07XG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRPcHRpbWlzdGljVXBkYXRlcyA9IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUaHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgdGhyZWFkczoge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUudGhyZWFkcyxcbiAgICAgICAgICAgICAgICAgIFt0aHJlYWRJZF06IHJlbW92ZVJlYWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1RocmVhZCxcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgICAgICAgICBlbW9qaSxcbiAgICAgICAgICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkQXRcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICAoZXJyb3IpID0+IG5ldyBSZW1vdmVSZWFjdGlvbkVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgICAgZW1vamlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIFtyb29tXVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlQ3JlYXRlQ29tbWVudCgpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIHJldHVybiBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAoeyB0aHJlYWRJZCwgYm9keSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRJZCA9IGNyZWF0ZUNvbW1lbnRJZCgpO1xuICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgY29tbWVudCA9IHtcbiAgICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICB0eXBlOiBcImNvbW1lbnRcIixcbiAgICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgICAgdXNlcklkOiBnZXRDdXJyZW50VXNlcklkKHJvb20pLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgcmVhY3Rpb25zOiBbXVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQyKCk7XG4gICAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgICB0eXBlOiBcImNyZWF0ZS1jb21tZW50XCIsXG4gICAgICAgICAgY29tbWVudCxcbiAgICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgIH0pO1xuICAgICAgICByb29tW2tJbnRlcm5hbF0uY29tbWVudHMuY3JlYXRlQ29tbWVudCh7IHRocmVhZElkLCBjb21tZW50SWQsIGJvZHkgfSkudGhlbihcbiAgICAgICAgICAobmV3Q29tbWVudCkgPT4ge1xuICAgICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXMgPSBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbiA9IE9iamVjdC52YWx1ZXMoXG4gICAgICAgICAgICAgICAgc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zXG4gICAgICAgICAgICAgICkuZmluZCgobm90aWZpY2F0aW9uKSA9PiBub3RpZmljYXRpb24udGhyZWFkSWQgPT09IHRocmVhZElkKTtcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEluYm94Tm90aWZpY2F0aW9ucyA9IGluYm94Tm90aWZpY2F0aW9uICE9PSB2b2lkIDAgPyB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgICAgICAgIFtpbmJveE5vdGlmaWNhdGlvbi5pZF06IHtcbiAgICAgICAgICAgICAgICAgIC4uLmluYm94Tm90aWZpY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgbm90aWZpZWRBdDogbmV3Q29tbWVudC5jcmVhdGVkQXQsXG4gICAgICAgICAgICAgICAgICByZWFkQXQ6IG5ld0NvbW1lbnQuY3JlYXRlZEF0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IDogc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLnRocmVhZHMsXG4gICAgICAgICAgICAgICAgICBbdGhyZWFkSWRdOiB1cHNlcnRDb21tZW50KGV4aXN0aW5nVGhyZWFkLCBuZXdDb21tZW50KVxuICAgICAgICAgICAgICAgICAgLy8gVXBzZXJ0IHRoZSBuZXcgY29tbWVudCBpbnRvIHRoZSB0aHJlYWQgY29tbWVudHMgbGlzdCAoaWYgYXBwbGljYWJsZSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogdXBkYXRlZEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgKGVycjIpID0+IG5ldyBDcmVhdGVDb21tZW50RXJyb3IoZXJyMiwge1xuICAgICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICAgIH0sXG4gICAgICBbcm9vbV1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUVkaXRDb21tZW50KCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgICh7IHRocmVhZElkLCBjb21tZW50SWQsIGJvZHkgfSkgPT4ge1xuICAgICAgICBjb25zdCBlZGl0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQyKCk7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHN0b3JlLmdldCgpLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zb2xlMi53YXJuKFxuICAgICAgICAgICAgYEludGVybmFsIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIENhbm5vdCBlZGl0IGNvbW1lbnQgaW4gdGhyZWFkIFwiJHt0aHJlYWRJZH1cIiBiZWNhdXNlIHRoZSB0aHJlYWQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgICAgICAgKGNvbW1lbnQyKSA9PiBjb21tZW50Mi5pZCA9PT0gY29tbWVudElkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChjb21tZW50ID09PSB2b2lkIDAgfHwgY29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnNvbGUyLndhcm4oXG4gICAgICAgICAgICBgSW50ZXJuYWwgdW5leHBlY3RlZCBiZWhhdmlvci4gQ2Fubm90IGVkaXQgY29tbWVudCBcIiR7Y29tbWVudElkfVwiIGluIHRocmVhZCBcIiR7dGhyZWFkSWR9XCIgYmVjYXVzZSB0aGUgY29tbWVudCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGUuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgICB0eXBlOiBcImVkaXQtY29tbWVudFwiLFxuICAgICAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgICAgIC4uLmNvbW1lbnQsXG4gICAgICAgICAgICBlZGl0ZWRBdCxcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb21ba0ludGVybmFsXS5jb21tZW50cy5lZGl0Q29tbWVudCh7IHRocmVhZElkLCBjb21tZW50SWQsIGJvZHkgfSkudGhlbihcbiAgICAgICAgICAoZWRpdGVkQ29tbWVudCkgPT4ge1xuICAgICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXMgPSBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLnRocmVhZHMsXG4gICAgICAgICAgICAgICAgICBbdGhyZWFkSWRdOiB1cHNlcnRDb21tZW50KGV4aXN0aW5nVGhyZWFkLCBlZGl0ZWRDb21tZW50KVxuICAgICAgICAgICAgICAgICAgLy8gVXBzZXJ0IHRoZSBlZGl0ZWQgY29tbWVudCBpbnRvIHRoZSB0aHJlYWQgY29tbWVudHMgbGlzdCAoaWYgYXBwbGljYWJsZSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICAoZXJyb3IpID0+IG5ldyBFZGl0Q29tbWVudEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgICAgYm9keVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgW3Jvb21dXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VEZWxldGVDb21tZW50KCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgICh7IHRocmVhZElkLCBjb21tZW50SWQgfSkgPT4ge1xuICAgICAgICBjb25zdCBkZWxldGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMigpO1xuICAgICAgICBzdG9yZS5wdXNoT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgICAgdHlwZTogXCJkZWxldGUtY29tbWVudFwiLFxuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICBkZWxldGVkQXQsXG4gICAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICB9KTtcbiAgICAgICAgcm9vbVtrSW50ZXJuYWxdLmNvbW1lbnRzLmRlbGV0ZUNvbW1lbnQoeyB0aHJlYWRJZCwgY29tbWVudElkIH0pLnRoZW4oXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgc3RvcmUuc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0YXRlLnRocmVhZHNbdGhyZWFkSWRdO1xuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXMgPSBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogdXBkYXRlZE9wdGltaXN0aWNVcGRhdGVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIHRocmVhZHM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLnRocmVhZHMsXG4gICAgICAgICAgICAgICAgICBbdGhyZWFkSWRdOiBkZWxldGVDb21tZW50KFxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1RocmVhZCxcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkQXRcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiB1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICAoZXJyb3IpID0+IG5ldyBEZWxldGVDb21tZW50RXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgICAgY29tbWVudElkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBbcm9vbV1cbiAgICApO1xuICB9XG4gIGNvbnN0IHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMgPSBjbGllbnRba0ludGVybmFsXS5yZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zO1xuICBjb25zdCBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIHVzZU1lbnRpb25TdWdnZXN0aW9ucyhzZWFyY2gpIHtcbiAgICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICAgIGNvbnN0IFttZW50aW9uU3VnZ2VzdGlvbnMsIHNldE1lbnRpb25TdWdnZXN0aW9uc10gPSBSZWFjdDIudXNlU3RhdGUoKTtcbiAgICBjb25zdCBsYXN0SW52b2tlZEF0ID0gUmVhY3QyLnVzZVJlZigpO1xuICAgIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKHNlYXJjaCA9PT0gdm9pZCAwIHx8ICFyZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnNBcmdzID0geyB0ZXh0OiBzZWFyY2gsIHJvb21JZDogcm9vbS5pZCB9O1xuICAgICAgY29uc3QgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGVLZXkgPSBzdHJpbmdpZnkoXG4gICAgICAgIHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnNBcmdzXG4gICAgICApO1xuICAgICAgbGV0IGRlYm91bmNlVGltZW91dDtcbiAgICAgIGxldCBpc0NhbmNlbGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBnZXRNZW50aW9uU3VnZ2VzdGlvbnMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGFzdEludm9rZWRBdC5jdXJyZW50ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgY29uc3QgbWVudGlvblN1Z2dlc3Rpb25zMiA9IGF3YWl0IHJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMoXG4gICAgICAgICAgICByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zQXJnc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFpc0NhbmNlbGVkKSB7XG4gICAgICAgICAgICBzZXRNZW50aW9uU3VnZ2VzdGlvbnMobWVudGlvblN1Z2dlc3Rpb25zMik7XG4gICAgICAgICAgICBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZS5zZXQoXG4gICAgICAgICAgICAgIG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlS2V5LFxuICAgICAgICAgICAgICBtZW50aW9uU3VnZ2VzdGlvbnMyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlMi5lcnJvcihlcnJvcj8ubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAobWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUuaGFzKG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlS2V5KSkge1xuICAgICAgICBzZXRNZW50aW9uU3VnZ2VzdGlvbnMoXG4gICAgICAgICAgbWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUuZ2V0KG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlS2V5KVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICghbGFzdEludm9rZWRBdC5jdXJyZW50IHx8IE1hdGguYWJzKHBlcmZvcm1hbmNlLm5vdygpIC0gbGFzdEludm9rZWRBdC5jdXJyZW50KSA+IE1FTlRJT05fU1VHR0VTVElPTlNfREVCT1VOQ0UpIHtcbiAgICAgICAgdm9pZCBnZXRNZW50aW9uU3VnZ2VzdGlvbnMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYm91bmNlVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB2b2lkIGdldE1lbnRpb25TdWdnZXN0aW9ucygpO1xuICAgICAgICB9LCBNRU5USU9OX1NVR0dFU1RJT05TX0RFQk9VTkNFKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlzQ2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGRlYm91bmNlVGltZW91dCk7XG4gICAgICB9O1xuICAgIH0sIFtyb29tLmlkLCBzZWFyY2hdKTtcbiAgICByZXR1cm4gbWVudGlvblN1Z2dlc3Rpb25zO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVRocmVhZFN1YnNjcmlwdGlvbih0aHJlYWRJZCkge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9uID0gc2VsZWN0ZWRJbmJveE5vdGlmaWNhdGlvbnMoc3RhdGUpLmZpbmQoXG4gICAgICAgICAgKGluYm94Tm90aWZpY2F0aW9uMikgPT4gaW5ib3hOb3RpZmljYXRpb24yLnRocmVhZElkID09PSB0aHJlYWRJZFxuICAgICAgICApO1xuICAgICAgICBjb25zdCB0aHJlYWQgPSBzdGF0ZS50aHJlYWRzW3RocmVhZElkXTtcbiAgICAgICAgaWYgKGluYm94Tm90aWZpY2F0aW9uID09PSB2b2lkIDAgfHwgdGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBcIm5vdC1zdWJzY3JpYmVkXCJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBcInN1YnNjcmliZWRcIixcbiAgICAgICAgICB1bnJlYWRTaW5jZTogaW5ib3hOb3RpZmljYXRpb24ucmVhZEF0XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgW3RocmVhZElkXVxuICAgICk7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc2VsZWN0b3JcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHVzZU1hcmtUaHJlYWRBc1JlYWQoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHRocmVhZElkKSA9PiB7XG4gICAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9uID0gT2JqZWN0LnZhbHVlcyhcbiAgICAgICAgICBzdG9yZS5nZXQoKS5pbmJveE5vdGlmaWNhdGlvbnNcbiAgICAgICAgKS5maW5kKChpbmJveE5vdGlmaWNhdGlvbjIpID0+IGluYm94Tm90aWZpY2F0aW9uMi50aHJlYWRJZCA9PT0gdGhyZWFkSWQpO1xuICAgICAgICBpZiAoIWluYm94Tm90aWZpY2F0aW9uKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMigpO1xuICAgICAgICBjb25zdCBub3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgc3RvcmUucHVzaE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICAgIHR5cGU6IFwibWFyay1pbmJveC1ub3RpZmljYXRpb24tYXMtcmVhZFwiLFxuICAgICAgICAgIGlkOiBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZDogaW5ib3hOb3RpZmljYXRpb24uaWQsXG4gICAgICAgICAgcmVhZEF0OiBub3dcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb21ba0ludGVybmFsXS5ub3RpZmljYXRpb25zLm1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbi5pZCkudGhlbihcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgICAgICAgIFtpbmJveE5vdGlmaWNhdGlvbi5pZF06IHtcbiAgICAgICAgICAgICAgICAgIC4uLmluYm94Tm90aWZpY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgcmVhZEF0OiBub3dcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgICAoZXJyb3IpID0+IG5ldyBNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWQ6IGluYm94Tm90aWZpY2F0aW9uLmlkXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBbcm9vbV1cbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIG1ha2VOb3RpZmljYXRpb25TZXR0aW5nc1F1ZXJ5S2V5KHJvb21JZCkge1xuICAgIHJldHVybiBgJHtyb29tSWR9Ok5PVElGSUNBVElPTl9TRVRUSU5HU2A7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0SW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyhyb29tLCBxdWVyeUtleSwgeyByZXRyeUNvdW50IH0gPSB7IHJldHJ5Q291bnQ6IDAgfSkge1xuICAgIGNvbnN0IGV4aXN0aW5nUmVxdWVzdCA9IHJlcXVlc3RzQnlRdWVyeS5nZXQocXVlcnlLZXkpO1xuICAgIGlmIChleGlzdGluZ1JlcXVlc3QgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBleGlzdGluZ1JlcXVlc3Q7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSByb29tW2tJbnRlcm5hbF0ubm90aWZpY2F0aW9ucy5nZXRSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MoKTtcbiAgICAgIHJlcXVlc3RzQnlRdWVyeS5zZXQocXVlcnlLZXksIHJlcXVlc3QpO1xuICAgICAgc3RvcmUuc2V0UXVlcnlTdGF0ZShxdWVyeUtleSwge1xuICAgICAgICBpc0xvYWRpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCByZXF1ZXN0O1xuICAgICAgc3RvcmUudXBkYXRlUm9vbUluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbS5pZCwgc2V0dGluZ3MsIHF1ZXJ5S2V5KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlcXVlc3RzQnlRdWVyeS5kZWxldGUocXVlcnlLZXkpO1xuICAgICAgcmV0cnlFcnJvcigoKSA9PiB7XG4gICAgICAgIHZvaWQgZ2V0SW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyhyb29tLCBxdWVyeUtleSwge1xuICAgICAgICAgIHJldHJ5Q291bnQ6IHJldHJ5Q291bnQgKyAxXG4gICAgICAgIH0pO1xuICAgICAgfSwgcmV0cnlDb3VudCk7XG4gICAgICBzdG9yZS5zZXRRdWVyeVN0YXRlKHF1ZXJ5S2V5LCB7XG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MoKSB7XG4gICAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZU5vdGlmaWNhdGlvblNldHRpbmdzUXVlcnlLZXkocm9vbS5pZCk7XG4gICAgICB2b2lkIGdldEluYm94Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbSwgcXVlcnlLZXkpO1xuICAgIH0sIFtyb29tXSk7XG4gICAgY29uc3QgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzID0gdXNlVXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCk7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgICAoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBzdGF0ZS5xdWVyaWVzW21ha2VOb3RpZmljYXRpb25TZXR0aW5nc1F1ZXJ5S2V5KHJvb20uaWQpXTtcbiAgICAgICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDAgfHwgcXVlcnkuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHsgaXNMb2FkaW5nOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5LmVycm9yICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4geyBpc0xvYWRpbmc6IGZhbHNlLCBlcnJvcjogcXVlcnkuZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgc2V0dGluZ3M6IHNlbGVjdE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb20uaWQsIHN0YXRlKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIFtyb29tXVxuICAgICk7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHNlbGVjdG9yXG4gICAgKTtcbiAgICByZXR1cm4gUmVhY3QyLnVzZU1lbW8oKCkgPT4ge1xuICAgICAgcmV0dXJuIFtzZXR0aW5ncywgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzXTtcbiAgICB9LCBbc2V0dGluZ3MsIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc10pO1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc1N1c3BlbnNlKCkge1xuICAgIGNvbnN0IHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyA9IHVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpO1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBtYWtlTm90aWZpY2F0aW9uU2V0dGluZ3NRdWVyeUtleShyb29tLmlkKTtcbiAgICBjb25zdCBxdWVyeSA9IHN0b3JlLmdldCgpLnF1ZXJpZXNbcXVlcnlLZXldO1xuICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwIHx8IHF1ZXJ5LmlzTG9hZGluZykge1xuICAgICAgdGhyb3cgZ2V0SW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyhyb29tLCBxdWVyeUtleSk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5lcnJvcikge1xuICAgICAgdGhyb3cgcXVlcnkuZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdG9yID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICAgKHN0YXRlKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICBzZXR0aW5nczogc2VsZWN0Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbS5pZCwgc3RhdGUpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgW3Jvb21dXG4gICAgKTtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc2VsZWN0b3JcbiAgICApO1xuICAgIHJldHVybiBSZWFjdDIudXNlTWVtbygoKSA9PiB7XG4gICAgICByZXR1cm4gW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdO1xuICAgIH0sIFtzZXR0aW5ncywgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzXSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlVXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCkge1xuICAgIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gICAgcmV0dXJuIFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAgIChzZXR0aW5ncykgPT4ge1xuICAgICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBuYW5vaWQyKCk7XG4gICAgICAgIHN0b3JlLnB1c2hPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIHR5cGU6IFwidXBkYXRlLW5vdGlmaWNhdGlvbi1zZXR0aW5nc1wiLFxuICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICBzZXR0aW5nc1xuICAgICAgICB9KTtcbiAgICAgICAgcm9vbVtrSW50ZXJuYWxdLm5vdGlmaWNhdGlvbnMudXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzKS50aGVuKFxuICAgICAgICAgIChzZXR0aW5nczIpID0+IHtcbiAgICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICBub3RpZmljYXRpb25TZXR0aW5nczoge1xuICAgICAgICAgICAgICAgIFtyb29tLmlkXTogc2V0dGluZ3MyXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICAoZXJyb3IpID0+IG5ldyBVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc0Vycm9yKGVycm9yLCB7XG4gICAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgW3Jvb21dXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VDdXJyZW50VXNlcklkKCkge1xuICAgIHJldHVybiB1c2VTZWxmKCh1c2VyKSA9PiB0eXBlb2YgdXNlci5pZCA9PT0gXCJzdHJpbmdcIiA/IHVzZXIuaWQgOiBudWxsKTtcbiAgfVxuICBjb25zdCBidW5kbGUgPSB7XG4gICAgUm9vbUNvbnRleHQsXG4gICAgUm9vbVByb3ZpZGVyOiBSb29tUHJvdmlkZXJPdXRlcixcbiAgICB1c2VSb29tLFxuICAgIHVzZVN0YXR1cyxcbiAgICB1c2VCYXRjaCxcbiAgICB1c2VCcm9hZGNhc3RFdmVudCxcbiAgICB1c2VPdGhlcnNMaXN0ZW5lcixcbiAgICB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyLFxuICAgIHVzZUVycm9yTGlzdGVuZXIsXG4gICAgdXNlRXZlbnRMaXN0ZW5lcixcbiAgICB1c2VIaXN0b3J5LFxuICAgIHVzZVVuZG8sXG4gICAgdXNlUmVkbyxcbiAgICB1c2VDYW5SZWRvLFxuICAgIHVzZUNhblVuZG8sXG4gICAgLy8gVGhlc2UgYXJlIGp1c3QgYWxpYXNlcy4gVGhlIHBhc3NlZC1pbiBrZXkgd2lsbCBkZWZpbmUgdGhlaXIgcmV0dXJuIHZhbHVlcy5cbiAgICB1c2VMaXN0OiB1c2VMZWdhY3lLZXksXG4gICAgdXNlTWFwOiB1c2VMZWdhY3lLZXksXG4gICAgdXNlT2JqZWN0OiB1c2VMZWdhY3lLZXksXG4gICAgdXNlU3RvcmFnZVJvb3QsXG4gICAgdXNlU3RvcmFnZSxcbiAgICB1c2VTZWxmLFxuICAgIHVzZU15UHJlc2VuY2UsXG4gICAgdXNlVXBkYXRlTXlQcmVzZW5jZSxcbiAgICB1c2VPdGhlcnMsXG4gICAgdXNlT3RoZXJzTWFwcGVkLFxuICAgIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHMsXG4gICAgdXNlT3RoZXIsXG4gICAgdXNlTXV0YXRpb24sXG4gICAgdXNlVGhyZWFkcyxcbiAgICB1c2VDcmVhdGVUaHJlYWQsXG4gICAgdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICAgIHVzZUNyZWF0ZUNvbW1lbnQsXG4gICAgdXNlRWRpdENvbW1lbnQsXG4gICAgdXNlRGVsZXRlQ29tbWVudCxcbiAgICB1c2VBZGRSZWFjdGlvbixcbiAgICB1c2VSZW1vdmVSZWFjdGlvbixcbiAgICB1c2VNYXJrVGhyZWFkQXNSZWFkLFxuICAgIHVzZVRocmVhZFN1YnNjcmlwdGlvbixcbiAgICB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgdXNlVXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgIC4uLnNoYXJlZCxcbiAgICBzdXNwZW5zZToge1xuICAgICAgUm9vbUNvbnRleHQsXG4gICAgICBSb29tUHJvdmlkZXI6IFJvb21Qcm92aWRlck91dGVyLFxuICAgICAgdXNlUm9vbSxcbiAgICAgIHVzZVN0YXR1cyxcbiAgICAgIHVzZUJhdGNoLFxuICAgICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgICB1c2VPdGhlcnNMaXN0ZW5lcixcbiAgICAgIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIsXG4gICAgICB1c2VFcnJvckxpc3RlbmVyLFxuICAgICAgdXNlRXZlbnRMaXN0ZW5lcixcbiAgICAgIHVzZUhpc3RvcnksXG4gICAgICB1c2VVbmRvLFxuICAgICAgdXNlUmVkbyxcbiAgICAgIHVzZUNhblJlZG8sXG4gICAgICB1c2VDYW5VbmRvLFxuICAgICAgLy8gTGVnYWN5IGhvb2tzXG4gICAgICB1c2VMaXN0OiB1c2VMZWdhY3lLZXlTdXNwZW5zZSxcbiAgICAgIHVzZU1hcDogdXNlTGVnYWN5S2V5U3VzcGVuc2UsXG4gICAgICB1c2VPYmplY3Q6IHVzZUxlZ2FjeUtleVN1c3BlbnNlLFxuICAgICAgdXNlU3RvcmFnZVJvb3QsXG4gICAgICB1c2VTdG9yYWdlOiB1c2VTdG9yYWdlU3VzcGVuc2UsXG4gICAgICB1c2VTZWxmOiB1c2VTZWxmU3VzcGVuc2UsXG4gICAgICB1c2VNeVByZXNlbmNlLFxuICAgICAgdXNlVXBkYXRlTXlQcmVzZW5jZSxcbiAgICAgIHVzZU90aGVyczogdXNlT3RoZXJzU3VzcGVuc2UsXG4gICAgICB1c2VPdGhlcnNNYXBwZWQ6IHVzZU90aGVyc01hcHBlZFN1c3BlbnNlLFxuICAgICAgdXNlT3RoZXJzQ29ubmVjdGlvbklkczogdXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlLFxuICAgICAgdXNlT3RoZXI6IHVzZU90aGVyU3VzcGVuc2UsXG4gICAgICB1c2VNdXRhdGlvbixcbiAgICAgIHVzZVRocmVhZHM6IHVzZVRocmVhZHNTdXNwZW5zZSxcbiAgICAgIHVzZUNyZWF0ZVRocmVhZCxcbiAgICAgIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICAgIHVzZUNyZWF0ZUNvbW1lbnQsXG4gICAgICB1c2VFZGl0Q29tbWVudCxcbiAgICAgIHVzZURlbGV0ZUNvbW1lbnQsXG4gICAgICB1c2VBZGRSZWFjdGlvbixcbiAgICAgIHVzZVJlbW92ZVJlYWN0aW9uLFxuICAgICAgdXNlTWFya1RocmVhZEFzUmVhZCxcbiAgICAgIHVzZVRocmVhZFN1YnNjcmlwdGlvbixcbiAgICAgIHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nczogdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2UsXG4gICAgICB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgICAuLi5zaGFyZWQuc3VzcGVuc2VcbiAgICB9LFxuICAgIFtrSW50ZXJuYWxdOiB7XG4gICAgICB1c2VDdXJyZW50VXNlcklkLFxuICAgICAgaGFzUmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9uczogcmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyAhPT0gdm9pZCAwLFxuICAgICAgdXNlTWVudGlvblN1Z2dlc3Rpb25zXG4gICAgfVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1bmRsZSwga0ludGVybmFsLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VXNlcklkKHJvb20pIHtcbiAgY29uc3Qgc2VsZiA9IHJvb20uZ2V0U2VsZigpO1xuICBpZiAoc2VsZiA9PT0gbnVsbCB8fCBzZWxmLmlkID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gXCJhbm9ueW1vdXNcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2VsZi5pZDtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQXBpRXJyb3IoZXJyKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtlcnIuc3RhdHVzfTogJHtlcnIubWVzc2FnZX1gO1xuICBpZiAoZXJyLmRldGFpbHM/LmVycm9yID09PSBcIkZPUkJJRERFTlwiKSB7XG4gICAgY29uc3QgZGV0YWlsZWRNZXNzYWdlID0gW21lc3NhZ2UsIGVyci5kZXRhaWxzLnN1Z2dlc3Rpb24sIGVyci5kZXRhaWxzLmRvY3NdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiXFxuXCIpO1xuICAgIGNvbnNvbGUyLmVycm9yKGRldGFpbGVkTWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlUXVlcnlLZXkocm9vbUlkLCBvcHRpb25zKSB7XG4gIHJldHVybiBgJHtyb29tSWR9LSR7c3RyaW5naWZ5KG9wdGlvbnMgPz8ge30pfWA7XG59XG5cbi8vIHNyYy9zaGFyZWQudHNcbmZ1bmN0aW9uIHVzZVNoYXJlZENvbnRleHRCdW5kbGUoKSB7XG4gIGNvbnN0IHJvb21Db250ZXh0QnVuZGxlID0gdXNlQ29udGV4dDIoQ29udGV4dEJ1bmRsZSk7XG4gIGNvbnN0IGxpdmVibG9ja3NDb250ZXh0QnVuZGxlID0gdXNlQ29udGV4dDIoQ29udGV4dEJ1bmRsZTIpO1xuICBpZiAocm9vbUNvbnRleHRCdW5kbGUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gcm9vbUNvbnRleHRCdW5kbGU7XG4gIH0gZWxzZSBpZiAobGl2ZWJsb2Nrc0NvbnRleHRCdW5kbGUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbGl2ZWJsb2Nrc0NvbnRleHRCdW5kbGU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJMaXZlYmxvY2tzUHJvdmlkZXIgb3IgUm9vbVByb3ZpZGVyIGFyZSBtaXNzaW5nIGZyb20gdGhlIFJlYWN0IHRyZWUuXCJcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVTaGFyZWRDb250ZXh0KGNsaWVudCkge1xuICBjb25zdCB1c2Vyc1N0b3JlID0gY2xpZW50W2tJbnRlcm5hbDJdLnVzZXJzU3RvcmU7XG4gIGNvbnN0IHJvb21zSW5mb1N0b3JlID0gY2xpZW50W2tJbnRlcm5hbDJdLnJvb21zSW5mb1N0b3JlO1xuICBmdW5jdGlvbiB1c2VVc2VyKHVzZXJJZCkge1xuICAgIGNvbnN0IGdldFVzZXJTdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAgICgpID0+IHVzZXJzU3RvcmUuZ2V0U3RhdGUodXNlcklkKSxcbiAgICAgIFt1c2VySWRdXG4gICAgKTtcbiAgICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICAgIHZvaWQgdXNlcnNTdG9yZS5nZXQodXNlcklkKTtcbiAgICB9LCBbdXNlcklkXSk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoXG4gICAgICB1c2Vyc1N0b3JlLnN1YnNjcmliZSxcbiAgICAgIGdldFVzZXJTdGF0ZSxcbiAgICAgIGdldFVzZXJTdGF0ZVxuICAgICk7XG4gICAgcmV0dXJuIHN0YXRlID8ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICB1c2VyOiBzdGF0ZS5kYXRhXG4gICAgfSA6IHsgaXNMb2FkaW5nOiB0cnVlIH07XG4gIH1cbiAgZnVuY3Rpb24gdXNlVXNlclN1c3BlbnNlKHVzZXJJZCkge1xuICAgIGNvbnN0IGdldFVzZXJTdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAgICgpID0+IHVzZXJzU3RvcmUuZ2V0U3RhdGUodXNlcklkKSxcbiAgICAgIFt1c2VySWRdXG4gICAgKTtcbiAgICBjb25zdCB1c2VyU3RhdGUgPSBnZXRVc2VyU3RhdGUoKTtcbiAgICBpZiAoIXVzZXJTdGF0ZSB8fCB1c2VyU3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgICB0aHJvdyB1c2Vyc1N0b3JlLmdldCh1c2VySWQpO1xuICAgIH1cbiAgICBpZiAodXNlclN0YXRlLmVycm9yKSB7XG4gICAgICB0aHJvdyB1c2VyU3RhdGUuZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUyKFxuICAgICAgdXNlcnNTdG9yZS5zdWJzY3JpYmUsXG4gICAgICBnZXRVc2VyU3RhdGUsXG4gICAgICBnZXRVc2VyU3RhdGVcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHVzZXI6IHN0YXRlPy5kYXRhXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1c2VSb29tSW5mbyhyb29tSWQpIHtcbiAgICBjb25zdCBnZXRSb29tSW5mb1N0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgICAgKCkgPT4gcm9vbXNJbmZvU3RvcmUuZ2V0U3RhdGUocm9vbUlkKSxcbiAgICAgIFtyb29tSWRdXG4gICAgKTtcbiAgICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICAgIHZvaWQgcm9vbXNJbmZvU3RvcmUuZ2V0KHJvb21JZCk7XG4gICAgfSwgW3Jvb21JZF0pO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUyKFxuICAgICAgcm9vbXNJbmZvU3RvcmUuc3Vic2NyaWJlLFxuICAgICAgZ2V0Um9vbUluZm9TdGF0ZSxcbiAgICAgIGdldFJvb21JbmZvU3RhdGVcbiAgICApO1xuICAgIHJldHVybiBzdGF0ZSA/IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgaW5mbzogc3RhdGUuZGF0YVxuICAgIH0gOiB7IGlzTG9hZGluZzogdHJ1ZSB9O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVJvb21JbmZvU3VzcGVuc2Uocm9vbUlkKSB7XG4gICAgY29uc3QgZ2V0Um9vbUluZm9TdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAgICgpID0+IHJvb21zSW5mb1N0b3JlLmdldFN0YXRlKHJvb21JZCksXG4gICAgICBbcm9vbUlkXVxuICAgICk7XG4gICAgY29uc3Qgcm9vbUluZm9TdGF0ZSA9IGdldFJvb21JbmZvU3RhdGUoKTtcbiAgICBpZiAoIXJvb21JbmZvU3RhdGUgfHwgcm9vbUluZm9TdGF0ZS5pc0xvYWRpbmcpIHtcbiAgICAgIHRocm93IHJvb21zSW5mb1N0b3JlLmdldChyb29tSWQpO1xuICAgIH1cbiAgICBpZiAocm9vbUluZm9TdGF0ZS5lcnJvcikge1xuICAgICAgdGhyb3cgcm9vbUluZm9TdGF0ZS5lcnJvcjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoXG4gICAgICByb29tc0luZm9TdG9yZS5zdWJzY3JpYmUsXG4gICAgICBnZXRSb29tSW5mb1N0YXRlLFxuICAgICAgZ2V0Um9vbUluZm9TdGF0ZVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgaW5mbzogc3RhdGU/LmRhdGFcbiAgICB9O1xuICB9XG4gIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICB1c2VVc2VyLFxuICAgIHVzZVJvb21JbmZvLFxuICAgIHN1c3BlbnNlOiB7XG4gICAgICB1c2VVc2VyOiB1c2VVc2VyU3VzcGVuc2UsXG4gICAgICB1c2VSb29tSW5mbzogdXNlUm9vbUluZm9TdXNwZW5zZVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGJ1bmRsZTtcbn1cblxuLy8gc3JjL2xpdmVibG9ja3MudHN4XG52YXIgQ29udGV4dEJ1bmRsZTIgPSBjcmVhdGVDb250ZXh0MihudWxsKTtcbmZ1bmN0aW9uIHVzZUxpdmVibG9ja3NDb250ZXh0QnVuZGxlKCkge1xuICBjb25zdCBidW5kbGUgPSB1c2VDb250ZXh0MyhDb250ZXh0QnVuZGxlMik7XG4gIGlmIChidW5kbGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJMaXZlYmxvY2tzUHJvdmlkZXIgaXMgbWlzc2luZyBmcm9tIHRoZSBSZWFjdCB0cmVlLlwiKTtcbiAgfVxuICByZXR1cm4gYnVuZGxlO1xufVxudmFyIFBPTExJTkdfSU5URVJWQUwyID0gNjAgKiAxZTM7XG52YXIgSU5CT1hfTk9USUZJQ0FUSU9OU19RVUVSWSA9IFwiSU5CT1hfTk9USUZJQ0FUSU9OU1wiO1xuZnVuY3Rpb24gY3JlYXRlTGl2ZWJsb2Nrc0NvbnRleHQoY2xpZW50KSB7XG4gIGNvbnN0IHNoYXJlZCA9IGNyZWF0ZVNoYXJlZENvbnRleHQoY2xpZW50KTtcbiAgY29uc3Qgc3RvcmUgPSBjbGllbnRba0ludGVybmFsM10uY2FjaGVTdG9yZTtcbiAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IGNsaWVudFtrSW50ZXJuYWwzXS5ub3RpZmljYXRpb25zO1xuICBmdW5jdGlvbiBMaXZlYmxvY2tzUHJvdmlkZXIocHJvcHMpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFxuICAgICAgQ29udGV4dEJ1bmRsZTIuUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiBidW5kbGVcbiAgICAgIH0sXG4gICAgICBwcm9wcy5jaGlsZHJlblxuICAgICk7XG4gIH1cbiAgbGV0IGZldGNoSW5ib3hOb3RpZmljYXRpb25zUmVxdWVzdCA9IG51bGw7XG4gIGxldCBpbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycyA9IDA7XG4gIGxldCBsYXN0UmVxdWVzdGVkQXQ7XG4gIGNvbnN0IHBvbGxlciA9IG1ha2VQb2xsZXIyKHJlZnJlc2hUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyk7XG4gIGZ1bmN0aW9uIHJlZnJlc2hUaHJlYWRzQW5kTm90aWZpY2F0aW9ucygpIHtcbiAgICByZXR1cm4gbm90aWZpY2F0aW9ucy5nZXRJbmJveE5vdGlmaWNhdGlvbnMoeyBzaW5jZTogbGFzdFJlcXVlc3RlZEF0IH0pLnRoZW4oXG4gICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgIGxhc3RSZXF1ZXN0ZWRBdCA9IHJlc3VsdC5tZXRhLnJlcXVlc3RlZEF0O1xuICAgICAgICBzdG9yZS51cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyhcbiAgICAgICAgICByZXN1bHQudGhyZWFkcyxcbiAgICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgIHJlc3VsdC5kZWxldGVkVGhyZWFkcyxcbiAgICAgICAgICByZXN1bHQuZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgICBJTkJPWF9OT1RJRklDQVRJT05TX1FVRVJZXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gaW5jcmVtZW50SW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMoKSB7XG4gICAgaW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMrKztcbiAgICBwb2xsZXIuc3RhcnQoUE9MTElOR19JTlRFUlZBTDIpO1xuICB9XG4gIGZ1bmN0aW9uIGRlY3JlbWVudEluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzKCkge1xuICAgIGlmIChpbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycyA8PSAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBJbnRlcm5hbCB1bmV4cGVjdGVkIGJlaGF2aW9yLiBDYW5ub3QgZGVjcmVhc2Ugc3Vic2NyaWJlciBjb3VudCBmb3IgcXVlcnkgXCIke0lOQk9YX05PVElGSUNBVElPTlNfUVVFUll9XCJgXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycy0tO1xuICAgIGlmIChpbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycyA8PSAwKSB7XG4gICAgICBwb2xsZXIuc3RvcCgpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBmZXRjaEluYm94Tm90aWZpY2F0aW9ucyh7IHJldHJ5Q291bnQgfSA9IHsgcmV0cnlDb3VudDogMCB9KSB7XG4gICAgaWYgKGZldGNoSW5ib3hOb3RpZmljYXRpb25zUmVxdWVzdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZldGNoSW5ib3hOb3RpZmljYXRpb25zUmVxdWVzdDtcbiAgICB9XG4gICAgc3RvcmUuc2V0UXVlcnlTdGF0ZShJTkJPWF9OT1RJRklDQVRJT05TX1FVRVJZLCB7XG4gICAgICBpc0xvYWRpbmc6IHRydWVcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnNSZXF1ZXN0ID0gbm90aWZpY2F0aW9ucy5nZXRJbmJveE5vdGlmaWNhdGlvbnMoKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoSW5ib3hOb3RpZmljYXRpb25zUmVxdWVzdDtcbiAgICAgIHN0b3JlLnVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zKFxuICAgICAgICByZXN1bHQudGhyZWFkcyxcbiAgICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgcmVzdWx0LmRlbGV0ZWRUaHJlYWRzLFxuICAgICAgICByZXN1bHQuZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgICAgSU5CT1hfTk9USUZJQ0FUSU9OU19RVUVSWVxuICAgICAgKTtcbiAgICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPT09IHZvaWQgMCB8fCBsYXN0UmVxdWVzdGVkQXQgPiByZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdCkge1xuICAgICAgICBsYXN0UmVxdWVzdGVkQXQgPSByZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdDtcbiAgICAgIH1cbiAgICAgIHBvbGxlci5zdGFydChQT0xMSU5HX0lOVEVSVkFMMik7XG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGZldGNoSW5ib3hOb3RpZmljYXRpb25zUmVxdWVzdCA9IG51bGw7XG4gICAgICByZXRyeUVycm9yKCgpID0+IHtcbiAgICAgICAgdm9pZCBmZXRjaEluYm94Tm90aWZpY2F0aW9ucyh7XG4gICAgICAgICAgcmV0cnlDb3VudDogcmV0cnlDb3VudCArIDFcbiAgICAgICAgfSk7XG4gICAgICB9LCByZXRyeUNvdW50KTtcbiAgICAgIHN0b3JlLnNldFF1ZXJ5U3RhdGUoSU5CT1hfTk9USUZJQ0FUSU9OU19RVUVSWSwge1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zU2VsZWN0b3JDYWxsYmFjayhzdGF0ZSkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gc3RhdGUucXVlcmllc1tJTkJPWF9OT1RJRklDQVRJT05TX1FVRVJZXTtcbiAgICBpZiAocXVlcnkgPT09IHZvaWQgMCB8fCBxdWVyeS5pc0xvYWRpbmcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzTG9hZGluZzogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmVycm9yICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBxdWVyeS5lcnJvcixcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uczogc2VsZWN0ZWRJbmJveE5vdGlmaWNhdGlvbnMoc3RhdGUpLFxuICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zKCkge1xuICAgIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgICAgdm9pZCBmZXRjaEluYm94Tm90aWZpY2F0aW9ucygpO1xuICAgICAgaW5jcmVtZW50SW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMoKTtcbiAgICAgIHJldHVybiAoKSA9PiBkZWNyZW1lbnRJbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycygpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCByZXN1bHQgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICBzdG9yZS5nZXQsXG4gICAgICB1c2VJbmJveE5vdGlmaWNhdGlvbnNTZWxlY3RvckNhbGxiYWNrXG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlU2VsZWN0b3Ioc3RhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiBzZWxlY3RlZEluYm94Tm90aWZpY2F0aW9ucyhzdGF0ZSksXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZSgpIHtcbiAgICBjb25zdCBxdWVyeSA9IHN0b3JlLmdldCgpLnF1ZXJpZXNbSU5CT1hfTk9USUZJQ0FUSU9OU19RVUVSWV07XG4gICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDAgfHwgcXVlcnkuaXNMb2FkaW5nKSB7XG4gICAgICB0aHJvdyBmZXRjaEluYm94Tm90aWZpY2F0aW9ucygpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgcXVlcnkuZXJyb3I7XG4gICAgfVxuICAgIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaW5jcmVtZW50SW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRlY3JlbWVudEluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzKCk7XG4gICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2VTZWxlY3RvclxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoc3RhdGUpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoY29uc3Qgbm90aWZpY2F0aW9uIG9mIHNlbGVjdGVkSW5ib3hOb3RpZmljYXRpb25zKHN0YXRlKSkge1xuICAgICAgaWYgKG5vdGlmaWNhdGlvbi5yZWFkQXQgPT09IG51bGwgfHwgbm90aWZpY2F0aW9uLnJlYWRBdCA8IG5vdGlmaWNhdGlvbi5ub3RpZmllZEF0KSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuICBmdW5jdGlvbiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFNlbGVjdG9yKHN0YXRlKSB7XG4gICAgY29uc3QgcXVlcnkgPSBzdGF0ZS5xdWVyaWVzW0lOQk9YX05PVElGSUNBVElPTlNfUVVFUlldO1xuICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwIHx8IHF1ZXJ5LmlzTG9hZGluZykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNMb2FkaW5nOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAocXVlcnkuZXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHF1ZXJ5LmVycm9yLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGNvdW50OiBzZWxlY3RVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudChzdGF0ZSlcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50KCkge1xuICAgIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgICAgdm9pZCBmZXRjaEluYm94Tm90aWZpY2F0aW9ucygpO1xuICAgICAgaW5jcmVtZW50SW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMoKTtcbiAgICAgIHJldHVybiAoKSA9PiBkZWNyZW1lbnRJbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycygpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTZWxlY3RvclxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZVNlbGVjdG9yKHN0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBjb3VudDogc2VsZWN0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoc3RhdGUpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlKCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gc3RvcmUuZ2V0KCkucXVlcmllc1tJTkJPWF9OT1RJRklDQVRJT05TX1FVRVJZXTtcbiAgICBpZiAocXVlcnkgPT09IHZvaWQgMCB8fCBxdWVyeS5pc0xvYWRpbmcpIHtcbiAgICAgIHRocm93IGZldGNoSW5ib3hOb3RpZmljYXRpb25zKCk7XG4gICAgfVxuICAgIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaW5jcmVtZW50SW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRlY3JlbWVudEluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzKCk7XG4gICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgc3RvcmUuZ2V0LFxuICAgICAgdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZVNlbGVjdG9yXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoKSB7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrMygoaW5ib3hOb3RpZmljYXRpb25JZCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMygpO1xuICAgICAgY29uc3QgcmVhZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBzdG9yZS5wdXNoT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwibWFyay1pbmJveC1ub3RpZmljYXRpb24tYXMtcmVhZFwiLFxuICAgICAgICBpZDogb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkLFxuICAgICAgICByZWFkQXRcbiAgICAgIH0pO1xuICAgICAgbm90aWZpY2F0aW9ucy5tYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZCkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTm90aWZpY2F0aW9uID0gc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zW2luYm94Tm90aWZpY2F0aW9uSWRdO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nTm90aWZpY2F0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUuaW5ib3hOb3RpZmljYXRpb25zLFxuICAgICAgICAgICAgICAgIFtpbmJveE5vdGlmaWNhdGlvbklkXToge1xuICAgICAgICAgICAgICAgICAgLi4uZXhpc3RpbmdOb3RpZmljYXRpb24sXG4gICAgICAgICAgICAgICAgICByZWFkQXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiBzdGF0ZS5vcHRpbWlzdGljVXBkYXRlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICh1cGRhdGUpID0+IHVwZGF0ZS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sIFtdKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKCkge1xuICAgIHJldHVybiB1c2VDYWxsYmFjazMoKCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gbmFub2lkMygpO1xuICAgICAgY29uc3QgcmVhZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBzdG9yZS5wdXNoT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwibWFyay1pbmJveC1ub3RpZmljYXRpb25zLWFzLXJlYWRcIixcbiAgICAgICAgaWQ6IG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgcmVhZEF0XG4gICAgICB9KTtcbiAgICAgIG5vdGlmaWNhdGlvbnMubWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCgpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgQXJyYXkuZnJvbShPYmplY3QuZW50cmllcyhzdGF0ZS5pbmJveE5vdGlmaWNhdGlvbnMpKS5tYXAoXG4gICAgICAgICAgICAgICAgKFtpZCwgaW5ib3hOb3RpZmljYXRpb25dKSA9PiBbXG4gICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgIHsgLi4uaW5ib3hOb3RpZmljYXRpb24sIHJlYWRBdCB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgKHVwZGF0ZSkgPT4gdXBkYXRlLmlkICE9PSBvcHRpbWlzdGljVXBkYXRlSWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlczogc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAodXBkYXRlKSA9PiB1cGRhdGUuaWQgIT09IG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlVGhyZWFkRnJvbUNhY2hlKHRocmVhZElkKSB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSB1c2VDYWxsYmFjazMoXG4gICAgICAoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gc3RhdGUudGhyZWFkc1t0aHJlYWRJZF07XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnRlcm5hbCBlcnJvcjogdGhyZWFkIHdpdGggaWQgXCIke3RocmVhZElkfVwiIG5vdCBmb3VuZCBpbiBjYWNoZWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aHJlYWQ7XG4gICAgICB9LFxuICAgICAgW3RocmVhZElkXVxuICAgICk7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHN0b3JlLmdldCxcbiAgICAgIHNlbGVjdG9yXG4gICAgKTtcbiAgfVxuICBjb25zdCBjdXJyZW50VXNlcklkU3RvcmUgPSBjbGllbnRba0ludGVybmFsM10uY3VycmVudFVzZXJJZFN0b3JlO1xuICBmdW5jdGlvbiB1c2VDdXJyZW50VXNlcklkKCkge1xuICAgIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMoXG4gICAgICBjdXJyZW50VXNlcklkU3RvcmUuc3Vic2NyaWJlLFxuICAgICAgY3VycmVudFVzZXJJZFN0b3JlLmdldCxcbiAgICAgIGN1cnJlbnRVc2VySWRTdG9yZS5nZXRcbiAgICApO1xuICB9XG4gIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICBMaXZlYmxvY2tzUHJvdmlkZXIsXG4gICAgdXNlSW5ib3hOb3RpZmljYXRpb25zLFxuICAgIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICAgIHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgICB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgIC4uLnNoYXJlZCxcbiAgICBzdXNwZW5zZToge1xuICAgICAgTGl2ZWJsb2Nrc1Byb3ZpZGVyLFxuICAgICAgdXNlSW5ib3hOb3RpZmljYXRpb25zOiB1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZSxcbiAgICAgIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50OiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlLFxuICAgICAgdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkLFxuICAgICAgdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCxcbiAgICAgIC4uLnNoYXJlZC5zdXNwZW5zZVxuICAgIH0sXG4gICAgW2tJbnRlcm5hbDNdOiB7XG4gICAgICB1c2VUaHJlYWRGcm9tQ2FjaGUsXG4gICAgICB1c2VDdXJyZW50VXNlcklkXG4gICAgfVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1bmRsZSwga0ludGVybmFsMywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IHNoYWxsb3cgYXMgc2hhbGxvdzIgfSBmcm9tIFwiQGxpdmVibG9ja3MvY2xpZW50XCI7XG5kZXRlY3REdXBlcyhQS0dfTkFNRSwgUEtHX1ZFUlNJT04sIFBLR19GT1JNQVQpO1xuZXhwb3J0IHtcbiAgQ2xpZW50U2lkZVN1c3BlbnNlLFxuICBjcmVhdGVMaXZlYmxvY2tzQ29udGV4dCxcbiAgY3JlYXRlUm9vbUNvbnRleHQsXG4gIHNoYWxsb3cyIGFzIHNoYWxsb3csXG4gIHVzZUxpdmVibG9ja3NDb250ZXh0QnVuZGxlLFxuICB1c2VSb29tQ29udGV4dEJ1bmRsZSxcbiAgdXNlU2hhcmVkQ29udGV4dEJ1bmRsZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiZGV0ZWN0RHVwZXMiLCJQS0dfTkFNRSIsIlBLR19WRVJTSU9OIiwiUEtHX0ZPUk1BVCIsIlJlYWN0IiwiQ2xpZW50U2lkZVN1c3BlbnNlIiwicHJvcHMiLCJtb3VudGVkIiwic2V0TW91bnRlZCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiY3JlYXRlRWxlbWVudCIsIlN1c3BlbnNlIiwiZmFsbGJhY2siLCJjaGlsZHJlbiIsImtJbnRlcm5hbCIsImtJbnRlcm5hbDMiLCJtYWtlUG9sbGVyIiwibWFrZVBvbGxlcjIiLCJuYW5vaWQiLCJuYW5vaWQzIiwiUmVhY3QzIiwiY3JlYXRlQ29udGV4dCIsImNyZWF0ZUNvbnRleHQyIiwidXNlQ2FsbGJhY2siLCJ1c2VDYWxsYmFjazMiLCJ1c2VDb250ZXh0IiwidXNlQ29udGV4dDMiLCJ1c2VFZmZlY3Q1IiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZTMiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciIsInVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMiIsImFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMiLCJzZWxlY3RlZEluYm94Tm90aWZpY2F0aW9ucyIsInN0YXRlIiwicmVzdWx0IiwiT2JqZWN0IiwidmFsdWVzIiwiaW5ib3hOb3RpZmljYXRpb25zIiwic29ydCIsImEiLCJiIiwibm90aWZpZWRBdCIsImdldFRpbWUiLCJNQVhfRVJST1JfUkVUUllfQ09VTlQiLCJFUlJPUl9SRVRSWV9JTlRFUlZBTCIsInJldHJ5RXJyb3IiLCJhY3Rpb24iLCJyZXRyeUNvdW50IiwidGltZW91dCIsIk1hdGgiLCJwb3ciLCJzZXRUaW1lb3V0Iiwia0ludGVybmFsMiIsInVzZUNhbGxiYWNrMiIsInVzZUNvbnRleHQyIiwidXNlRWZmZWN0NCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlMiIsInNoYWxsb3ciLCJhZGRSZWFjdGlvbiIsIkNvbW1lbnRzQXBpRXJyb3IiLCJjb25zb2xlIiwiY29uc29sZTIiLCJkZWxldGVDb21tZW50IiwiZGVwcmVjYXRlSWYiLCJlcnJvcklmIiwiaXNMaXZlTm9kZSIsIm1ha2VFdmVudFNvdXJjZSIsIk5vdGlmaWNhdGlvbnNBcGlFcnJvciIsInJlbW92ZVJlYWN0aW9uIiwiU2VydmVyTXNnQ29kZSIsInN0cmluZ2lmeSIsInVwc2VydENvbW1lbnQiLCJuYW5vaWQyIiwiUmVhY3QyIiwiQ3JlYXRlVGhyZWFkRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY2F1c2UiLCJjb250ZXh0IiwibmFtZSIsIkVkaXRUaHJlYWRNZXRhZGF0YUVycm9yIiwiQ3JlYXRlQ29tbWVudEVycm9yIiwiRWRpdENvbW1lbnRFcnJvciIsIkRlbGV0ZUNvbW1lbnRFcnJvciIsIkFkZFJlYWN0aW9uRXJyb3IiLCJSZW1vdmVSZWFjdGlvbkVycm9yIiwiTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkRXJyb3IiLCJVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc0Vycm9yIiwiVEhSRUFEX0lEX1BSRUZJWCIsIkNPTU1FTlRfSURfUFJFRklYIiwiY3JlYXRlT3B0aW1pc3RpY0lkIiwicHJlZml4IiwiY3JlYXRlVGhyZWFkSWQiLCJjcmVhdGVDb21tZW50SWQiLCJhcHBseU9wdGltaXN0aWNVcGRhdGVzMiIsIm5uIiwic2VsZWN0Tm90aWZpY2F0aW9uU2V0dGluZ3MiLCJyb29tSWQiLCJub3RpZmljYXRpb25TZXR0aW5ncyIsImFwcGx5T3B0aW1pc3RpY1VwZGF0ZXMzIiwic2VsZWN0ZWRUaHJlYWRzIiwib3B0aW9ucyIsInRocmVhZHMiLCJmaWx0ZXIiLCJ0aHJlYWQiLCJkZWxldGVkQXQiLCJxdWVyeSIsImtleSIsIm1ldGFkYXRhIiwiY3JlYXRlZEF0IiwidXNlU3RhdGUyIiwidXNlSW5pdGlhbCIsInZhbHVlIiwidXNlRWZmZWN0MiIsInVzZVJlZiIsInVzZUxhdGVzdCIsInJlZiIsImN1cnJlbnQiLCJ1c2VSZWR1Y2VyIiwidXNlUmVyZW5kZXIiLCJ1cGRhdGUiLCJ4Iiwibm9vcCIsImlkZW50aXR5IiwibWlzc2luZ191bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsInJlYWN0VmVyc2lvbiIsIkpTT04iLCJzdXBlcmZsdW91c191bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsInMiLCJncyIsImdzcyIsIlNUQUJMRV9FTVBUWV9MSVNUIiwiZnJlZXplIiwiUE9MTElOR19JTlRFUlZBTCIsIk1FTlRJT05fU1VHR0VTVElPTlNfREVCT1VOQ0UiLCJhbHdheXNFbXB0eUxpc3QiLCJhbHdheXNOdWxsIiwibWFrZU11dGF0aW9uQ29udGV4dCIsInJvb20iLCJlcnJtc2ciLCJzdG9yYWdlIiwibXV0YWJsZVJvb3QiLCJnZXRTdG9yYWdlU25hcHNob3QiLCJzZWxmIiwiZ2V0U2VsZiIsIm90aGVycyIsImdldE90aGVycyIsInNldE15UHJlc2VuY2UiLCJ1cGRhdGVQcmVzZW5jZSIsIkNvbnRleHRCdW5kbGUiLCJ1c2VSb29tQ29udGV4dEJ1bmRsZSIsImJ1bmRsZSIsImNyZWF0ZVJvb21Db250ZXh0IiwiY2xpZW50IiwicmVzb2x2ZVVzZXJzIiwicmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyIsIlJvb21Db250ZXh0IiwiY29tbWVudHNFcnJvckV2ZW50U291cmNlIiwic2hhcmVkIiwiY3JlYXRlU2hhcmVkQ29udGV4dCIsIlJvb21Qcm92aWRlck91dGVyIiwiY2FjaGUiLCJNYXAiLCJzdGFibGVFbnRlclJvb20iLCJvcHRpb25zMiIsImNhY2hlZCIsImdldCIsInJ2IiwiZW50ZXJSb29tIiwib3JpZ0xlYXZlIiwibGVhdmUiLCJkZWxldGUiLCJzZXQiLCJSb29tUHJvdmlkZXJJbm5lciIsImlkIiwicHJvY2VzcyIsIm1ham9yUmVhY3RWZXJzaW9uIiwicGFyc2VJbnQiLCJ2ZXJzaW9uIiwib2xkUmVhY3RWZXJzaW9uIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJmcm96ZW5Qcm9wcyIsImluaXRpYWxQcmVzZW5jZSIsImluaXRpYWxTdG9yYWdlIiwiYXV0b0Nvbm5lY3QiLCJzaG91bGRJbml0aWFsbHlDb25uZWN0Iiwid2luZG93Iiwic2V0Um9vbUxlYXZlUGFpciIsImhhbmRsZUNvbW1lbnRFdmVudCIsIm1lc3NhZ2UiLCJpbmZvIiwiY29tbWVudHMiLCJnZXRUaHJlYWQiLCJ0aHJlYWRJZCIsInN0b3JlIiwiZGVsZXRlVGhyZWFkIiwiaW5ib3hOb3RpZmljYXRpb24iLCJleGlzdGluZ1RocmVhZCIsInR5cGUiLCJDT01NRU5UX0VESVRFRCIsIlRIUkVBRF9NRVRBREFUQV9VUERBVEVEIiwiQ09NTUVOVF9SRUFDVElPTl9BRERFRCIsIkNPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRCIsIkNPTU1FTlRfREVMRVRFRCIsInVwZGF0ZVRocmVhZEFuZE5vdGlmaWNhdGlvbiIsIkNPTU1FTlRfQ1JFQVRFRCIsImV2ZW50cyIsInN1YnNjcmliZSIsImdldFRocmVhZHNVcGRhdGVzIiwiaGFuZGxlSXNPbmxpbmUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInBhaXIiLCJyb29tMiIsImNvbm5lY3QiLCJQcm92aWRlciIsImNvbm5lY3Rpb25JZFNlbGVjdG9yIiwibWFwIiwidXNlciIsImNvbm5lY3Rpb25JZCIsInVzZVJvb20iLCJ1c2VTdGF0dXMiLCJzdGF0dXMiLCJnZXRTbmFwc2hvdCIsImdldFN0YXR1cyIsImdldFNlcnZlclNuYXBzaG90IiwidXNlTXlQcmVzZW5jZSIsIm15UHJlc2VuY2UiLCJnZXRQcmVzZW5jZSIsInByZXNlbmNlIiwic2V0UHJlc2VuY2UiLCJ1c2VVcGRhdGVNeVByZXNlbmNlIiwidXNlT3RoZXJzIiwic2VsZWN0b3IiLCJpc0VxdWFsIiwidXNlT3RoZXJzQ29ubmVjdGlvbklkcyIsInVzZU90aGVyc01hcHBlZCIsIml0ZW1TZWxlY3RvciIsIml0ZW1Jc0VxdWFsIiwid3JhcHBlZFNlbGVjdG9yIiwib3RoZXIiLCJ3cmFwcGVkSXNFcXVhbCIsImVxIiwiaXMiLCJsZW5ndGgiLCJldmVyeSIsImF0dXBsZSIsImluZGV4IiwiYnR1cGxlIiwiTk9UX0ZPVU5EIiwiU3ltYm9sIiwidXNlT3RoZXIiLCJvdGhlcjIiLCJmaW5kIiwib3RoZXIzIiwicHJldiIsImN1cnIiLCJ1c2VCcm9hZGNhc3RFdmVudCIsImV2ZW50Iiwic2hvdWxkUXVldWVFdmVudElmTm90UmVhZHkiLCJicm9hZGNhc3RFdmVudCIsInVzZU90aGVyc0xpc3RlbmVyIiwiY2FsbGJhY2siLCJzYXZlZENhbGxiYWNrIiwidXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lciIsImxvc3RDb25uZWN0aW9uIiwidXNlRXJyb3JMaXN0ZW5lciIsImVycm9yIiwiZSIsInVzZUV2ZW50TGlzdGVuZXIiLCJsaXN0ZW5lciIsImV2ZW50RGF0YSIsImN1c3RvbUV2ZW50IiwidXNlU2VsZiIsIm1heWJlU2VsZWN0b3IiLCJtZSIsInVzZU11dGFibGVTdG9yYWdlUm9vdCIsInN0b3JhZ2VEaWRMb2FkIiwic3Vic2NyaWJlT25jZSIsInVzZVN0b3JhZ2VSb290IiwidXNlSGlzdG9yeSIsImhpc3RvcnkiLCJ1c2VVbmRvIiwidW5kbyIsInVzZVJlZG8iLCJyZWRvIiwidXNlQ2FuVW5kbyIsImNhblVuZG8iLCJ1c2VDYW5SZWRvIiwiY2FuUmVkbyIsInVzZUJhdGNoIiwiYmF0Y2giLCJ1c2VMZWdhY3lLZXkiLCJyb290T3JOdWxsIiwicmVyZW5kZXIiLCJyb290IiwidW5zdWJDdXJyIiwic3Vic2NyaWJlVG9DdXJyIiwib25Sb290Q2hhbmdlIiwibmV3VmFsdWUiLCJ1bnN1YnNjcmliZVJvb3QiLCJ1c2VTdG9yYWdlIiwicm9vdE9yTnVsbDIiLCJvblN0b3JlQ2hhbmdlIiwiaXNEZWVwIiwiaW1tIiwidG9JbW11dGFibGUiLCJlbnN1cmVOb3RTZXJ2ZXJTaWRlIiwidXNlU3VzcGVuZFVudGlsU3RvcmFnZUxvYWRlZCIsIlByb21pc2UiLCJyZXMiLCJ1c2VTdXNwZW5kVW50aWxQcmVzZW5jZUxvYWRlZCIsInVzZU11dGF0aW9uIiwiZGVwcyIsInVzZU1lbW8iLCJhcmdzIiwidXNlU3RvcmFnZVN1c3BlbnNlIiwidXNlU2VsZlN1c3BlbnNlIiwidXNlT3RoZXJzU3VzcGVuc2UiLCJ1c2VPdGhlcnNDb25uZWN0aW9uSWRzU3VzcGVuc2UiLCJ1c2VPdGhlcnNNYXBwZWRTdXNwZW5zZSIsInVzZU90aGVyU3VzcGVuc2UiLCJ1c2VMZWdhY3lLZXlTdXNwZW5zZSIsImNhY2hlU3RvcmUiLCJvbk11dGF0aW9uRmFpbHVyZSIsImlubmVyRXJyb3IiLCJvcHRpbWlzdGljVXBkYXRlSWQiLCJjcmVhdGVQdWJsaWNFcnJvciIsIm9wdGltaXN0aWNVcGRhdGVzIiwiaGFuZGxlQXBpRXJyb3IiLCJub3RpZnkiLCJzdWJzY3JpYmVyc0J5UXVlcnkiLCJyZXF1ZXN0c0J5UXVlcnkiLCJwb2xsZXIiLCJyZWZyZXNoVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnMiLCJyZXF1ZXN0cyIsImdldFJvb21JZHMiLCJnZXRSb29tIiwicHVzaCIsImFsbFNldHRsZWQiLCJpbmNyZW1lbnRRdWVyeVN1YnNjcmliZXJzIiwicXVlcnlLZXkiLCJzdWJzY3JpYmVycyIsInN0YXJ0IiwiZGVjcmVtZW50UXVlcnlTdWJzY3JpYmVycyIsIndhcm4iLCJ0b3RhbFN1YnNjcmliZXJzIiwic3Vic2NyaWJlcnMyIiwic3RvcCIsImdldFRocmVhZHNBbmRJbmJveE5vdGlmaWNhdGlvbnMiLCJleGlzdGluZ1JlcXVlc3QiLCJyZXF1ZXN0IiwiZ2V0VGhyZWFkcyIsInNldFF1ZXJ5U3RhdGUiLCJpc0xvYWRpbmciLCJ1cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyIsImRlbGV0ZWRUaHJlYWRzIiwiZGVsZXRlZEluYm94Tm90aWZpY2F0aW9ucyIsImxhc3RSZXF1ZXN0ZWRBdCIsImxhc3RSZXF1ZXN0ZWRBdEJ5Um9vbSIsIm1ldGEiLCJyZXF1ZXN0ZWRBdCIsImVyciIsIkRFRkFVTFRfREVEVVBJTkdfSU5URVJWQUwiLCJyZXF1ZXN0U3RhdHVzQnlSb29tIiwic2luY2UiLCJpc0ZldGNoaW5nVGhyZWFkc1VwZGF0ZXMiLCJ1cGRhdGVzIiwidXNlVGhyZWFkcyIsImdlbmVyYXRlUXVlcnlLZXkiLCJxdWVyaWVzIiwidXNlVGhyZWFkc1N1c3BlbnNlIiwidXNlQ3JlYXRlVGhyZWFkIiwiYm9keSIsImNvbW1lbnRJZCIsIkRhdGUiLCJuZXdDb21tZW50IiwidXNlcklkIiwiZ2V0Q3VycmVudFVzZXJJZCIsInJlYWN0aW9ucyIsIm5ld1RocmVhZCIsInVwZGF0ZWRBdCIsInB1c2hPcHRpbWlzdGljVXBkYXRlIiwiY3JlYXRlVGhyZWFkIiwidGhlbiIsImVycjIiLCJ1c2VFZGl0VGhyZWFkTWV0YWRhdGEiLCJlZGl0VGhyZWFkTWV0YWRhdGEiLCJtZXRhZGF0YTIiLCJ1cGRhdGVkT3B0aW1pc3RpY1VwZGF0ZXMiLCJ1c2VBZGRSZWFjdGlvbiIsImVtb2ppIiwicmVhY3Rpb24iLCJhZGRlZFJlYWN0aW9uIiwidXNlUmVtb3ZlUmVhY3Rpb24iLCJyZW1vdmVkQXQiLCJ1c2VDcmVhdGVDb21tZW50IiwiY29tbWVudCIsImNyZWF0ZUNvbW1lbnQiLCJub3RpZmljYXRpb24iLCJ1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zIiwicmVhZEF0IiwidXNlRWRpdENvbW1lbnQiLCJlZGl0ZWRBdCIsImNvbW1lbnQyIiwiZWRpdENvbW1lbnQiLCJlZGl0ZWRDb21tZW50IiwidXNlRGVsZXRlQ29tbWVudCIsIm1lbnRpb25TdWdnZXN0aW9uc0NhY2hlIiwidXNlTWVudGlvblN1Z2dlc3Rpb25zIiwic2VhcmNoIiwibWVudGlvblN1Z2dlc3Rpb25zIiwic2V0TWVudGlvblN1Z2dlc3Rpb25zIiwibGFzdEludm9rZWRBdCIsInJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnNBcmdzIiwidGV4dCIsIm1lbnRpb25TdWdnZXN0aW9uc0NhY2hlS2V5IiwiZGVib3VuY2VUaW1lb3V0IiwiaXNDYW5jZWxlZCIsImdldE1lbnRpb25TdWdnZXN0aW9ucyIsInBlcmZvcm1hbmNlIiwibm93IiwibWVudGlvblN1Z2dlc3Rpb25zMiIsImhhcyIsImFicyIsImNsZWFyVGltZW91dCIsInVzZVRocmVhZFN1YnNjcmlwdGlvbiIsImluYm94Tm90aWZpY2F0aW9uMiIsInVucmVhZFNpbmNlIiwidXNlTWFya1RocmVhZEFzUmVhZCIsImluYm94Tm90aWZpY2F0aW9uSWQiLCJub3RpZmljYXRpb25zIiwibWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkIiwibWFrZU5vdGlmaWNhdGlvblNldHRpbmdzUXVlcnlLZXkiLCJnZXRJbmJveE5vdGlmaWNhdGlvblNldHRpbmdzIiwiZ2V0Um9vbU5vdGlmaWNhdGlvblNldHRpbmdzIiwic2V0dGluZ3MiLCJ1cGRhdGVSb29tSW5ib3hOb3RpZmljYXRpb25TZXR0aW5ncyIsInVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyIsInVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyIsInVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyIsInVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc1N1c3BlbnNlIiwic2V0dGluZ3MyIiwidXNlQ3VycmVudFVzZXJJZCIsIlJvb21Qcm92aWRlciIsInVzZUxpc3QiLCJ1c2VNYXAiLCJ1c2VPYmplY3QiLCJzdXNwZW5zZSIsImhhc1Jlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJkZXRhaWxzIiwiZGV0YWlsZWRNZXNzYWdlIiwic3VnZ2VzdGlvbiIsImRvY3MiLCJCb29sZWFuIiwiam9pbiIsInVzZVNoYXJlZENvbnRleHRCdW5kbGUiLCJyb29tQ29udGV4dEJ1bmRsZSIsImxpdmVibG9ja3NDb250ZXh0QnVuZGxlIiwiQ29udGV4dEJ1bmRsZTIiLCJ1c2Vyc1N0b3JlIiwicm9vbXNJbmZvU3RvcmUiLCJ1c2VVc2VyIiwiZ2V0VXNlclN0YXRlIiwiZ2V0U3RhdGUiLCJkYXRhIiwidXNlVXNlclN1c3BlbnNlIiwidXNlclN0YXRlIiwidXNlUm9vbUluZm8iLCJnZXRSb29tSW5mb1N0YXRlIiwidXNlUm9vbUluZm9TdXNwZW5zZSIsInJvb21JbmZvU3RhdGUiLCJ1c2VMaXZlYmxvY2tzQ29udGV4dEJ1bmRsZSIsIlBPTExJTkdfSU5URVJWQUwyIiwiSU5CT1hfTk9USUZJQ0FUSU9OU19RVUVSWSIsImNyZWF0ZUxpdmVibG9ja3NDb250ZXh0IiwiTGl2ZWJsb2Nrc1Byb3ZpZGVyIiwiZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnNSZXF1ZXN0IiwiaW5ib3hOb3RpZmljYXRpb25zU3Vic2NyaWJlcnMiLCJnZXRJbmJveE5vdGlmaWNhdGlvbnMiLCJpbmNyZW1lbnRJbmJveE5vdGlmaWNhdGlvbnNTdWJzY3JpYmVycyIsImRlY3JlbWVudEluYm94Tm90aWZpY2F0aW9uc1N1YnNjcmliZXJzIiwiZmV0Y2hJbmJveE5vdGlmaWNhdGlvbnMiLCJlciIsInVzZUluYm94Tm90aWZpY2F0aW9uc1NlbGVjdG9yQ2FsbGJhY2siLCJ1c2VJbmJveE5vdGlmaWNhdGlvbnMiLCJ1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZVNlbGVjdG9yIiwidXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2UiLCJzZWxlY3RVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCIsImNvdW50IiwidXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTZWxlY3RvciIsInVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50IiwidXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZVNlbGVjdG9yIiwidXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZSIsInVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCIsImV4aXN0aW5nTm90aWZpY2F0aW9uIiwidXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCIsIm1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQiLCJmcm9tRW50cmllcyIsIkFycmF5IiwiZnJvbSIsImVudHJpZXMiLCJ1c2VUaHJlYWRGcm9tQ2FjaGUiLCJjdXJyZW50VXNlcklkU3RvcmUiLCJzaGFsbG93MiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@liveblocks/react/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/nanoid/index.browser.js":
/*!**********************************************!*\
  !*** ./node_modules/nanoid/index.browser.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: function() { return /* binding */ customAlphabet; },\n/* harmony export */   customRandom: function() { return /* binding */ customRandom; },\n/* harmony export */   nanoid: function() { return /* binding */ nanoid; },\n/* harmony export */   random: function() { return /* binding */ random; },\n/* harmony export */   urlAlphabet: function() { return /* reexport safe */ _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__.urlAlphabet; }\n/* harmony export */ });\n/* harmony import */ var _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url-alphabet/index.js */ \"(app-pages-browser)/./node_modules/nanoid/url-alphabet/index.js\");\n\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nlet nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uYW5vaWQvaW5kZXguYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ2lFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uYW5vaWQvaW5kZXguYnJvd3Nlci5qcz84OTI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVybEFscGhhYmV0IH0gZnJvbSAnLi91cmwtYWxwaGFiZXQvaW5kZXguanMnXG5sZXQgcmFuZG9tID0gYnl0ZXMgPT4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlcykpXG5sZXQgY3VzdG9tUmFuZG9tID0gKGFscGhhYmV0LCBkZWZhdWx0U2l6ZSwgZ2V0UmFuZG9tKSA9PiB7XG4gIGxldCBtYXNrID0gKDIgPDwgKE1hdGgubG9nKGFscGhhYmV0Lmxlbmd0aCAtIDEpIC8gTWF0aC5MTjIpKSAtIDFcbiAgbGV0IHN0ZXAgPSAtfigoMS42ICogbWFzayAqIGRlZmF1bHRTaXplKSAvIGFscGhhYmV0Lmxlbmd0aClcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSAnJ1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgYnl0ZXMgPSBnZXRSYW5kb20oc3RlcClcbiAgICAgIGxldCBqID0gc3RlcFxuICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICBpZCArPSBhbHBoYWJldFtieXRlc1tqXSAmIG1hc2tdIHx8ICcnXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IHNpemUpIHJldHVybiBpZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxubGV0IGN1c3RvbUFscGhhYmV0ID0gKGFscGhhYmV0LCBzaXplID0gMjEpID0+XG4gIGN1c3RvbVJhbmRvbShhbHBoYWJldCwgc2l6ZSwgcmFuZG9tKVxubGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+XG4gIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpLnJlZHVjZSgoaWQsIGJ5dGUpID0+IHtcbiAgICBieXRlICY9IDYzXG4gICAgaWYgKGJ5dGUgPCAzNikge1xuICAgICAgaWQgKz0gYnl0ZS50b1N0cmluZygzNilcbiAgICB9IGVsc2UgaWYgKGJ5dGUgPCA2Mikge1xuICAgICAgaWQgKz0gKGJ5dGUgLSAyNikudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKClcbiAgICB9IGVsc2UgaWYgKGJ5dGUgPiA2Mikge1xuICAgICAgaWQgKz0gJy0nXG4gICAgfSBlbHNlIHtcbiAgICAgIGlkICs9ICdfJ1xuICAgIH1cbiAgICByZXR1cm4gaWRcbiAgfSwgJycpXG5leHBvcnQgeyBuYW5vaWQsIGN1c3RvbUFscGhhYmV0LCBjdXN0b21SYW5kb20sIHVybEFscGhhYmV0LCByYW5kb20gfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/nanoid/index.browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/nanoid/url-alphabet/index.js":
/*!***************************************************!*\
  !*** ./node_modules/nanoid/url-alphabet/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   urlAlphabet: function() { return /* binding */ urlAlphabet; }\n/* harmony export */ });\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uYW5vaWQvdXJsLWFscGhhYmV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ3NCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uYW5vaWQvdXJsLWFscGhhYmV0L2luZGV4LmpzP2UzMmMiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG5leHBvcnQgeyB1cmxBbHBoYWJldCB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/nanoid/url-alphabet/index.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Ccode-files%5Cfigpro%5Capp%5CRoom.tsx&modules=C%3A%5Ccode-files%5Cfigpro%5Cnode_modules%5Cnext%5Cfont%5Cgoogle%5Ctarget.css%3F%7B%22path%22%3A%22app%5C%5Clayout.tsx%22%2C%22import%22%3A%22Work_Sans%22%2C%22arguments%22%3A%5B%7B%22subsets%22%3A%5B%22latin%22%5D%2C%22variable%22%3A%22--font-work-sans%22%2C%22weight%22%3A%5B%22400%22%2C%22600%22%2C%22700%22%5D%7D%5D%2C%22variableName%22%3A%22workSans%22%7D&modules=C%3A%5Ccode-files%5Cfigpro%5Capp%5Cglobals.css&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);